1. Note
C++11中新增了一种引用：所谓的"右值引用"，这种引用主要用于内置类；严格来说，当我们使用术语"引用"时，其实是指"左值引用"。

2. 引用为对象起了另外一个名字。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：
<1>eg： 
int ival = 1024;
int &refVal = ival;		//refVal指向ival(是ival的另一个名字)
int &refVal2;			//报错：引用必须被初始化

<2>一般在初始化变量时，初始值会被拷贝到新建的对象中。
然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。

<3>因为无法令引用重新绑定到另一个对象，因此引用必须初始化。

3. 引用即别名
<1>引用并非对象，相反，它只是为一个已经存在的对象所起的另外一个名字。
定义一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。

4. 引用的定义
<1>允许在一条语句中定义多个引用，其中每个引用标识符都必须以&开头：
int &r3 = i3, &r4 = i2; //r3、r4都是引用
int &r = i, r2 = i2; //r是引用，与i绑定；r2是int

<2>除了2.4.1和15.2.3两种列外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。
引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

<3>eg:
int &refVal4 = 10; //错误：引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval; //错误：此处引用类型的初始值必须是int型对象

5. (2.4.1)对const的引用(也称为"常量引用")
<1>可以把引用绑定到const对象上，称为 对常量的引用。
与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。

eg:
const int ci = 1024;
const int &r1 = ci; //正确：引用及其对应的对象都是常量
r1 = 42;			//错误：r1是对常量的引用
int &r2 = ci;		//错误：试图让一个非常量引用指向一个常量对象

<2>初始化和对const的引用
- 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。
尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般的表达式。

<3>对const的引用可能引用一个并非const的对象
常量引用仅仅是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量并未作限定。


