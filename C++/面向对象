一、面向对象程序设计的核心思想是数据抽象、继承和动态绑定。
1、继承
<1>虚函数
1)对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。
2)作为继承关系中根节点的类通常都会定义一个虚析构函数。
3)当使用指针或引用调用虚函数时，该调用将被动态绑定。
根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行派生类的版本。
4)任何构造函数之外的非静态函数都可以是虚函数。
5)关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
6)如果基类把一个函数声明成虚函数，该函数在派生类中隐式地也是虚函数。
7)成员函数如果没有被声明为虚函数，其解析过程发生在编译时而非运行时。

<2>访问控制与继承
1)派生类能够访问基类的共有成员，不能访问基类的私有成员。
受保护protected：基类希望派生类有权访问该成员，同时禁止其他用户访问。
2)公有继承，基类的公有成员也是派生类接口的组成部分。
因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象使用。
可以将公有派生类的对象绑定到基类的引用或指针上。
3)如果派生类没有覆盖基类中的某个虚函数，那么与普通成员类似，派生类会直接继承其在基类中的版本。
4)派生类可以显式地注明它使用某个成员函数覆盖了继承的虚函数，具体做法是在形参列表后面添加关键字override。
5)尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。
派生类必须使用基类的构造函数来初始化它的基类部分。
//每个类控制自己的成员初始化过程。
派生类构造函数是通过构造初始化列表来将实参传递给基类的构造函数的。
Bulk_quote(const std::string & book, double p, std::size_t qty, double disc):
    Quote(book, p), min_qty(qty), discount(disc) { }

<3>继承与静态成员
如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。
无论从基类派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例。

<4>被用作基类的类
1)如果想将某个类用作基类，则该类必须已经定义而非仅仅声明。
该规定还有一层隐含的意思，即一个类不能派生它本身。

2)派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

<5>防止继承的发生
在类名后跟关键字final。
class NoDerived final{/**/};

2、类型转换与继承
<1>可以将基类的指针或引用绑定到派生类对象上。
1)当使用基类的引用或指针时，实际上我们并不清楚该引用或指针所绑定的对象的真实类型。
该对象可能是基类的对象，也可能是派生类的对象。

<2>静态类型与动态类型
如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。

<3>不存在从基类向派生类的隐式类型转换
否则就会访问基类中根本不存在的派生类成员。

<4>...对象之间不存在类型转换
派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。
当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生部分将会被忽略。

3、纯虚函数与抽象类
http://blog.csdn.net/hackbuteer1/article/details/7558868












