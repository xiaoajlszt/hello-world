15.1 OOP概述
面向对象程序设计的核心思想是数据抽象、继承和动态绑定。
- 通过使用数据抽象，可以将类的接口与实现分离；
- 通过使用继承，可以定义相似的类型并对其相似关系建模；
- 通过使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。//动态绑定也称为运行时绑定

1. 继承
基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

2. 动态绑定
当使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。	//需要派生类是公有派生类型

15.2 定义基类和派生类
15.2.1 定义基类
作为继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不执行任何实际操作。

1. 成员函数与继承
<1>基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。
对于前者，基类通常将其定义为虚函数。

<2>任何构造函数之外的非静态函数都可以是虚函数。
//关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。

<3>如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。

<4>成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。

2. 访问控制与集成
<1>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。
- 同其他用户访问一样，派生类能访问公有成员，而不能访问私有成员。
- protected：派生类有权访问该成员，同时禁止其他用户访问。

15.2.2 定义派生类
1. 派生类必须通过使用类派生列表明确指出它是从哪些基类继承而来的。
//首先是冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符(public、protected、private)。

2. 访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。
<1>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。
<2>能将公有派生类型的对象绑定到基类的引用或指针上。

3. 派生类中的虚函数
<1>派生类经常(但不总是)覆盖它继承的虚函数。
如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通函数，派生类会直接继承其在基类中的版本。

<2>派生类可以在这样的函数之前加上virtual关键字，但并不是非得这么做。

<2>C++新标准允许派生类显示地注明它将使用哪个成员函数改写基类的虚函数。
具体措施是在 该函数的形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面 增加override关键字。

4. 派生类对象及派生类向基类的类型转换
<1>一个派生类对象包含多个组成部分：
- 一个含有派生类自己定义的(非静态)成员的子对象；
- 一个与基类对应的子对象；//如果有多个基类，这样的子对象也有多个

//在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

<2>因为派生类对象中含有与基类对应的组成部分，所以能把派生类的对象当成基类对象来使用。
而且能将基类的指针或引用绑定到派生类对象中的基类部分上。

eg:
Quote item;			//基类对象
Bulk_quote bulk;	//派生类对象
Quote *p = &item;	//p指向Quote对象
p = &bulk;			//p指向bulk的Quote部分
Quote &r = bulk;	//r绑定到bulk的Quote部分

这种转换通常称为派生类到积累的类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换。

5. 派生类构造函数
<1>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。

<2>派生类构造函数是通过构造函数初始化列表将实参传递给基类构造函数的。
eg:
Bulk_quote(/**/):Quote(bookNo,price),min_qty(qty),dicount(disc){}
//Quote的构造函数负责初始化Bulk_quote对象的基类部分。当Quote构造函数的函数体结束后，对象的基类部分也就完成了初始化，接下来初始化由派生类直接定义的成员。
最后运行Bulk_quote构造函数的函数体。

6. 派生类使用基类的成员
<1>派生类可以访问基类的公有成员和受保护成员。

<2>遵循基类的接口
尽管从语法上来说可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。
派生类应该遵循基类的接口，通过调用基类的构造函数来初始化那些从基类中继承而来的成员。

7. 继承与静态成员
<1>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论有多少派生类，对于静态成员来说都只存在唯一的实例。

<2>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。
假设某静态成员是可访问的，则既能通过基类使用它也能通过派生类使用它。//也可以通过类对象(引用)、指针使用它。

8. 派生类的声明
<1>声明中包含类名但不包含它的派生列表。

9. 被用作基类的类
<1>如果要将某个类用作基类，则该类必须已经定义而非是仅仅声明。

10. 防止继承的发生
<1>C++11新标准提供了一种防止继承发生的方法，即在类名之后跟一个关键字final。

15.2.3 类型转换与继承
1. 静态类型与动态类型
<1>静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；

<2>动态类型则是变量或表达式的内存中的对象的类型，动态类型知道运行时才可知。

<3>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。

2. 不存在从基类向派生类的隐式类型转换......
<1>一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。

<2>即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类向派生类的转换：
Bulk_quote bulk;
Quote *itemP = &bulk;		//正确：动态类型是Bulk_quote
Bukl_quote *bulkP = itemP;  //错误：不能将基类转换为派生类

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。
- 如果基类中含有一个或多个虚函数，可以使用dynamic_cast(19.2.1)请求一个类型转换，该转换的安全检查将在运行时执行；
- 如果已经某个基类向派生类的转换是安全的，则可以使用static_cast(4.11.3)来强制覆盖掉编译器的检查工作。

3. ......在对象之间不存在类型转换
<1>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。
//派生类对象转换成基类类型实际转换过程往往与预期有所差别。
