7.1 定义抽象数据类型
1. 成员函数的定义和声明
成员函数的声明必须在类的内部，定义既可以在类的内部也可以在类的外部。
非成员函数，它们的定义和声明都在类的外部。

定义在类内部的函数是隐式的inline函数。

2. this
<1>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。
当调用一个成员函数时，用请求该函数的对象地址初始化this。

eg:
total.isbn();
编译器负责把total的地址传递给isbn的隐式形参this。

<2>在成员函数内部，可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点。
因为this所指的正是这个对象。任何对类成员的直接访问都被看作this的隐式引用。

eg:
std::string isbn() const {return bookNo;}	//这是一个成员函数
total.isbn();
//实际上隐式返回total.bookNo

<3>对于我们来说this形参是隐式定义的。任何自定义名为this的参数或变量的行为都是非法的。

eg: 我们可以在成员函数体内部使用this，尽管没有必要。
std::string isbn() const {return this->bookNo;}

<4>因为this总是指向某个对象，所以this是一个常量指针(const指针，指针本身是const)。不允许改变this中保存的地址。

3. const成员函数
<1>默认情况下，this的类型是指向类类型非常量版本的常量指针(const指针，指针本身是const)。
尽管this是隐式的，但它仍需遵循初始化规则，即默认情况下不能把this绑定到一个常量对象上。
也就是说，默认情况下，不能在一个常量对象上调用普通的成员函数。

eg:
Sales_data类的成员函数中，this的类型是：Sales_data *const。

<2>紧跟在参数列表后面的const表示this是一个指向常量的指针。
std::string isbn() const {return bookNo;}
//这样的成员函数被称作常量成员函数。
//因为this指向常量，所以常量成员函数不能改变调用它的对象的内容。

<3>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

4. 类的作用域和成员函数
编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数。
因此，成员函数可以随意使用类中的其他成员，而无须在意这些成员出现的次序。

7.1.4. 构造函数
1. 类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。
- 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数;
- 构造函数的名字与类名相同;
- 构造函数没有返回类型;
- 类可以有多个构造函数，和其他重载函数差不多，不同构造函数之间必须在参数数量或参数类型上区别;
- 构造函数不能被声明为const，但它仍然可用于初始化常量对象。
//创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其"常量"属性，构造函数在const对象的构造过程中可以向其写值。

2. 合成的默认构造函数
<1>如果类中没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。
编译器创建的构造函数又被称为合成的默认构造函数。按照如下规则初始化类对象：
1)如果存在类内的初始值，用它来初始化成员;	//在数据成员定义处
2)否则，默认初始化该成员。

3. 某些类不能依赖于合成的默认构造函数
<1>合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数。
- 编译器只有在发现类不包括任何构造函数的情况下才会生成一个默认构造函数。一旦定义了一些构造函数，除非自定义一个默认的构造函数，否则该类将没有默认构造函数。 

- 对于某些类来说，合成的默认构造函数可能执行错误的操作。
(2.2.1)定义在块中的内置类型或复合类型(如：数组和指针)的对象被默认初始化，则它们的值将是未定义的。
该准则同样适用于默认初始化的内置类型成员。因此，含有内置类型或复合类型的成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。
否则，用户在创建类的对象时就可能得到未定义的值。
//如果类包含内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合使用合成的默认构造函数。

- 有时编译器不能为某些类合成默认的构造函数。对于这样的类，必须自定义默认构造函数。否则，该类将没有可用的默认构造函数。
eg: 类中包含一个其他类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。

4. = defult 的含义
Sales_data() = default;		//自定义默认构造函数
<1>因为该构造函数不接受任何实参，所以它是一个默认构造函数。
<2>定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。这个函数的作用完全等同于之前使用的合成默认构造函数。
<3>C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 = default 来要求编译器生成构造函数。
= default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。

5. 构造函数初始值列表
Sales_data(const std::string &s): bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
//当数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。

6. 在类的外部定义构造函数

7.1.5 拷贝、赋值和析构
1. 如果不主动定义这些操作，编译器将替我们合成它们。

2. 某些类不能依赖于合成的版本
<1>特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。
//管理动态内存的类通常不能依赖合成版本。

<2>很多需要动态内存的类能(而且应该)使用vector对象或者string对象管理必要的存储空间，这样可以避免分配和释放内存带来的复杂性。
//如果类包含vector或者string成员，则其拷贝、赋值、销毁的合成版本都能正常工作。

7.2 访问控制与封装
1. 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口；
2. 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了(隐藏了)类的实现细节。

3. 使用class或struct关键字
<1>可以使用这两个关键字中的任何一个定义类。唯一的区别是，它们的默认访问权限不同。
<2>类可以再它的第一个访问说明符之前定义成员，其访问权限依赖于类的定义方式。
struct : public
class  : private

7.2.1 友元
1. 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。
<1>把一个函数作为类的友元，只需要在类中增加一条以friend关键字开始的函数声明语句即可。
//友元声明只能出现在类定义的内部，具体位置不限。
//友元不是类的成员，不受它所在区域访问控制级别的约束。
//一般来说，最好在类定义开始或结束前的位置集中声明友元。

2. 友元的声明
友元的声明仅仅指定了访问的权限，而非函数声明。
如果希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

<1>为了使友元对类的用户可见，通常把友元的函数声明与类本身放置在同一个头文件中(类的外部)。

7.3.3 类类型
1. 每个类定义了唯一的类型。
<1>即使两个类的成员列表完全一致，它们也是不同的类型。
<2>可以把类名作为类型的名字使用；也可以把类名跟在关键字class或struct后面。

2. 类的声明
class Screen; //仅仅声明Screen类而暂时不定义它

<1>这种声明有时被称为前向声明，它向程序中引入名字Screen并指明Screen是一种类类型。
对于Screen来说，在它 声明之后、定义之前 是一个不完全类型。也就是说不清楚它到底包含哪些成员。

<2>不完全类型只能在非常有限的情景下使用：
- 可以定义指向这种类型的指针或引用
- 可以声明(但不能定义)以不完全类型作为参数或返回类型的函数

<3>对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。
//所以一个类的成员类型不能是该类自己。
//但允许类包含指向自身类型的引用或指针。
eg:
class Link_screen {
	Screen Window;
	Link_screen *next;
	Link_screen *prev;
}


7.3.4 友元再探
类还可以把其他类定义成友元，也可以把其他类的成员函数定义成友元。

1. 类之间的友元关系
eg: Window_mgr类的某些成员可能需要访问Screen类的私有数据，则Screen需要把Window_mgr指定成它的友元：
class Screen {
	friend class Window_mgr;
	//Screen类的剩余部分
};

<1>友元类的成员函数可以访问此类的所有成员。

<2>友元关系不存在传递性。

2. 令成员函数作为友元
eg:
class Screen {
	friend void Window_mgr::clear(Index);	//Window_mgr::clear必须在Screen类之前被声明
	//Screen类的剩余部分
};

7.4 类的作用域

7.5 构造函数再探
7.5.1 构造函数初始值列表
1. 初始化和赋值的区别
如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。

2. 构造函数的初始值列表有时是必不可少的
- 如果成员是const或者是引用的话，必须将其初始化。
- 当成员属于某种类类型且该类没有定义默认构造函数时，必须初始化该成员。

推荐使用构造函数初始值列表来初始化数据成员。

3. 成员初始化的顺序
<1>成员的初始化顺序与它们在类定义中的出现顺序一致，与构造函数初始值列表中的前后位置关系无关。
<2>一般来说，初始化的顺序没有特别要求。但是如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。
因此，最好令够构造函数初始值列表的顺序与成员声明顺序保持一致；采用构造函数的参数作为成员的初始值，尽量避免使用某些成员初始化其他成员。

4. 默认实参和构造函数
<1>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。
eg: 
Sales_data(std::string s = ""): bookNo(s) { }

7.5.2 委托构造函数
C++11新特性。

7.5.3 默认构造函数的作用



7.5.4 隐式的类类型转换

7.5.5 聚合类

7.5.6 字面值常量


7.6 类的静态成员
类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

1. 声明静态成员
<1>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。
<2>静态成员函数也不与任何对象绑定，它们不包含this指针。作为结果，静态成员函数不能声明为const。

2. 使用类的静态成员
<1>使用作用域运算符访问静态成员
static double rate() {/**/}  //类Account的静态成员函数
Account::rate();

<2>虽然静态成员不属于类的某个对象，但是仍然可以使用类的对象、引用或指针来访问静态成员
Account ac1;
Account *ac2 = &ac1;
r = ac1.rate();			//通过Account的对象或引用
r = ac2->rate();		//通过指向Account对象的指针

<3>(静态/非静态)成员函数不用通过作用域运算符就能直接使用静态成员。

3. 定义静态成员
<1>和其他的成员函数一样，既可以在类的内部也可以在类的外部定义静态成员函数。
在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句中。

<2>静态数据成员并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。
- 而且一般来说，不能在类的内部初始化静态成员。必须在类的外部定义和初始化每个静态成员。
- 类似于全局变量，静态数据成员定义在任何函数之外。一旦被定义，将一直存在于程序的整个生命周期中。

eg: 

class Account{	
public:
	/**/
private:
	static double interestRate;
	static double initRate();
}

double Account::interestRate = initRate();	//定义名为interestRate的对象，该对象是类的静态成员
从类名开始，这条定义语句的剩余部分都位于类的作用域之内，因此，可以直接使用initRate函数。
//和其他成员定义一样，interestRate的定义是在类的作用域中，因此可以访问该类的私有成员。

4. 静态成员的类内初始化
<1>通常情况下，类的静态成员不应该在类的内部初始化。
然而，可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。
eg:
private:
	static constexpr int period = 30;
	double daily_tbl[period];  //因为这些成员本身就是常量表达式，所以它们能用在所有适合常量表达式的地方。

<2>如果在类的内部提供了一个初始值，则成员的定义就不能再指定一个初始值了。
eg:
constexpr int Account::period;	//一个不带初始值的静态成员的定义，初始值在类的定义内提供

5. 静态成员能用于某些场景，而普通成员不能
静态成员独立于任何对象，因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常地使用。

<1>静态数据成员可以是不完全类型。静态数据成员的类型可以就是它所属的类类型。

<2>可以使用静态数据成员作为默认实参。
非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。