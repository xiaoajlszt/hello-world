1. 当定义一个类时，我们显式或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时叫做什么。
一个类通过5种类型的成员函数来控制这些操作(拷贝控制操作)，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。
- 拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。
- 拷贝和移动运算符定义了将一个对象赋予同类型的另一个对象时做什么。
- 析构函数定义了当此类型对象销毁时做什么。

13.1 拷贝、赋值与销毁
1. 拷贝构造函数
<1>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
class Foo {
public:
	Foo();				//默认构造函数
	Foo(const Foo&);	//拷贝构造函数
	//...
};

- 拷贝构造函数的第一个参数必须是一个引用。
- 虽然可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。
- 拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是explicit的。


2. 拷贝赋值运算符

13.1.3 析构函数
<1>析构函数执行与构造函数相反的操作：
构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。

<2>析构函数是类的一个成员函数，名字由波浪线接类名构成。没有返回值，也不接受参数。
//由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

1. 析构函数完成什么工作
<1>析构函数有一个函数体和一个析构部分。
在一个析构函数中，首先执行函数体，然后销毁成员。成员按照初始化顺序的逆序销毁。

- 析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。

- 析构函数中不存在类似构造函数中初始化列表的东西来控制成员如何销毁，成员销毁时发生什么完全依赖于成员的类型。
销毁类类型的成员需要执行成员自己的析构函数；			  
内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

- 隐式销毁一个内置指针类型的成员不会delete它所指向的对象；
与普通指针不同，智能指针是类类型，所以具有析构函数，智能指针成员在析构阶段会被自动销毁。

2. 什么时候会调用析构函数
<1>无论何时一个对象被销毁，就会自动调用其析构函数。
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器(无论是标准库容器还是数组)被销毁时，其元素被销毁
//需要注意 当vector中保存的是指向动态内存的指针时：
当vector离开作用域之后，只会把其成员所占的内存删除(即指针)，而不会删除指针指向的动态内存，就会出现内存泄露。
解决办法:使用智能指针，或自行释放动态内存(详见test)。

- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
//delete和free的区别和联系：https://blog.csdn.net/gukesdo/article/details/7506155
在类和对象的时候会有很大区别：
使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete可以既释放对象的内存，同时，调用这个对象的析构函数。

- 对于临时对象，当创建它的完整表达式结束时被销毁

<2>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

3. 合成析构函数
<1>当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。
对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。