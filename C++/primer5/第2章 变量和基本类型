数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

2.1 基本内置类型
C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。
其中算术类型包括：字符、整型数、布尔值、浮点数；空类型不对应具体的值，仅用于一些特殊场合，如函数返回值。

2.1.1 算术类型
1. 算术类型分为两类：整型(包括字符和布尔型)和浮点型。
<1>算术类型的尺寸(也就是该类型数据所占的比特数)在不同机器上有所差别。

2.2 变量
1. 变量提供了一个具名的、可供程序操作的存储空间。
<1>每个变量都具有数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。
<2>对C++程序员来说，变量和对象一般可以互换使用。

2. 何为对象?
<1>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。
<2>一些人仅在与类有关的场景下才使用"对象"这一词汇。另一些人则把已命名的对象和未命名的对象区分开，把已命名的对象叫做变量。
还有一些人把对象和值区分开，其中对象是指能被程序修改的数据，而值指的是只读的数据。
<3>本书认为对象是具有某种数据类型的内存空间。并不严格区分是类还是内置类型，也不区分是否命名或是否只读。

2.2.1 变量定义
1. 初始值
<1>当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。

<2>C++中，初始化和赋值是两个完全不同的操作。
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦掉，而以一个新值来替代。

2. 列表初始化
<1>C++语言定义了初始化的好几种不同形式：
int a = 0;
int a = {0};
int a{0};
int a(0);

作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。这种初始化的形式也称为列表初始化。
无论是初始化对象还是某些时候为对象赋值，都可以使用这样一组花括号括起来的初始值了。

<2>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果使用列表初始化且初始值存在丢失信息的风险，编译器将报错：
long double ld = 3.1415;
int a{ld}, b = {ld};		//错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld;			//正确：转换执行，且确实丢失了部分值

3. 默认初始化
<1>如果定义变量时没有指定初值，则变量被默认初始化。

<2>默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。
- 定义于任何函数体之外的变量被初始化为0；
- 定义在函数体内部的内置类型变量将不被初始化。
//一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。
//类的对象如果没有显式地初始化，其值由类确定。

<3>每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。
- 绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。
- 一些类要求每个对象都显式初始化，否则将引发错误。

4. 建议初始化每个内置类型的变量。

2.2.2 变量声明和定义的关系
1. 为了允许把程序拆分成多个逻辑部分来编写，C++支持分离式编译机制，允许将程序分割为若干个文件，每个文件可被独立编译。
为了支持分离式编译，C++将声明与定义区分开来。

2. 声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
<1>变量声明规定了变量的类型和名字。如果想声明而非定义变量，需要在变量名前添加extern，而且不要显示地初始化变量。
extern int i; //声明

<2>任何包含显式初始化的声明即成为定义。初始化抵消了extern的作用。
extern double pi = 3.14;  //定义

函数体内部，如果试图初始化一个由extern标记的变量，会引发错误。

<3>变量只能被定义一次，但可以被声明多次。

3. 定义负责创建与名字关联的实体。
<1>变量定义除了规定了变量的类型和名字，还申请了存储空间，也可能会初始化变量。
int i; //声明并定义

4. C++是一种静态类型语言
含义是：会在编译阶段检测类型，检测类型的过程称为类型检查。

2.3 复合类型
1. 复合类型是指基于其他类型定义的类型。eg:引用、指针。

2.3.1 引用
1. Note
C++11中新增了一种引用：所谓的"右值引用"，这种引用主要用于内置类；严格来说，当我们使用术语"引用"时，其实是指"左值引用"。

2. 引用为对象起了另外一个名字。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：
<1>eg： 
int ival = 1024;
int &refVal = ival;		//refVal指向ival(是ival的另一个名字)
int &refVal2;			//报错：引用必须被初始化

<2>一般在初始化变量时，初始值会被拷贝到新建的对象中。
然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。

<3>因为无法令引用重新绑定到另一个对象，因此引用必须初始化。

3. 引用即别名
<1>引用并非对象，相反，它只是为一个已经存在的对象所起的另外一个名字。
定义一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。

4. 引用的定义
<1>允许在一条语句中定义多个引用，其中每个引用标识符都必须以&开头：
int &r3 = i3, &r4 = i2; //r3、r4都是引用
int &r = i, r2 = i2; //r是引用，与i绑定；r2是int

<2>除了2.4.1和15.2.3两种列外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。
引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

<3>eg:
int &refVal4 = 10; //错误：引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval; //错误：此处引用类型的初始值必须是int型对象

2.4 const限定符
1. 初始化和const
<1>因为const对象一旦创建后其值就不能再变化，所以const对象必须初始化。
初始值可以是任意复杂的表达式。

2. 默认情况下，const对象仅在文件内有效
<1>如果想在一个文件中定义const对象，而在其他多个文件中声明并使用它：
解决方法：对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次。
eg: 
cpp1中定义：
extern const int bufSize = fcn();	//因为bufSize是一个常量，必须用extern加以限定使其能被其他文件使用
cpp2中声明：
extern const int bufSize;

2.4.1 const的引用
1. 对const的引用(也称为"常量引用")
<1>可以把引用绑定到const对象上，称为 对常量的引用。
与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。

eg:
const int ci = 1024;
const int &r1 = ci; //正确：引用及其对应的对象都是常量
r1 = 42;			//错误：r1是对常量的引用
int &r2 = ci;		//错误：试图让一个非常量引用指向一个常量对象

<2>初始化和对const的引用
- 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。
尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般的表达式。

<3>对const的引用可能引用一个并非const的对象
常量引用仅仅是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量并未作限定。

2.4.2 指针和const

2.4.3 顶层const
1. 顶层const表示指针本身是一个常量；底层const表示指针所指的对象是一个常量。
更一般的，顶层const表示任意的对象是常量，这一点对任何数据类型都是用。
底层const则与指针和引用等复合类型的基本类型部分有关。

2. 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。
<1>不受顶层const的限制。
<2>受底层const的限制。

2.4.4 constexpr和常量表达式
