1、线程调度  sleep和yield的区别
<1>sleep方法会给其他线程运行的机会，而不考虑线程的优先级，因此会给较低线程一个运行的机会；
yield方法只会给相同优先级或者更高优先级的线程运行的机会。
<2>sleep方法声明抛出InterruptionException异常;而yeild()方法没有声明抛出任何异常。
<3>sleep方法比 yeild()方法具有更高的可移植性。
<4>sleep方法使线程进入阻塞状态;而yeild()方法使线程进入就绪状态。

<5>yield暂时交出cpu控制权，从running状态转为runnable状态，但是仍有可能被调度;
   sleep线程指定休眠一段时间;
   wait在其他线程调用此对象的notify或notifyAll方法时才能继续执行。
   
2、int main() {fork() || fork();} 共创建几个进程？
<1> || 的短路功能。如果第一个表达式为真，不再执行后面的表达式。
<2> fork会return两次，一次在子进程(返回0)，一次在父进程(返回PID)。
显然父进程中不会在继续执行；子进程中会继续执行fork。

<3>因此，包括main进程在内，共创建了3个进程。

3、二叉树 知道前序遍历、中顺遍历，求后续遍历。
重点是一直找根节点。