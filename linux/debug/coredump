http://blog.csdn.net/newnewman80/article/details/8173770
1、简介
coredump是什么：通常情况下coredump包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息等。可以理解为把程序工作的当前状态存储成一个文件。
许多程序和操作系统出错时会自动生成一个core文件。

coredump分析工具：现在大部分类unix操作系统都提供了分析core文件的工具，比如?GNU Binutils Binary File Descriptor library?(BFD),GNU Debugger?(gdb），mdb等。

造成coredump的原因：
<1>内存访问越界
a) 由于使用错误的下标，导致数组访问越界
b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符
c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。

<2>多线程程序使用了线程不安全的函数。
应该使用下面这些可重入的函数，尤其注意红色标示出来的函数，它们很容易被用错：
asctime_r(3c) gethostbyname_r(3n) getservbyname_r(3n) ctermid_r(3s) gethostent_r(3n) getservbyport_r(3n) ctime_r(3c) getlogin_r(3c) getservent_r(3n) fgetgrent_r(3c) getnetbyaddr_r(3n) getspent_r(3c) fgetpwent_r(3c) getnetbyname_r(3n) getspnam_r(3c) fgetspent_r(3c) getnetent_r(3n) gmtime_r(3c) gamma_r(3m) getnetgrent_r(3n) lgamma_r(3m) getauclassent_r(3) getprotobyname_r(3n) localtime_r(3c) getauclassnam_r(3) etprotobynumber_r(3n) nis_sperror_r(3n) getauevent_r(3) getprotoent_r(3n) rand_r(3c) getauevnam_r(3) getpwent_r(3c) readdir_r(3c) getauevnum_r(3) getpwnam_r(3c) strtok_r(3c) getgrent_r(3c) getpwuid_r(3c) tmpnam_r(3s) getgrgid_r(3c) getrpcbyname_r(3n) ttyname_r(3c) getgrnam_r(3c) getrpcbynumber_r(3n) gethostbyaddr_r(3n) getrpcent_r(3n)

<3>多线程读写的数据未加锁保护。
对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump

<4>非法指针
a) 使用空指针
b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这
种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它 时就很容易因为bus error而core dump.

<5>堆栈溢出
不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。

2、生成core文件
文件路径：通常位于程序所在的路径。但如果程序中调用了chdir函数，则有可能改变了当前工作目录。这时core文件创建在chdir指定的路径下。
很多程序崩溃却找不到core文件位置就和chdir函数就有关系。当然程序崩溃了不一定都产生core文件。

ulimit设置：设置core文件大小为不限制（默认core文件大小为0，生成不了core文件），详见linux命令中的ulimit用法。

3、调试core文件
构造段错误：
  core_dump_test.c
  1 int main()
  2 {
  3     char *str = "hello core dump!";
  4     str[0] = 'I';
  5     return 0;
  6 } 
执行 gcc -g core_dump_test.c -o core_dump_test  //使用-g在生成的exe中加入代码信息，便于调试
     ./core_dump_test
结果 Segmentation fault (core dumped)
生成 core.2326

调试：
执行 gdb core_dump_test core.2326 
结果显示错误在程序第4行 
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-80.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /home/xiaopeng/USPP/test/core_dump_test...done.
[New LWP 2326]
Core was generated by `./core_dump_test'.
Program terminated with signal 11, Segmentation fault.
#0  0x0000000000400500 in main () at core_dump_test.c:4
4           str[0] = 'I';
Missing separate debuginfos, use: debuginfo-install glibc-2.17-106.el7_2.4.x86_64

(gdb) bt(或者where)  //查看函数调用链，显示错误位于core_dump_test.c:4
#0  0x0000000000400500 in main () at core_dump_test.c:4