1、javac程序是一个java编译器，它将.java文件编译成.class，并发送给java虚拟机，虚拟机执行编译器存放在class文件中的执行码。
2、编译时（javac）需要提供一个文件名（Welcome.java），运行时（java）只需要指定类名（Welcome），不要带扩展名.java或.class。
3、Java中的所有函数都属于某个类的方法（标准术语将其称为方法，而不是成员函数）。因此， Java中的main方法必须有一个外壳类。 Java中的main方法必须是静态的。
方法：函数
------------------------------------------------------------------------------------
Java Development Kit JDK 编写Java程序的程序员使用的软件
Java Runtime Environment JRE 运行Java程序的用户使用的软件
Standard Edition SE 用于桌面或简单的服务器应用的Java平台
Enterprise Edition EE 用于复杂的服务器应用的Java平台
Micro Edition ME 用于微型手机cell phone和其他小型设备的Java平台
Java 2 J2 一个过时的术语，用于描述1998年~2006年之间的Java版本
Software Development Kit SDK 一个过时的术语，用于描述1998年~2006年之间的JDK
Update u Sun的术语，用于发布修改的bug
NetBeans ― Sun的集成开发环境
JVM java虚拟机
------------------------------------------------------------------------------------
一个.java文件中可以有很多类。不过注意以下几点：
1、public 权限的类只能有一个（也可以一个都没有，但最多只有1个）
2、这个.java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）
3、若这个文件中没有public的类，则文件名随便是一个类的名字即可
4、用javac 编译这个.java文件的时候，它会给每一个类生成一个.class文件
------------------------------------------------------------------------------------
内部类的class文件命名是：主类＋$＋内部类名
匿名类的class文件命名是：主类＋$＋(1,2,3....)
------------------------------------------------------------------------------------
编写mf文件时要注意格式：eg
  1 Manifest-Version: 1.0
  2 Created-By: 1.8.0_31 (Oracle Corporation)
  3 Main-Class: ResourceTest
  4 
：之后要加空格
最后一行要加回车
------------------------------------------------------------------------------------
数值类型：
1、在Java中，所有的数值类型所占据的字节数量与平台无关。Java没有任何无符号类型（ unsigned type）。
2、boolean（布尔）类型有两个值： false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。
3、Java中，利用关键字final声明常量。关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用大写。
const是Java保留的关键字，但目前并没有使用。在Java中，必须使用final定义常量。
4、>>>运算符将用0填充高位； >>运算符用符号位填充高位。没有<<<运算符。（区分了算术和逻辑左移）
5、String类的substring方法可以从一个较大的字符串提取出一个子串。例如：创建了一个由字符“ Hel”组成的字符串。
6、与绝大多数的程序设计语言一样， Java语言允许使用+号连接（拼接）两个字符串。
7、Java将自动地进行垃圾回收。如果一块内存不再使用了，系统最终会将其回收。


类：实例域->类对象成员  方法->类成员函数
1、对象与对象变量之间存在着一个重要的区别。eg：
2、多数自定义类没有main方法，而却有自定义的实例域和实例方法。要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。
3、<1>在这个示例程序中包含两个类：一个Employee类；一个带有public访问修饰符的EmployeeTest类。 EmployeeTest类包含了main方法，其中使用了前面介绍的指令。
源文件名是EmployeeTest.java，这是因为文件名必须与public类的名字相匹配。在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。
<2>接下来，当编译这段源代码的时候，编译器将在目录下创建两个类文件： EmployeeTest.class和Employee.class。
将程序中包含main方法的类名字提供给字节码解释器，以便启动这个程序：java EmployeeTest
字节码解释器开始运行EmployeeTest类的main方法中的代码。在这段代码中，先后构造了三个新Employee对象，并显示它们的状态。
<3>在例4-2中，一个源文件包含了两个类。许多程序员习惯于将每一个类存在一个单独的源文件中。例如，将Employee类存放在文件Employee.java中，将EmployeeTest类存放在文件EmployeeTest.java中。
<4>强烈建议将实例域标记为private。
<5>构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
<6>构造器与类同名
-每个类可以有一个以上的构造器
-构造器可以有0个、 1个或1个以上的参数
-构造器没有返回值
-构造器总是伴随着new操作一起调用
Java构造器的工作方式与C++一样。但是，要记住所有的Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用。 C++程序员最易犯的错误就是忘记new操作符.
<7>在每一个方法中，关键字this表示隐式参数.
在C++中，通常在类的外面定义方法，如果在类的内部定义方法，这个方法将自动地成为内联（ inline）方法。
在Java程序设计语言中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。
<8>在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：
- 一个私有的数据域；
- 一个公有的域访问器方法；
- 一个公有的域更改器方法。
<9>方法可以访问所属类的私有特性（ feature），而不仅限于访问隐式参数的私有特性。eg：
<10>如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。静态域被称为类域。
如果有1000个Employee类的对象，则有1000个实例域id。但是，只有一个静态域nextId。即使没有一个雇员对象，静态域nextId也存在。它属于类，而不属于任何独立的对象。
<11>可以认为静态方法是没有this参数的方法（在一个非静态的方法中， this参数表示这个方法的隐式参数）。
因为静态方法不能操作对象，所以不能在静态方法中访问实例域。但是，静态方法可以访问自身类中的静态域。
建议使用类名，而不是对象来调用静态方法。
/*****/
C++注释： Java中的静态域与静态方法在功能上与C++相同。但是，语法书写上却稍有所不同。在C++中，使用::操作符访问自身作用域之外的静态域和静态方法，如Math::PI。
术语“ static”有一段不寻常的历史。起初， C引入关键字static是为了表示退出一个块后依然存在的局部变量。在这种情况下，术语“ static”是有意义的：变量一直存在，当再
次进入该块时仍然存在。随后， static在C中有了第二种含义，表示不能被其他文件访问的全局变量和函数。为了避免引入一个新的关键字，关键字static被重用了。最后， C++
第三次重用了这个关键字，与前面赋予的含义完全不一样，这里将其解释为：属于类且不属于类对象的变量和函数。这个含义与Java 相同。
/*****/
<12>所谓默认构造器是指没有参数的构造器。如果在编写一个类时没有编写构造器，那么系统就会提供一个默认构造器。这个默认构造器将所有的实例域设置为默认值。
于是，实例域中的数值型数据设置为0、布尔型数据设置为false、所有对象变量将设置为null。
<13>标记为public的部分可以被任意的类使用；标记为private 的部分只能被定义它们的类使用。如果没有指定public或private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。
<14>Java用关键字extends代替了C++中的冒号（：）。在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。
关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类被称为超类（ superclass）、 基类（ base class）或父类（ parent class）；
新类被称为子类（ subclass）、 派生类（ derived class）或孩子类（ child class）。
<15>一个对象变量（例如，变量e）可以引用多种实际类型的现象被称为多态（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（ dynamic binding）。
<16>抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；另
一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。类即使不含抽象方法，也可以将类声明为抽象类。抽象类不能被实例化。
类对象：Student a = new Student();
类对象变量：Student a;
抽象类不能创建类对象，但可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象

/*第6章*/
1、克隆：（有时又称为深拷贝）。对象的克隆是指创建一个新对象，且新对象的状态与原始对象的状态相同。当对克隆的新对象进行修改时，不会影响原始对象的状态。
默认的克隆操作是浅拷贝，它并没有克隆包含在对象中的内部对象。