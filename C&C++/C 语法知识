1、for循环
<1> for循环有三个表达式:
    第一个表达式进行测试，只在循环开始时执行一次；
    第二个表达式是判断条件，每次执行循环之前进行求值，如果为假则循环结束；
    第三个表达式在每次循环结束时进行计算；

<2> 有时候我们希望for循环判断两个条件来结束循环(表达式2)，有时候希望每次循环结束后改变两个变量的值(表达式3)，可以采用逗号运算符；
    在C语言中，多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别计算，但整个表达式的值是最后一个表达式的值。
    因此for循环的第二个表达式条件判断时应该使用 && 和 || 等关系运算符，而第三个表达式可以使用逗号运算法。
    例：for (i=0,j=0; (i<10)&&(j<5); i+=2,j+=1) //该for语句的作用是，每次循环开始前判断i<10和j<5是否同时成立，循环结束后修改i和j的值。
	
2、a++和++a可不可以作为左值
<1> 首先说左值和右值的定义： 
    变量和文字常量都有存储区，并且有相关的类型。区别在于变量是可寻址的（addressable）对于每一个变量都有两个值与其相联：
  1)它的数据值，即存储在某个内存地址中。有时这个值也被称为对象的右值（rvalue,读做are-value），也可认为右值的意思是被读取的值（read value）。文字常量和变量都可被用作右值。
  2)它的地址值，即存储数据值的那块内存的地址。它有时被称为变量的左值（lvalue，读作ell-value），也可认为左值的意思是位置值。文字常量不能被用作左值。

<2> a++和++a在做左值的时候有不同，那么左值它首先必须是有特定地址的才能作为左值，否则赋值就没有具体对象。
    a++的意思是先复制一份临时数据出来参与周边环境的运算，再自加变量a，可见a++用来参与运算的是一份复制出来的临时数据，这个数据是临时存在而没有固定地址的，不是一个真正的变量。
	++a的意思是先自加变量a，再将变量放到周边环境参与运算，那么++a用来参与运算的是有具体地址的变量，所以++a是可以作为左值使用的。
    具体一点可以理解为：a++返回一个临时变量，++a返回变量的引用。
          i++的实现是：int temp；temp = i; i = i+1; return temp;  
		  ++i的实现是：i = i+1；return i;              
    i++=5;是错误的是因为i++返回的是编译器自动分配的临时变量temp，而这个temp并不是程序中定义的可寻址变量的引用，也就是说你不能通过地址对temp进行操作，不能作为左值。
    ++i=5;是正确的就是因为其返回值就是i;
	
3、cout输出数组名/指针时，字符串数组char []/指针char *：输出整个字符串，其他类型数组/指针：输出首地址。
原因：1、cout对const char*重载了运算符<<，输出字符数组时，就把字符数组转换成char*，将数组\0前的内容全部输出；（等同于输出char *字符串）
      2、其他非字符数组输出数组首地址。
	  如：char a[] = "hello";
          char *p = a;
          cout << "p = " << p << endl                   hello
               << "p = " << (void *) p << endl          0x0032FB2C
               << "*p = " << *p << endl;                h
			   
4、结构体对齐
（一）http://blog.csdn.net/zhongkeli/article/details/7002371
<1>对齐规则：一般来说，结构体的对齐规则是先按数据类型自身进行对齐，然后再按整个结构体进行对齐，对齐值必须是2的幂，比如1，2， 4， 8， 16。
             如果一个类型按n字节对齐，那么该类型的变量起始地址必须是n的倍数。比如int按四字节对齐，那么int类型的变量起始地址一定是4的倍数，比如0x0012ff60，0x0012ff48等。
<2>数据自身对齐：通常是数据类型所占的空间大小，比如int类型占四个字节，那么它的对齐值就是4。
<3>结构体的对齐：整个结构体的对齐值一般是结构体中最大数据类型所占的空间。
eg:struct Test1
  {
      int i ;
      double d ;
      char c ;
  };
  i是int类型，按4字节对齐;d是double类型，按8字节对齐，所以i和d之间空了4字节;c是char类型，按1字节对齐。
  所以整个结构体是 4(i) + 4（补齐）+ 8(d) + 1(c) =  17字节，注意！整个结构体还没有对齐，因为结构体中空间最大的类型是double，
  所以整个结构体按8字节对齐，那么最终结果就是17 + 7（补齐） = 24字节。

（二）http://blog.csdn.net/mcu_hong/article/details/8702912
eg: 1字节对齐后，该结构总长为13字节；去掉对齐后，总长为16字节。
   #pragma pack(push) //保存对齐状态------------
   #pragma pack(1)   // 1 bytes对齐-------------等价于 #pragma pack(push,1)

   typedef struct 
   {
       double dValue1;
       char   u8Value2;
       int    u32Value3;
   } ASampleStructor;
   
   #pragma pack(pop)//恢复对齐状态
   
（三）在ARM平台的编译器中，没有提供象“#pragma pack”这么丰富的带参数对齐指令，只有一个关键字“__packed”。
      __packed 限定符将所有有效类型的对齐边界设置为 1，如果一个结构没有这个限定符，默认向表数能力最强的那个数据类型对齐。
	  
5、C和C++中的sizeof('A')
<1>C语言:
	char a = 'a';
	sizeof(char) = 1
	sizeof(a) = 1
	sizeof('a') = 4
<2>C++语言:
	char a = 'a';
	sizeof(char) = 1
	sizeof(a) = 1
	sizeof('a') = 1
  存在问题：字符型变量是1字节这个没错，奇怪就奇怪在C语言认为'a'是4字节，而C++语言认为'a'是1字节？？？？
  原因如下:
  <1>C99标准的规定，'a'叫做整型字符常量(integer character constant)，被看成是int型，所以在32位机器上占4字节。
  <2>ISO C++标准规定，'a'叫做字符字面量(character literal)，被看成是char型，所以占1字节。

6、printf输出：
   d / i       int         接受整数值并将它表示为有符号的十进制整数，i是老式写法 
     u     unsigned int    无符号10进制整数 
   x / X   unsigned int    无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x) 
     c         char        字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 

7、函数原型的使用
   函数原型：int max(int,int);或int max(int a,int b);
   函数声明：int max();
<1>使用函数原型，是为了在编译器编译第一个调用该函数的语句之前，告知编译器该函数的使用方法。
<2>函数声明形式是不够准确的，只声明了函数返回值类型，没有声明其参数。当调用函数时，参数类型或参数个数错误，编译器并不能发现这种错误。
<3>无参数的函数原型void print_name();最好写成void print_name(void); 否则编译器会认为没有函数原型，编译器不会进行参数检查；
<4>若不使用函数原型，也可以通过在首次调用某函数之前对该函数进行定义，这样函数的定义部分就和函数原型有着相同的作用（适用于小函数）。
  
8、变量申明必须用extern，否则视为定义

9、字符串常量是有地址的，其他常量没有地址
    const常量本质并不是常量，只是表示只读，因此有地址

10、volatile关键字  http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html
<1>volatile关键字是一种类型修饰符，它声明的类型变量表示可以被某些编译器未知的因素更改，如：操作系统、硬件、其他线程等。。
<2>遇到volatile声明的变量，编译器对访问改变了的代码不再进行优化，从而可以提供对特殊地址的稳定访问。
系统总是重新从它所在的内存读取数据，即使之前的指令刚刚从该处读取过数据。

11、static
http://www.cnblogs.com/stoneJin/archive/2011/09/21/2183313.html

12、switch中的打印：
int main()
{
	int a = 100;

	switch(a)
	{
		printf("enter switch!");
		
	    case 100:
			printf("a=100!");
			break;
		default:
			printf("default!");
			break;
	}
	
	return 0;
}

switch直接跳到case分支，该段代码中的 printf("enter switch!"); 是不会打印出来的！！！







