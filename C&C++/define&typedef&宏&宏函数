http://m.blog.csdn.net/blog/bytxl/46007849
http://www.cnblogs.com/dong008259/archive/2011/12/27/2302625.html

1、要写好C语言，漂亮的宏定义是非常重要的。宏定义可以帮助我们防止出错，提高代码的可移植性和可读性等。
   在软件开发过程中，经常有一些常用或者通用的功能或者代码段，这些功能既可以写成函数，也可以封装成为宏定义。
   那么究竟是用函数好，还是宏定义好？这就要求我们对二者进行合理的取舍。
   <1> 我们来看一个例子，比较两个数或者表达式大小，首先我们把它写成宏定义：
　　#define MAX( a, b) ( (a) > (b) (a) : (b) )
　　其次，把它用函数来实现：
　　int max( int a, int b)
　　{
　　	return (a > b a : b)
　　}
　 <2> 很显然，我们不会选择用函数来完成这个任务，原因有两个：首先，函数调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆栈。
    这种开销不仅会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都比函数更胜一筹；
	其次，函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用，我们如果要比较两个浮点型的大小，就不得不再写一个专门针对浮点型的比较函数。
	反之，上面的那个宏定义可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“>”操作符比较值大小的类型，也就是说，宏是与类型无关的。

　 <3> 和使用函数相比，使用宏的不利之处在于每次使用宏时，一份宏定义代码的拷贝都会插入到程序中。除非宏非常短，否则使用宏会大幅度增加程序的长度。

　 <4> 还有一些任务根本无法用函数实现，但是用宏定义却很好实现。比如参数类型没法作为参数传递给函数，但是可以把参数类型传递给带参的宏。
　　   看下面的例子：
　　   #define MALLOC（n, type） ((type *) malloc((n)* sizeof(type)))
	   利用这个宏，我们就可以为任何类型分配一段我们指定的空间大小，并返回指向这段空间的指针。我们可以观察一下这个宏确切的工作过程：
　　    int *ptr;
        ptr = MALLOC ( 5, int );
        将这宏展开以后的结果：
		ptr = (int *) malloc ( (5) * sizeof(int) );

　　    这个例子是宏定义的经典应用之一，完成了函数不能完成的功能。
        但是宏定义也不能滥用，通常，如果相同的代码需要出现在程序的几个地方，更好的方法是把它实现为一个函数。

2、下面总结和宏和函数的不同之处，以供大家写代码时使用，这段总结摘自《C和指针》一书。

     属性                     #define宏                                               函数
 
   代码长度             每次使用时，宏代码都被插入到程序中                 函数代码只出现于一个地方：每次使用这个函数时，
                     除了非常小的宏之外，程序的长度将大幅度增长                   都调用那个地方的同一份代码
 
   执行速度                     更快                                            存在函数调用、返回的额外开销

                      宏参数的求值是在所有周围表达式的上下文环境里，           函数参数只在函数调用时求值一次，
   操作符优先级       除非它们加上括号，否则邻近操作符的优先级可能              它的结果值传递给函数。
					   产生不可预料的结果                                       表达式的求值结果更容易预测。
 
    参数求值        参数用于宏定义时，每次都将重新求值，由于多次求值，         参数在函数调用前只求值一次，
	                 具有副作用的参数可能会产生不可预测的结果。               在函数中多次使用参数并不会导致多次求值过程，
																				参数的副作用并不会造成任何特殊问题。

    参数类型           宏与类型无关，只要参数的操作是合法的，                函数的参数是与类型有关系的，如果参数的类型不同，
	                         它可以用于任何参数类型。                        就需要使用不同的函数，即使它们执行的任务是相同的。
 
 
注：1、关于宏函数操作符优先级的说明：
    #define MAX(a,b) ((a)>(b)?(a):(b))
    若定义为#define MAX(a,b) (a>b?a:b)
	k = MAX(a&0x0f,b&0x0f)
	则宏展开就成了k = (i&0x0f>j&0x0f?i&0x0f:j&0x0f)，运算的优先级就错了 &位与的优先级低于>
	
	2、消除多余的分号
	<1> 通常情况下，为了使函数模样的宏在表面上看起来像一个通常的C语言调用一样，通常情况下我们在宏的后面加上一个分号。
	比如下面的带参宏： MY_MACRO(x);
	<2> 但是如果是下面的情况： #define MY_MACRO(x) {	/* line 1 */	/* line 2 */	/* line 3 */ }
        if (condition())
           MY_MACRO(a);
        else
        {...}
		
		这样会由于多出的那个分号产生编译错误。
		为了避免这种情况出现同时保持MY_MACRO(x);的这种写法，我们需要把宏定义为这种形式： 
        #define MY_MACRO(x) do {/* line 1 */	/* line 2 */	/* line 3 */ } while(0)
        这样只要保证总是使用分号，就不会有任何问题。 

	3、Duplication of Side Effects
       这里的Side Effect是指宏在展开的时候对其参数可能进行多次Evaluation（也就是取值），如果这个宏参数是一个函数，那么就有可能被调用多次从而达到不一致的结果，
	   甚至会发生更严重的错误。比如： 
		#define min(X,Y) ((X) > (Y) ? (Y) : (X))
		//...
		c = min(a,foo(b));
		这时foo()函数就被调用了两次。为了解决这个潜在的问题，我们应当这样写min(X,Y)这个宏： 
		#define min(X,Y) ({	typeof (X) x_ = (X);	typeof (Y) y_ = (Y);	(x_ < y_) ? x_ : y_; })
		({...})的作用是将内部的几条语句中最后一条的值返回，它也允许在内部声明变量（因为它通过大括号组成了一个局部Scope）。 
       
	   typeof构造的主要应用是用在宏定义中。可以使用typeof关键字来引用宏参数的类型。

3、example：
define的单行定义
#define maxi(a,b) (a>;b?a:b)
define的多行定义
define可以替代多行的代码，例如MFC中的宏定义（非常的经典，虽然让人看了恶心）
#define   MACRO(arg1,   arg2)   do   {   \
   \
stmt1;   \
stmt2;   \
   \
}   while(0)  
关键是要在每一个换行的时候加上一个 "\ "

//宏定义写出swap（x，y）交换函数
#define swap(x, y)\
x = x + y;\
y = x - y;\
x = x - y;

zigbee里多行define有如下例子
#define FillAndSendTxOptions( TRANSSEQ, ADDR, ID, LEN, TxO ) { \
afStatus_t stat;                                    \
ZDP_TxOptions = (TxO);                              \
stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
ZDP_TxOptions = AF_TX_OPTIONS_NONE;                 \
return stat;                                        \
}

http://blog.sina.com.cn/s/blog_861912cd0100tc94.html

--------------------------------------------------------------------------------------------------------------------------

http://blog.csdn.net/dotphoenix/article/details/4345174
一、C语言宏定义##连接符和#符的使用：
1、#的作用
   在C语言的宏中，#的功能是将其后面的宏参数进行字符串化操作（Stringfication），简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。
   比如下面代码中的宏：
   #define WARN_IF(EXP)    do{ if (EXP)    fprintf(stderr, "Warning: " #EXP "/n"); }  while(0)
   实际使用中会出现下面所示的替换过程：
    WARN_IF (divider == 0)被替换为
	do {
		if (divider == 0)
		fprintf(stderr, "Warning" "divider == 0" "/n");
	} while(0);

2、##的作用
   ##被称为连接符（concatenator），用来将两个Token连接为一个Token。注意这里连接的对象是Token就行，而不一定是宏的变量。
 <1>比如你要做一个菜单项命令名和函数指针组成的结构体的数组，并且希望在函数名和菜单项命令名之间有直观的、名字上的关系。那么下面的代码就非常实用：
    struct command
	{
		char* name;
		void (*function) (void);
	};
    #define COMMAND(NAME) { NAME, NAME ## _command } 
	//然后你就用一些预先定义好的命令来方便的初始化一个command结构的数组了：
	struct command commands[] = {
	COMMAND(quit),
	COMMAND(help),
	...
	}
	COMMAND宏在这里充当一个代码生成器的作用，这样可以在一定程度上减少代码密度，间接地也可以减少不留心所造成的错误。
 
 <2>我们还可以n个##符号连接 n+1个Token，这个特性也是#符号所不具备的。比如： 
	#define LINK_MULTIPLE(a,b,c,d) a##_##b##_##c##_##d
	typedef struct _record_type LINK_MULTIPLE(name,company,position,salary);
	// 这里这个语句将展开为：typedef struct _record_type name_company_position_salary;

3、...的作用
   ...在C宏中称为Variadic Macro，也就是变参宏。比如： 
	#define myprintf(templt,...) fprintf(stderr,templt,__VA_ARGS__)
	// 或者 #define myprintf(templt,args...) fprintf(stderr,templt,args)

------------------------------------------------------------------------------------------------------------------------------------

1、ANSI标准说明了五个预定义的宏名。它们是：
__LINE__  代表该行代码的所在行号
__FILE__  代表源文件的文件名
__DATE__  宏指令含有形式为月/日/年的串，表示源文件被翻译到代码时的日期
__TIME__
__STDC__   

2、在GNU C中，宏可以接受可变数目的参数，就像函数一样，例如:
#define pr_debug(fmt,arg...)	\
printk(KERN_DEBUG fmt, ##arg)

C99允许定义可变参数宏(variadic macros)，这样你就可以使用拥有可以变化的参数表的宏。可变参数宏就像下面这个样子: 
#define debug(...) printf(__VA_ARGS__)缺省号代表一个可以变化的参数表。使用保留名 __VA_ARGS__ 把参数传递给宏。当宏的调用展开时，实际的参数就传递给 printf()了。
例如: Debug("Y = %d\n", y);而处理器会把宏的调用替换成: printf("Y = %d\n", y);
C99 引入了对参数个数可变的函数式宏的正式支持。在宏"原型" 的末尾加上符号 ... (就像在参数可变的函数定义中), 宏定义中的伪宏 __VA_ARGS__ 就会在调用是 替换成可变参数。 
   
---------------------------------------------------------------------------------------------------------------------------------------

1) #define是预处理指令，在编译预处理时进行简单的替换，不作正确性检查，不关含义是否正确照样带入，只有在编译已被展开的源程序时才会发现可能的错误并报错。
例如：#define PI 3.1415926
程序中的：area=PI*r*r 会替换为3.1415926*r*r
如果你把#define语句中的数字9 写成字母g 预处理也照样带入。

2）typedef是在编译时处理的。它在自己的作用域内给一个已经存在的类型一个别名，但是You cannot use the typedef specifier inside a function definition。

3）typedef int * int_ptr;与#define int_ptr int * 作用都是用int_ptr代表 int * ,
但是二者不同，正如前面所说 ，#define在预处理时进行简单的替换，而typedef不是简单替换 ，而是采用如同定义变量的方法那样来声明一种类型。
也就是说;//refer to (xzgyb(老达摩))
#define int_ptr int *
int_ptr a, b; //相当于int * a, b; 只是简单的宏替换
typedef int* int_ptr;
int_ptr a, b; //a, b 都为指向int的指针,typedef为int* 引入了一个新的助记符这也说明了为什么下面观点成立
//QunKangLi(维护成本与程序员的创造力的平方成正比)
typedef int * pint ;
#define PINT int *
那么：
const pint p ;//p不可更改，但p指向的内容可更改
const PINT p ;//p可更改，但是p指向的内容不可更改。
pint是一种指针类型 const pint p 就是把指针给锁住了 p不可更改
而const PINT p 是const int * p 锁的是指针p所指的对象。

4）也许您已经注意到#define 不是语句 不要在行末加分号，否则 会连分号一块置换。
   
   
   
   








