MySQL支持对MyISAM和MEMORY存储引擎的表进行表级锁定；
		 对BDB存储引擎的表进行页级锁定；
		 对InnoDB存储引擎的表进行行级锁定。
默认情况下，表锁和行锁都是自动获得的，不需要额外的命令。
某些情况下，用户需要明确地进行锁表或事务的控制，以便确保整个事务的完整性，此时就需要使用事务控制和锁定语句来完成。

1、LOCK TABLE和UNLOCK TABLE
<1>使用方式：
1)LOCK TABLES可以锁定当前线程使用的表。如果表被某个线程锁定，其他线程会等待，直到可以获取所有锁定为止。
2)UNLOCK TABLES可以释放当前线程获得的所有锁定。
3)线程执行另一个LOCK TABLES时，或与服务器的连接被关闭时，所有由该线程锁定的表都被隐式地解锁。

<2>使用示例：
session1、session2表示两个连接(两个线程)。
<1>session1获取表的READ锁定。  LOCK TABLE tablename READ;
此时session1和session2都可以查询该表的记录。

<2>若session2要更新表内容，就会等待获得锁。

2、事务控制
<1>MySQL通过SET AUTOCOMMIT、START TRANSACTION、COMMIT和ROLLBACK等语句支持本地事务。
SET AUTOCOMMIT = {0 | 1}
START TRANSACTION | BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]

<2>默认情况下，MySQL是自动提交的(Autocommit)。
1)如果需要通过明确的Commit和Rollback来提交和回滚事务，那么就需要通过明确的事务控制命令来开始事务。(这点与Oracle不同)

2)START TRANSACTION或BEGIN语句可以开始一项新的事务；
  
3)COMMIT和ROLLBACK用于提交或回滚事务；CHAIN和RELEASE子句分别用来定义在事务提交或回滚后的操作。
CHAIN会立即启动一个新事务，并且和之前的事务具有相同的隔离级别；
RELEASE则会立即断开和客户端的连接。

4)SET AUTOCOMMIT可以修改当前连接的提交方式
如果设置了SET AUTOCOMMIT=0，那么之后所有的事务都需要通过明确的命令进行提交或回滚。

---------------------------------------------------------------------------------------------------

一、事务
1、简介
<1>事务就是一组原子性的SQL查询，或者说是一个独立的工作单元。
如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行改值查询。
如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。
也就是说，事务内的语句要么全部执行成功，要么全部执行失败。

<2>除非系统通过严格的ACID测试，否则空谈事务的概念是不够的。
一个运行良好的事务处理系统，必须具有：
原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元。
一致性(consistency)：数据库总是从一个一致性状态转到另一个一致性状态。
隔离性(isolation)：通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。
持久性(durability)：一旦事务提交，其所做的修改就会永久保存在数据库中。即使系统崩溃，数据也不会丢失。

<3>用户可以根据业务是否需要事务处理，来选择合适的存储引擎。
对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。

2、隔离级别
SQL标准中定义了四种隔离级别，每种级别规定了一个事务中所做的修改，哪些在事务内和事务间是可见的。
较低级别的隔离通常可以执行更高的并发，系统开销也更低。

<1>READ UNCOMMITTED(未提交读)
1)该级别，事务中的修改即使未提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为脏读(Dirty Read)。
2)该级别会导致很多问题，实际应用中很少使用。

<2>READ COMMITTED(提交读)
1)该级别是大多数数据库系统的默认隔离级别(但MySQL不是)。
2)一个事务开始时，只能看见已经提交的事务所做的修改。
换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。
3)该级别也叫作不可重复读(nonrepeatable read)，因为两次执行同样的查询，可能会得到不一样的结果。

<3>REPEATABLE READ(可重复读)
1)该级别解决了脏读的问题，且保证在同一个事务中多次读取同样记录的结果是一致的。
2)理论上该级别还是无法解决幻读(Phantom Read)的问题。
InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题。
3)该级别是MySQL的默认事务隔离级别。

<4>SERIALIZABLE(可串行化)
1)该级别是最高的隔离级别。强制事务串行执行，避免了幻读问题。
简单来说，该级别会在读取的每一行数据上都加锁。
2)实际应用中该级别很少使用，只在非常需要确保数据一致性，且可接受没有并发的情况下使用。

<5>综述
   隔离级别		      脏读可能性		 不可重复读可能性        幻读可能性        加锁读
READ UNCOMMITTED		Yes						Yes					Yes				No
READ COMMITTED			No						Yes					Yes				No
REPEATABLE READ			No						No					Yes				No
SERIALIZABLE			No						No					No				Yes









