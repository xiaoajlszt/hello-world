一、基本命令
1、DDL(Data Definition Language)语句：
数据定义语言，定义不同的数据段、数据库、表、列、索引等数据库对象的定义。
常用语句关键字包括create、drop、alter等。

show databases;          //显示库
create database dbname;  //建库
drop database dbname;    //删除库
user dbname;             //选中库

show tables;             //显示库中的所有数据表
desc tablename;          //查看表定义
show create table tablename; //查看创建表的SQL语句    \G 选项使得记录能够按照字段竖着排列
drop table tablename;    //删除表

select count(*) from tableName;  //查询表记录条目
SELECT * FROM tablename [WHERE CONDITION];  //查询表中符合条件的记录

SELECT * FROM information_schema.PARTITIONS WHERE table_name='tablename';//查看表的分区
select count(*) from tableName PARTITION (P01);

show index from policy_big;  //查看索引
show keys from policy_big;   //查看索引

select count(*) from policy_little where PolicyId="254123614"; //字符串匹配
select count(distinct(Subscriber)) from policy_little where PolicyId="254123614";  //去重后的个数

select * from tableA where id not in (select id from tableB); //not in

INSERT INTO policy_little SELECT * FROM policy_big PARTITION(p%02d); //insert into

INSERT INTO policy_user (SELECT * FROM policy_little PARTITION(p01) where PolicyId not in (select PolicyId from policy_user) or Subscriber not in (select Subscriber from policy_user));

insert ignore into policy_user SELECT * FROM policy_little PARTITION(p01); //忽略主键或唯一索引重复

delete from policy_user;//删除表中数据

//查询rdb_test库空间占用情况
SELECT CONCAT(TRUNCATE(SUM(data_length)/1024/1024,2),'MB') AS data_size,
CONCAT(TRUNCATE(SUM(max_data_length)/1024/1024,2),'MB') AS max_data_size,
CONCAT(TRUNCATE(SUM(data_free)/1024/1024,2),'MB') AS data_free,
CONCAT(TRUNCATE(SUM(index_length)/1024/1024,2),'MB') AS index_size
FROM information_schema.tables WHERE TABLE_SCHEMA = 'rdb_test';

//查询POLICY_4INDX_NOPRIM表空间占用情况
SELECT CONCAT(TRUNCATE(SUM(data_length)/1024/1024,2),'MB') AS data_size,
CONCAT(TRUNCATE(SUM(max_data_length)/1024/1024,2),'MB') AS max_data_size,
CONCAT(TRUNCATE(SUM(data_free)/1024/1024,2),'MB') AS data_free,
CONCAT(TRUNCATE(SUM(index_length)/1024/1024,2),'MB') AS index_size
FROM information_schema.tables WHERE TABLE_NAME = 'POLICY_4INDX_NOPRIM';


/*创建索引*/
CREATE INDEX index_name ON table_name (column_list)
CREATE UNIQUE INDEX index_name ON table_name (column_list)

/*删除索引*/
DROP INDEX index_name ON talbe_name
ALTER TABLE table_name DROP INDEX index_name
ALTER TABLE table_name DROP PRIMARY KEY


<1>建表
CREATE TABLE tablename(column_name_1 column_type_1 constraints,
column_name_2 column_type_2 constraints, ... column_name_n column_type_n constraints)
1)因为MySQL的表名是以目录的形式存在于磁盘上，所以表名的字符可以用任何目录名允许的字符。
2)column_name是列的名字。
3)column_type是列的数据类型。
4)constraints是列的约束条件。

<2>修改表
ALTER TABLE tablename MODIFY [COLUMN] column_definition [FIRST|AFTER col_name]  //修改表类型
ALTER TABLE tablename ADD [COLUMN] column_definition [FIRST|AFTER col_name]   //增加表字段
ALTER TABLE tablename DROP [COLUMN] col_name   //删除表字段
ALTER TABLE tablename CHANGE [COLUMN] old_col_name column_definition [FIRST|AFTER col_name]   //字段改名
ALTER TABLE tablename RENAME [TO] new_tablename  //表改名

2、DML(Data Manipulation Language)语句：
数据操纵语句，用于添加、删除、更改和查询数据库记录，并检查数据完整性。
常用的语句关键词主要包括insert、delete、update、select等。
INSERT INTO tablename (field1,field2,……fieldn) VALUES(value1,value2,……valuesn);
UPDATE tablename SET field1=value1，field2=value2，……fieldn=valuen [WHERE CONDITION]
DELETE FROM tablename [WHERE CONDITION]
SELECT * FROM tablename [WHERE CONDITION]

/***********************************************查询**************************************************/

1)SELECT * FROM tablename [WHERE CONDITION]
select * from tablename;  //把所有记录都选出来
select field1,field2,...,fieldn tablename;  //逗号分割需要查询的字段
select * from tablename where field1=1;     //列出符合条件的记录 > < >= <= != 多个条件之间使用or and等逻辑运算符

2)distinct //将表中的记录去掉重复后显示出来
select distinct field1 from tablename; //将字段1不重复的记录显示出来，只显示字段1那列

3)ORDER BY 排序
SELECT * FROM tablename [WHERE CONDITION] [ORDER BY field1 [DESC|ASC], field2 [DESC|ASC],...,fieldn[DESC|ASC]]
其中：DESC表示按照字段降序排列，ASC表示升序排列，如果不写关键字默认是升序排列。
ORDER BY后面可以跟多个不同的排序字段，并且每个字段可以有不同的排列顺序。（若第一个字段相同，再按第二个字段排序。）

eg：select * from tablename order by field1，field2 desc;
注：GROUP BY强加了ORDER BY，如果要避免需要显示使用ORDER BY NULL。

4)LIMIT
对于排序后的记录，如果只希望显示一部分，可以用LIMIT关键字。
SELECT ... [LIMIT offset_start,row_count] //offset_start表示记录的起始偏移量(默认为0)，row_count表示显示的行数

eg: select * from tablename order by field1 limit 3; //显示前3条记录
    select * from tablename order by field1 limit 1,3; //从第2条开始，显示3条记录

5)聚合
SELECT [field1,field2,...,fieldn] fun_name   //fun_name表示要做的聚合操作，也就是聚合函数，如: sum、count(*)、max、min
FROM tablename 
[WHERE where_condition] 
[GROUP BY field1,field2,...,fieldn]  //GROUP BY关键字表示要进行分类聚合的字段，比如要按照部门分类统计员工数量，部门就应该写在group by后面
[WITH ROLLUP]   //可选，表明是否对分类聚合后的结果进行再汇总。
[HAVING where_condition]  //表明对分类后的结果再进行条件过滤。

6)表连接
当需要同时显示多个表中的字段时，就可以用表连接来实现这样的功能。
分为内连接和外连接，内连接仅仅选出两张表中互相匹配的记录，而外连接会选出其他不匹配的记录。
	
	
/*****************************************************************************************************/

3、DCL(Data Control Language)用于授予或回收数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监控等。
GRANT--授权
ROLLBACK--回滚
COMMIT--提交

4、提交数据有三种类型：显式提交、隐式提交及自动提交。
<1>显式提交
用 COMMIT 命令直接完成的提交为显式提交。
<2>隐式提交
用 SQL 命令间接完成的提交为隐式提交。
这些命令是：ALTER\AUDIT\COMMENT\CONNECT\CREATE\DISCONNECT\DROP\EXIT\GRANT\NOAUDIT\QUIT\REVOKE\RENAME
<3>自动提交
若把AUTOCOMMIT设置为 ON ，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为:SQL> SET AUTOCOMMIT ON;
     
<4>COMMIT/ROLLBACK这两个命令用的时候要小心。 COMMIT/ROLLBACK都是用在执行DML语句（INSERT/DELETE/UPDATE/SELECT）之后的。
1)DML语句执行完之后，处理的数据都会放在回滚段中（除了SELECT语句）,等待用户进行提交（COMMIT）或者回滚 （ROLLBACK），
当用户执行COMMIT/ROLLBACK后，放在回滚段中的数据就会被删除。
2)SELECT语句执行后，数据都存在共享池。提供给其他人查询相同的数据时，直接在共享池中提取，不用再去数据库中提取，提高了数据查询的速度。
3)所有的 DML 语句都是要显式提交的，也就是说要在执行完DML语句之后，执行COMMIT。
而其他的诸如 DDL 语句的，都是隐式提交的。也就是说，在运行那些非DML语句后，数据库已经进行了隐式提交，
例如 CREATE TABLE，在运行脚本后，表已经建好了，并不在需要你再进行显式提交。在提交事务（commit）之前可以用rollback回滚事务。

二、表的存储引擎
1、MySQL 5.0支持的存储引擎包括：MyISAM、InnoDB、BDB、MEMORY等。其中InnoDB和BDB提供事务安全表，其他存储引擎都是非事务安全表。
参数default-table-type设置默认存储引擎。

2、相关命令
show variables like 'table_type'; //查看当前默认存储引擎
show engines \G  //查看当前数据库支持的存储引擎
show variables like 'have%'; //查看当前数据库支持的存储引擎

show variables like '%innodb%';   //查看innodb相关配置参数
show status like '%innodb%';  //查看innodb相关的运行时参数（比如当前正在打开的表的数量，当前已经打开的表的数量）
show global status like 'open%tables';  //查看全局的运行时参数，加上global是对当前mysql服务器中运行的所有数据库实例进行统计。
									不加global则只对当前数据库实例进行统计。
									
3、InnoDB的存储方式
<1>使用共享空间存储
这种方式创建的表结构保存在.frm文件中，数据和索引保存在innodb_data_home_dir和innodb_data_file_path定义的表空间中。可以是多个文件。

<2>使用多表空间存储
这种方式创建的表结构保存在.frm文件中，每个表的数据和索引单独保存在.ibd中。
如果是分区表，每个分区对应单独的.ibd文件，可以在创建时指定每个分区的数据文件位置，以此来将表的IO均匀分布在多个磁盘上。

1)要使用多表空间的存储方式，需要设置参数innodb_file_per_table，重新启动服务后生效。
之后对于新建的表按照多表空间的方式创建，已有的表仍使用共享表空间存储。

2)多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数。

3)使用多表空间特性的表，可以方便地进行单表备份和恢复操作。
因为没有共享表空间的数据字典信息，直接复制.ibd和.frm文件恢复时是不能被正确识别的，可以使用以下命令将备份恢复到数据库中，
ATLER TABLE tbl_name DISCARD TABLESPACE;
ATLER TABLE tbl_name IMPORT TABLESPACE;
但是这样的单表备份只能恢复到原来所在的数据库中，而不能恢复到其他的数据库中。
如果需要恢复到目标数据库，则要通过mysqldump和mysqlimport来实现。

4、相关配置参数
1、innodb_read_io_threads\innodb_write_io_threads
在MySQL5.5.X版本中，这两个参数取代了innodb_file_io_threads。分表表示InnoDB使用后台线程处理数据页上读写I/O请求的数量，默认值都是4。
32个逻辑CPU时可以分别改为16。

2、innodb_thread_concurrency
InnoDB会试图将InnoDB服务的使用的操作系统进程小于或等于这里所设定的数值。此参数默认值为 8。
如果你的计算机系统有很多的处理器与磁盘系统，则可以将这个值设高一点以充分利用你的系统资源。建议设值为处理器数目+磁盘数目。
在当前最新版本的mysql中，innodb_thread_concurrency的默认值为0，它表示默认情况下不限制线程并发执行的数量。 

3、innodb_buffer_pool_size
InnoDB用来高速缓冲数据和索引内存缓冲大小。更大的设置可以使访问数据时减少磁盘 I/O。这对Innodb表来说非常重要。Innodb相比MyISAM表对缓冲更为敏感。
在一个专用的数据库服务器上可以将它设置为物理内存的80%。
不要将它设置太大，因为物理内存的使用竞争可能会影响操作系统的页面调用。在my.cnf中以数字格式设置。

4、innodb_log_file_size   
日志组中的每个日志文件的大小(单位 MB)。
如果 n 是日志组中日志文件的数目，那么理想的数值为 1M 至下面设置的缓冲池(buffer pool)大小的 1/n。
较大的值，可以减少刷新缓冲池的次数，从而减少磁盘 I/O。但是大的日志文件意味着在崩溃时需要更长的时间来恢复数据。 
日志文件总和必须小于2G，3.23.55和4.0.9以上为小于4G。在my.cnf中以数字格式设置。

5、innodb_flush_log_at_trx_commit
通常设置为 1，意味着在事务提交前日志已被写入磁盘，事务可以运行更长以及服务崩溃后的修复能力。
如果你愿意减弱这个安全，或你运行的是比较小的事务处理，可以将它设置为0，以减少写日志文件的磁盘 I/O。这个选项默认设置为0。
这个参数的含义是事务提交刷写磁盘的模式。为1，每个事务都进行写盘。为0时：log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。


参数	前一次测试	本次测试
innodb_read_io_threads	4	8
innodb_write_io_threads	4	16
thread_concurrency	10	32
innodb_log_file_size	10000M	600M
innodb_log_files_in_group	2	3
innodb_log_buffer_size	8M	16M
innodb_flush_log_at_trx_commit	0	0
innodb_buffer_pool_size	20000M	20000M


三、一些资料
1、金海：
<1>mysql分区表，分区自己维护增加和删除，时间序列是range那种类型。
http://www.cnblogs.com/mliudong/p/3625522.html
http://www.2cto.com/database/201503/380348.html

<2>laodfile用法和技巧和性能
http://blog.csdn.net/qmyzch/article/details/53141911   （设置缓存大小）
http://blog.jobbole.com/85657/   性能测试

<3>线程和配置
http://book.2cto.com/201402/40300.html  据说5.1支持4核，5.5支持24核，5.6支持64核，io读写线程很关键。
http://blog.csdn.net/u010433704/article/details/50524117  配置指南

<4>分析总结：
增加io线程以后，性能比第一次15万提升了20%，达到18万。
直觉是索引还有些问题，所以第二次插入同一分区的时候性能下降明显（工程上可以规避插入新的分区即可）。
我猜测你是用b树默认索引，索引填充因子和树分裂有关，因此出现大量毛刺导致性能下降。注意观察插入时刻的cpu占用率情况。
尝试大页面的情况下，分区的第二次插入是否有所改善，若是则说明填充因子需要调整。
我预计最终能每秒能达到25-30万左右。
基础测试中任何疑点都不能放过，宁可慢，切记切记。

你索引是b树还是哈希的？  可以参见这篇 http://blog.sina.com.cn/s/blog_6776884e0100pko1.html
http://www.cnblogs.com/olinux/p/5161826.html   如果是整形，可以采用哈希索引。时间如果是字符串，一般只能用b树。如果列1用整形，等价于列二的时间，那么索引只要建一个即可，不需要复合索引。
这篇关键：
http://blog.csdn.net/great_tony/article/details/47280963
InnoDB的主键选择与插入优化
在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。
经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。
上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。
如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：

这篇是innodb关于索引参数的优化：innodb_page_size，MERGE_THRESHOLD，innodb_fill_factor 主要这三个关键字
http://blog.csdn.net/aeolus_pu/article/details/56833191


2、索引
http://blog.csdn.net/lmh12506/article/details/8879916
http://blog.csdn.net/xluren/article/details/32746183   

3、分区表操作
http://blog.csdn.net/orangleliu/article/details/57088338    MySQL对数据表已有表进行分区表

SELECT * FROM information_schema.PARTITIONS WHERE table_name='tablename';//查看表的分区
select count(*) from tableName PARTITION (P01);
ALTER TABLE policy_partition ADD PARTITION (PARTITION p08 VALUES LESS THAN (20170702000000)); //新增分区
alter table policy_partition drop partition p8;  //删除分区



四、一些问题：
1、->
记得语句结尾加;

2、Host '10.43.241.216' is not allowed to connect to this MySQL servertime: 0.001！
http://blog.csdn.net/dazhi_100/article/details/50553947
http://www.cnblogs.com/yuejin/archive/2013/11/12/3419467.html   //外网连接mysql
mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'db10$ZTE' WITH GRANT OPTION;                
Query OK, 0 rows affected (0.12 sec)

mysql> flush privileges;

3、LOAD DATA INFILE时报duplicate entry for key错误
通常是数据中唯一索引冲突导致。
load csv file error! csv file name=NoticeFile20170401155049.csv. ret=1!
Duplicate entry '150778720309359-2017-04-03 15:50:51-2541236063' for key 'index_subscriber_time_policy', errno=1062

4、int
<1>int类型占4个字节32位，默认是有符号的。无符号范围为0-4,294,967,295，有符号范围为-2147483648-2147483647。
<2>修改为usigned：alter table tablename modify 字段名 int zerofill
<3>int(40);只是表示显示40宽度（不足前面加0），与实际数据库存储该字段所用的空间无关。
通常int为int(11)，无符号int为int(10)
PolicyId               | int(10) unsigned zerofill | YES  | MUL | NULL    |       |
UserGrade              | int(11)                   | YES  |     | NULL    |       |

5、多线程
<1>MySQL允许多个线程同时导入数据，即多个线程同时insert，不会冲突。要给每个都线程建立连接。
<2>mysql中有一种机制是表锁定和行锁定，为什么要出现这种机制，是为了保证数据的完整性。
如果有二个sql都要修改同一张表的同一条数据，这个时候怎么办呢，是不是二个sql都可以同时修改这条数据呢？
很显然mysql对这种情况的处理是，一种是表锁定（myisam存储引擎），一个是行锁定（innodb存储引擎）。
表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。
行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。
如果数据太多，一次执行的时间太长，等待的时间就越长，这也是我们为什么要分表的原因。

五、待研究
http://blog.csdn.net/czw698/article/details/42294171   //亿级别MySQL使用


六、mysql配置参数
1、bind_address
<1>bind_address后面增加远程访问IP地址或者注释掉，重启Mysql，就可以远程登录数据库了。
<2>设为0.0.0.0表示所有IP都能访问。

























