MySQL支持对MyISAM和MEMORY存储引擎的表进行表级锁定；
		 对BDB存储引擎的表进行页级锁定；
		 对InnoDB存储引擎的表进行行级锁定。
默认情况下，表锁和行锁都是自动获得的，不需要额外的命令。
某些情况下，用户需要明确地进行锁表或事务的控制，以便确保整个事务的完整性，此时就需要使用事务控制和锁定语句来完成。

1、LOCK TABLE和UNLOCK TABLE
<1>使用方式：
1)LOCK TABLES可以锁定当前线程使用的表。如果表被某个线程锁定，其他线程会等待，直到可以获取所有锁定为止。
2)UNLOCK TABLES可以释放当前线程获得的所有锁定。
3)线程执行另一个LOCK TABLES时，或与服务器的连接被关闭时，所有由该线程锁定的表都被隐式地解锁。

<2>使用示例：
session1、session2表示两个连接(两个线程)。
<1>session1获取表的READ锁定。  LOCK TABLE tablename READ;
此时session1和session2都可以查询该表的记录。

<2>若session2要更新表内容，就会等待获得锁。

2、事务控制
<1>MySQL通过SET AUTOCOMMIT、START TRANSACTION、COMMIT和ROLLBACK等语句支持本地事务。
SET AUTOCOMMIT = {0 | 1}
START TRANSACTION | BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]

<2>默认情况下，MySQL是自动提交的(Autocommit)。
1)如果需要通过明确的Commit和Rollback来提交和回滚事务，那么就需要通过明确的事务控制命令来开始事务。(这点与Oracle不同)

2)START TRANSACTION或BEGIN语句可以开始一项新的事务；
  
3)COMMIT和ROLLBACK用于提交或回滚事务；CHAIN和RELEASE子句分别用来定义在事务提交或回滚后的操作。
CHAIN会立即启动一个新事务，并且和之前的事务具有相同的隔离级别；
RELEASE则会立即断开和客户端的连接。

4)SET AUTOCOMMIT可以修改当前连接的提交方式
如果设置了SET AUTOCOMMIT=0，那么之后所有的事务都需要通过明确的命令进行提交或回滚。

---------------------------------------------------------------------------------------------------

一、事务
1、简介
<1>事务就是一组原子性的SQL查询，或者说是一个独立的工作单元。
如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。
如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。
也就是说，事务内的语句要么全部执行成功，要么全部执行失败。

<2>除非系统通过严格的ACID测试，否则空谈事务的概念是不够的。
一个运行良好的事务处理系统，必须具有：
原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元。
一致性(consistency)：数据库总是从一个一致性状态转到另一个一致性状态。
隔离性(isolation)：通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。
持久性(durability)：一旦事务提交，其所做的修改就会永久保存在数据库中。即使系统崩溃，数据也不会丢失。

<3>用户可以根据业务是否需要事务处理，来选择合适的存储引擎。
对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。

2、隔离级别
SQL标准中定义了四种隔离级别，每种级别规定了一个事务中所做的修改，哪些在事务内和事务间是可见的。
较低级别的隔离通常可以执行更高的并发，系统开销也更低。

<1>READ UNCOMMITTED(未提交读)
1)该级别，事务中的修改即使未提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为脏读(Dirty Read)。
2)该级别会导致很多问题，实际应用中很少使用。

<2>READ COMMITTED(提交读)
1)该级别是大多数数据库系统的默认隔离级别(但MySQL不是)。
2)一个事务开始时，只能看见已经提交的事务所做的修改。
换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。
3)该级别也叫作不可重复读(nonrepeatable read)，因为两次执行同样的查询，可能会得到不一样的结果。

<3>REPEATABLE READ(可重复读)
1)该级别解决了脏读的问题，且保证在同一个事务中多次读取同样记录的结果是一致的。
2)理论上该级别还是无法解决幻读(Phantom Read)的问题。
InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题。
3)该级别是MySQL的默认事务隔离级别。

<4>SERIALIZABLE(可串行化)
1)该级别是最高的隔离级别。强制事务串行执行，避免了幻读问题。
简单来说，该级别会在读取的每一行数据上都加锁。
2)实际应用中该级别很少使用，只在非常需要确保数据一致性，且可接受没有并发的情况下使用。

<5>综述
   隔离级别		      脏读可能性		 不可重复读可能性        幻读可能性        加锁读
READ UNCOMMITTED		Yes						Yes					Yes				No
READ COMMITTED			No						Yes					Yes				No
REPEATABLE READ			No						No					Yes				No
SERIALIZABLE			No						No					No				Yes

<6>每种存储引擎实现的隔离级别不尽相同。
1)MySQL能够识别所有的4个ANSI隔离级别，InnoDB引擎也支持所有的隔离级别。

2)MySQL可以通过执行SET TRANSACTION ISOLATION LEVEL命令来设置隔离级别。新的隔离级别会在下一个事务开始时生效。

//查询隔离级别
mysql> SHOW VARIABLES LIKE '%ISOLATION%';  
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.01 sec)


可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别：
mysql> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

3、死锁
<1>死锁是指两个或多个事务在同一个资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
1)当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。
2)多个事务同时锁定同一个资源时，也会产生死锁。

<2>解决方法
1)数据库系统实现了各种死锁检测和死锁超时机制。
InnoDB处理死锁的方法：将持有最少行级排他锁的事务进行回滚。
2)当查询时间达到锁等待超时的设定后，放弃锁请求。

<3>锁的行为和顺序与存储引擎相关。
1)死锁发生后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，是无法避免的。
2)应用程序在设计时必须考虑如何处理死锁。大多数情况下，只要重新执行因死锁回滚的事务即可。

4、事务日志
<1>事务日志可以帮助提高事务的效率。
1)使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久硬盘上的事务日志中，
而不用每次都将修改的数据本身持久到磁盘。
2)事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，
所以采用事务日志的方式相对来说要快很多。
3)事务日志持久以后，内存中被修改的数据在后台可以慢慢回刷到磁盘。
目前大多数存储引擎都是这样实现的，称之为预写式日志。(修改数据需要些两次磁盘)
4)如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，
存储引擎在启动时能够自动恢复这部分修改的数据。

5、MySQL中的事务
MySQL提供两种事务型的存储引擎：InnoDB、NDB Cluster。另外一些第三方存储引擎也支持事务：XtraDB、PBXT。

<1>自动提交(AUTOCOMMIT)
MySQL默认采用自动提交模式。
也就是说，如果不是显式地开始一个事务，则每个查询都被当做一个事务执行提交操作。

1)在当前连接中，可以通过设置AUTOCOMMIT变量来启动或禁用自动提交模式：
mysql> SHOW VARIABLES LIKE 'AUTOCOMMIT';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)

//1或者ON表示启用；0或者OFF表示禁用。

2)当设置AUTOCOMMIT=0时，所有的查询都是在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，
该事务结束，同时又开始一个新事务。

3)修改AUTOCOMMIT对非事务型的表(eg：MyISAM或者内存表)不会有任何影响。
对于这类表来说，没有COMMIT或ROLLBACK的概念，也可以说是相当于一直处于AUTOCOMMIT启用的模式！

4)还有一些命令，在执行之前会强制执行COMMIT提交当前的活动事务。
eg：DDL(数据定义语句)中，如果是会导致大量数据改变的操作(如：ALTER TABLE)。
//查询对应版本的官方文档，确认所有可能导致自动提交的语句列表。

<2>在事务中混合使用存储引擎
MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。

1)在一个事务中使用多个存储引擎是不可靠的。
eg：在事务中混合使用了事务型和非事务型的表(如：InnoDB和MyISAM)，正常提交的情况下没有任何问题。
但如果事务需要回滚，非事务型表上的变更却无法撤销。导致数据库处于不一致的状态，事务的最终结果将无法确定。

为每张表选择合适的存储引擎非常重要！

在非事务型的表上执行事务操作，MySQL通常不会发出提醒，也不会报错。

<3>隐式和显式锁定
InnoDB采用的是两阶段锁定协议。
1)隐式锁定：InnoDB会根据隔离级别在需要的时候自动加锁
事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK时才会释放，并且所有锁在同一时刻释放。

2)显式锁定：InnoDB也支持通过特定的语句进行显式锁定(这些语句不属于SQL规范)
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE

3)MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。
它们有自己的用途，但并不能替代事务处理。
如果应用需要用到事务，还是应该选择事务型存储引擎。
----------------------------------------------------------------------------------
注：
<1>经常遇到，应用已经将表从MyISAM转换到InnoDB，但还是显式地使用LOCK TABLES语句。
这不但没有必要，还会严重影响性能。实际上InnoDB的行级锁工作得更好。

<2>LOCK TABLES和事务之间互相影响会产生无法预料的结果。
因此，除了事务中禁用AUTOCOMMIT时，可以使用LOCK TABLES；
其他任何时候无论使用何种存储引擎，都不要显式执行LOCK TABLES。
----------------------------------------------------------------------------------

二、多版本并发控制
1、MySQL大多数事务型存储引擎实现的都不是简单的行级锁。
基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制(MVCC)。
<1>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。

<2>MVCC是通过保存数据在某个时间点的快照来实现的。
不管需要执行多长时间，每个事务看到的数据都是一致的。
根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

2、不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制。
<1>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。
1)这两列，一个保存了行的创建时间，一个保存了行的过期时间(或删除时间)。
2)存储的不是实际的时间值，而是系统版本号。每开始一个新事务，系统版本号都会自动递增。
3)事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

<2>InnoDB在REPEATABLE READ隔离级别下，MVCC具体操作：
1)SELECT 符合以下条件的记录，才能作为查询结果返回。
a. InnoDB只查找版本号早于当前事务版本的数据行。(行的系统版本号小于或等于事务的系统版本号)
这样可以确保事务读取的行，要么在事务开始前已经存在，要么是事务本身插入或修改过的。
b. 行的删除版本要么未定义，要么大于当前事务版本号。
这样可以确保事务读取到的行，在事务开始之前未被删除。

2)INSERT
InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

3)DELETE
InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

4)UPDATE
InnoDB为插入一行新记录，保存当前系统版本号作为行版本号；同时保存当前系统版本号到原来的行作为删除标识。

<3>保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。
不足之处是每行记录都需要额外的存储空间，需要做更多的行检查以及一些额外维护工作。

3、MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。



