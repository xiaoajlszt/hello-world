第一章 操作系统引论
1.3 操作系统的基本特征
并发、共享、虚拟、异步，其中并发特征是操作系统最重要的特征，是其他三个特征的前提。
1、并发性：
<1>并发与并行
-并发性是指两个或多个事件在同一时间间隔内发生。
 在单处理系统中，宏观上一段时间内有多个程序在同时运行；微观上每一时刻却仅有一道程序执行，分时交替执行。
-并行性是指两个或多个事件在同一时刻发生。
 倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可以被分配到多个处理机上，实现并行执行。
 
<2>引入进程
为了使多个程序能够并发执行，系统必须分别为每个程序建立进程。
进程是指在系统中能独立运行并作为资源分配的基本单元，它由一组机器指令、数据和堆栈组成的，是一个能独立运行的活动实体。

<3>引入线程
-当一个进程因故不能继续运行时，操作系统变调度另一个进程运行。由于进程拥有自己的资源，故调度付出的开销较大。
-通常一个进程可以包含若干个线程，它们可以利用进程所拥有的资源。
-通常把进程作为分配资源的基本单元，把线程作为独立运行和独立调度的基本单元。
-线程调度所付出的开销比进程小很多，能高效地提高系统内多个程序间并发执行的程度，以便进一步提高系统的并发性。

2、共享性
所谓共享，是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。这些资源成为共享资源。

3、虚拟技术
所谓虚拟，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物(虚的)。
如果说时分复用技术是利用处理机的空闲时间来运行其他的程序，提高处理机的利用率；那么空分复用技术则是利用存储器的空闲空间来存放其他的程序，提高内存利用率。

<1>时分复用技术(分时使用方式)
<2>空分复用技术

如果虚拟的实现是通过时分复用的方法，即对某一物理设备进行分时使用，设N是某物理设备所对应的虚拟的逻辑设备数，则每台虚拟设备的平均速度必然等于或低于物理设备速度的1/N;
如果虚拟的实现是通过空分复用的方法，此时一台虚拟设备平均占用的空间必然也等于或低于物理设备所拥用空间的1/N。

4、异步性
-在多道程序环境下允许多个进程并发执行，但只有进程在获得所需资源后方能执行。
-进程以不可预知的速递向前推进，此即进程的异步性。但只要在操作系统中配置完善的进程同步机制，且运行环境相同，作业经过多次运行都会获得完全相同的结果。因此异步运行方式是允许的。


1.4 操作系统的主要功能
1、处理机管理
创建和撤销进程(线程)、对所有进程(线程)的运行进行协调、实现进程(线程)之间的信息交换、按照一定的算法把处理机分配给进程(线程)
<1>进程控制
要是作业运行，必须先为它创建一个或几个进程，并为之分配必要的资源；当进程运行结束时，立即撤销该进程，以便能及时回收进程所占用的各类资源。
创建进程(线程)、撤销已结束的进程(线程)、控制进程在运行过程中的状态转换。

<2>进程同步
进程是以异步方式运行的，并以人们不可预知的速度向前推进，为了使多个进程能够有条不紊地运行，系统中必须设置进程同步机制。
1)进程互斥方式(加锁)
对临界资源的访问

2)进程同步方式(信号量)
在相互合作完成共同任务的各个进程(线程)间，由同步机构对他们执行顺序加以协调。

<3>进程通讯
当相互合作的进程(线程)处于同一计算机系统时，通常在它们之间是采用直接通讯的方式，即由源进程利用发送命令直接将消息挂到目标进程的消息队列上，由目标进程利用接收命令从消息队列中取出消息。

<4>调度
在后备队列上等待的每个作业多需要经过调度才能执行。
1)作业调度

2)进程调度

2、存储器管理功能
1)内存分配
静态分配：作业的内存空间在装入时确定，装入后的运行期间不允许作业在申请新的内存空间，也不允许作业在内存中“移动”；
动态分配：作业所要求的基本内存空间也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，也允许作业在内存中“移动”。

2)内存保护
确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰。不允许用户程序访问操作系统的程序和数据。

3)地址映射
每个程序的地址都是从"0"开始的，程序中的其他址都是相对于起始地址计算的。"地址空间"、"逻辑地址/相对地址"
                                                                       "内存空间"、"物理地址"
存储器管理必须提供地址映射功能，将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。

4)内存扩充
存储器管理中的内存扩充并非是扩大物理内存的容量，而是借助虚拟存储技术，从逻辑上去扩充内存容量。


第二章 进程管理
2.1.4 进程的特征与状态
<1>进程的特征
为了使程序能并发执行(执行结果不出错)，且为了对并发执行的程序加以描述和控制，引入了进程的概念。
1)结构特征
通常程序是不能并发执行的，为了使程序能独立运行，要配置一进程控制块PCB，程序段、数据段和PCB三部分构成了进程的实体。
许多情况下所说的进程，实际上是指进程实体，所谓创建/撤销进程，实质上是创建/撤销进程实体中的PCB。

2)动态性
进程的实质是进程实体的一次执行过程，因此进程具有一定的生命周期。动态性表现在，它由创建而产生、由调度而执行、由撤销而消亡。

3)并发性
指多个进程实体同存于内存中，且能在一段时间内同时运行。而程序(没有建立PCB)是不能并发执行的。

4)独立性
指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单元。

5)异步性

2.1.5 进程控制块
1、在进程的整个生命期中，系统总是通过PCB对进程进行控制的。
   系统根据进程的PCB感知进程的存在，PCB是进程存在的唯一标志。
   系统创建新进程时，就为它创建一个PCB；进程结束时又回收其PCB。

2、PCB经常被操作系统访问，尤其是被运行频率很高的进程及分派程序访问，故PCB应常驻内存。
   系统将所有的PCB组织成若干链表(或队列)，存放在操作系统中专门开辟的PCB区内。
   
3、进程控制块中的信息：
<1>进程标识符  //唯一标识一个进程
1)内部标识符：系统使用，通常是一个进程的序号
2)外部标识符：创建者提供，由用户在访问该进程是使用

<2>处理机状态
处理机状态信息主要是由处理机的各种寄存器中的内容组成的。处理机在运行时，许多信息都放在寄存器中。
当处理机被中断时，所有这些信息都必须保存在PCB中，以便在该进程重新执行时，能从断点继续执行。

<3>进程调度信息

<4>进程控制信息

2.2进程的控制
进程控制一般由OS内核中的原语来实现的。
原语(Primitive)是由若干条指令组成的，用于完成一定功能的一个过程。它是原子操作。

block() //自我阻塞，放弃处理机
wakeup() //唤醒等待进程


2.2.1进程的创建
子进程可以继承父进程所拥有的资源。(如：继承父进程打开的文件；继承父进程所分配到的缓冲区等)
当子进程被撤销时，应将其从父进程获得的资源归还给父进程。
撤销父进程时，也必须同时撤销其所有的子进程。
PCB中设置了家族关系表项，用以标明自己的父进程及所有的子进程。

2.3进程同步
对多个相关进程在执行次序上进行协调，使并发执行的各个进程之间能有效共享资源和相互合作，从而使程序的执行具有可在再现性。
2.3.1进程同步的基本概念
1、两种形式的制约关系
<1>间接相互制约关系  //争抢资源
<2>直接相互制约关系  //进程间合作

2、临界资源
互斥访问

3、临界区
把在每个进程中访问临界资源的那段代码称为临界区。
若能保证各个进程互斥地进入自己的临界区，便可以实现对临界资源的互斥访问。
每个进程在进入临界区之前，应先对要访问的临界资源进行检查，如果未被访问，进程便可进入临界区，并设置它正被访问的标志。

4、同步机制遵循的原则
<1>空闲让进
<2>忙则等待
<3>有限等待
<4>让权等待

2.3.2信号量(Semaphores)机制  //一种卓有成效的进程同步工具
1、整型信号量  //一个用于表示资源数目的整型量S
初始化之后，只能通过两个标准的原子操作 wait(S)和signal(S)来访问。
wait(S)和signal(S)是两个原子操作，它们在执行时是不可中断的。当一个进程在修改某信号量时，没有其他进程可同时修改该信号量。

整型信号量机制中的wait操作，只要是信号量S<=0，就会不断测试。因此，该机制并未遵循"让权等待"的准则，而是使进程处于"忙等"状态。

2、记录型信号量  //是由于采用记录型的数据结构而得名的
采取"让权等待"的策略。一个用于代表资源数目的整型变量value；一个进程链表指针L(链接所有等待的进程)。
如果value初始值为1，表示只允许一个进程访问临界资源，此时信号量转化为互斥信号量，用于进程互斥。

3、AND型信号量  //一个进程需要先获得两个或更多的共享资源
基本思想：将进程在整个运行过程中所需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放。
也就是对若干临界资源的分配采用原子操作方式。这样可以避免死锁情况发生。
也称为AND同步或同时wait操作。

4、信号量集
当一次需要N个某类型临界资源时，需要N次wait(S)操作，很低效。对AND信号量机制加以扩充。
Swait(S,d,d)
Swait(S,1,1)
Swait(S,1,0)

2.3.4管程机制  //另一种进程同步工具
1、管程(Monitors)的定义
系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，
即用少量信息和对该资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。

利用共享数据结构抽象地表示系统中的共享资源，而把对该共享数据结构实施的操作定义为一组过程，
如资源的请求request和释放release过程。

代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，
共同构成了一个操作系统的资源管理模块，我们称子为管程。

一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。

2.5 进程通信
进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。
高级进程通信，用户可以直接利用操作系统所提供的一组通信命令高效地传递大量数据的一种通信方式。操作系统隐藏了进程间通信的实现细节(对用户是透明的)。

2.5.1 进程通信的类型
一、共享存储器系统
相互通信的进程共享某些数据结构或共享存储区，进程之间通过这些空间进行通信。
1、基于共享数据结构的通信方式
要求进程公用某些数据结构，来实现进程间的信息交换。  //低效，只适合传递少量的数据          

2、基于共享存储区的通信方式
为了传输大量数据，在存储器中划出了一块共享存储区，各个进程可通过对共享存储区中数据的读写来实现通信。  //属于高级通信
进程在通信前，先向系统申请获得共享存储区中的一个分区。

二、消息传递系统
是当前应用最为广泛的一种进程间通信机制，通过格式化的消息为单元实现进程间消息交换。
程序员直接利用操作系统提供的一组通信命令(原语)，不仅能实现大量数据的传递，而且还隐藏了通信的实现细节，使通信过程对用户是透明的。
//是一种高级通信方式，又因其实现方式的不同分为直接通信方式和间接通信方式两种。

三、管道通信
用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又叫pipe文件。

2.5.2 消息传递通信的实现方法
一、直接通讯方式
发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。此时要求发送进程和接收进程都以显示方式提供对方的标识符。

二、间接通信方式
指进程之间的通信需要通过作为共享数据结构的实体。该实体用来暂存消息，接收进程则从该实体中取出对方发送给自己的消息。通常把这种中间实体称为信箱。
1、利用信箱通信方式，既可以实时通信，又可实现非实时通信。
2、系统为信箱通信提供了若干条原语，分别用于信箱创建、撤销和消息发送、接收等。

2.5.3 消息传递系统实现中的若干问题
一、通信链路
1、单机系统：发送进程无须明确提出建链请求，只需利用系统提供的发送命令(原语)，系统会在佛那个地为之建立一条链路。
2、网络通信：发送进程在通信之前要显示的建立链接的命令(原语)请求系统为之建立一条通信链路；在链路使用完后，也用显示方式拆除。

连接方式：
<1>点到点连接通信链路
<2>多点连接链路

通信方式：
<1>单向通信链路
<2>双向链路

通信链路容量的不同：
<1>无容量通信链路：链路上没有缓冲区，因而不能暂存任何消息
<2>有容量通信链路：链路上设置了缓冲区，能够暂存消息。缓冲区数目越多，通信链路的容量越大。

二、消息的格式
通常把一个消息分为消息头和消息正文两部分。消息头包含消息在传输中所需的控制信息。

三、进程同步方式

2.5.4 消息缓冲队列通信机制
//广泛应用于本地进程之间的通讯中。

2.6 线程(Threads)
一、线程的基本概念
1、线程的引入
操作系统引入进程的目的是为了多个程序能并发执行，以提高资源利用率和系统吞吐量；
操作系统引入线程的目的是为了减少程序在并发执行时所付出的时空开销，使得操作系统具有更好的并发性。

进程切换付出较大的时空开销，因此，系统中所设置的进程数目不宜过多，进程切换频率不宜过高。

2、线程与进程的比较
传统进程相当于只有一个线程的任务；引入进程后的操作系统中，通常一个进程都拥有若干个线程。

<1>调度
线程作为调度和分派资源的基本单元；进程作为拥有资源的基本单元。
把传统进程的两个属性分开，使线程基本上不拥有资源，从而就可以显著地提高系统的并发程度。

在同一进程中，线程的切换不会引起进程的切换；但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。

<2>并发性

<3>拥有资源
线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源(进程的代码段、数据段、所拥有的系统资源)。

<4>系统开销
线程切换仅需保存和设置少量寄存器内容，不涉及存储器管理方面的操作。
/**********************************************************************************/
？？？(CPU有多少个寄存器，够给这些线程保存数据？？？)
补充说明：
如何理解"每个线程都有它自己的一组CPU寄存器和它自己的堆栈"???

这里说的一组寄存器不是物理上的，而是逻辑上的。
每个线程都需要有一块地址用来做线程让出CPU所有权时保存cpu各个寄存器的值;在线程重新拥有cpu的时候用于恢复运行状态。

CPU是只有一组，不过切换到自己的时候就把堆栈中保存的之前的值又放到寄存器中。

/**********************************************************************************/
一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。

3、线程的属性
<1>轻型实体。线程只有一点保证其独立运行的资源，如：
用于控制线程运行的线程控制块TCB；
指示被执行指令序列的程序计数器PC；
保留局部变量、少数状态参数、返回地址等的一组寄存器和堆栈。

4、线程的状态
<1>寄存器状态
<2>堆栈：堆栈中通常保存有局部变量和返回地址
<3>线程运行状态

5、线程的创建和终止

6、多线程OS中的进程
进程拥有多个线程并未它们提供资源，但此时的进程就不再作为一个执行的实体。
因此，所谓的进程处于执行状态，实际上是指该进程中的某线程正在执行。
对进程施加的与进程状态相关的操作，也对其线程起作用。

二、线程间的同步和通信
1、互斥锁(mutex)
操作互斥锁的时间和空间开销都比较低，因而适合于高频率使用的关键共享数据和程序段。
unlock  lock  
Trylock

2、条件变量  //为了解决互斥锁的死锁问题
每一个条件变量通常都与一个互斥锁一起使用。单纯的互斥锁用于短期锁定，主要保证对临界区的互斥进入；而条件变量则用于线程的长期等待，直到所等待的资源成为可用资源。

3、信号量机制
<1>私用信号量  //属于某个特定进程，OS并不知道其存在
当某线程需要利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一个私用信号量。

<2>公用信号量  //供所有进程使用，由OS分配空间并进行管理，也称为系统信号量
公用信号量为实现不同进程间或不同进程中各个线程之间的同步而设置的。

相对于私用信号量，公用信号量是一种较为安全的同步机制。

三、线程同步的实现方式
1、内核支持线程
无论是用户进程还是系统进程，它们的创建、撤销、切换，都是在操作系统内核的支持下运行的，与内核紧密相关的。
主要缺点是：对于用户线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态进行。

2、用户级线程
仅存在于用户空间中，对于这种线程的创建、撤销、线程间的同步与通信等功能，都无需利用操作系统调用来实现。


第三章 处理机调度和死锁
3.1处理机调度层次
一、高级调度(high level scheduling)
又称为作业调度和长程调度，其主要功能是根据某种算法将外存上处于后备队列中的那些作业调入内存。
它的操作对象是作业(job)。
1、作业
概念比程序更为广泛，不仅包含通常的程序和数据，而且还应配有一份作业说明书，系统根据该说明书控制程序运行。

2、作业步
在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果，每一个加工步骤称为一个作业步。

3、作业流
若干个作业进入系统后，被依次放在外存上，这便形成了输入的作业流。

4、进程调度方式：
<1>非抢占方式：
一旦将处理器分配给某个进程后，不管它要运行多长时间，都让它一直运行下去，决不会因为时钟中断等原因而抢占正在运行进程的处理机，
也不允许其他进程抢占已经分配给它的处理机。直到该进程完成，自愿释放处理机，或发生某事件而被阻塞。

这种调度优点是实现简单，系统开销小，适合于大多数的批处理系统环境。
但它难以满足紧急任务的要求--立即执行。显然不适合实时系统。

<2>抢占方式
允许调度程序根据某种原则去暂停某个正在执行的进程。
1)优先权原则
2)短作业(进程)优先原则
3)时间片原则

第四章 存储器管理
存储器管理的主要对象是内存，外存用于存放文件。

4.1 存储器的层次结构
一、多级存储器结构
CPU寄存器：寄存器
主存：高速缓存、主存储器、磁盘缓存 
辅存：固定磁盘、可移动存储介质

其中，寄存器、高速缓存、主存储器、磁盘缓存 属于操作系统存储管理的范畴，掉电后存储信息丢失。
      固定磁盘、可移动存储介质属于设备管理的范畴，它们的存储信息将被长期保存。
	  
寄存器和主存储器又被称为可执行存储器，存放于其中的信息与存放于辅存的信息相比而言，计算机所采用的访问机制是不同的，
所消耗的时间也是不同的。进程可以在很少的时钟周期内使用一条load或store指令对可执行存储器进访问；
但对辅存的访问则需要通过I/O设备来实现。
   
二、主存储器与寄存器
1、主存储器(简称内存或主存)
<1>CPU的控制部件只能从主存储器中取得指令和数据，数据能够从主存储器读取并将它们装入到寄存器中，或从寄存器存入到主存储器中。
<2>CPU与外围设备交换的信息一般也依托于主存储器地址空间。
<3>主存储器的访问速度远低于CPU执行指令的速度，为缓和这一矛盾，引入寄存器和高速缓存。

2、寄存器
<1>寄存器访问速度很快，完全能与CPU协调工作，但价格十分昂贵。
<2>寄存器用于加上存储器的访问速度，如用寄存器存放操作数等。

三、高速缓存和磁盘缓存
1、高速缓存
<1>容量大于或远大于寄存器；比内存小两到三个数量级。
<2>访问速度快于内存。
<3>根据程序执行的局部性原理，将主存中一些经常访问的信息放在高速缓存中，减少访问主存的次数。
<4>由于高速缓存的速度越高价格也越昂贵，因此有时会设置两级或多级高缓存。

2、磁盘缓存
<1>将频繁使用的一部分磁盘数据和信息暂时存放在磁盘缓存中，可减少访问磁盘的次数。
<2>磁盘缓存本身不是一种实际存在的存储介质，它依托于固定磁盘，提供对主存储器存储空间的扩充。

4.2 程序段装入和链接
在多道程序环境下，要使程序运行，必须先为之创建进程。而创建进程的第一件事，便是将程序和数据装入内存。
将用户源程序变为一个可在内存中执行的程序，通常要经过：编译、链接、装入

一、程序的装入
1、绝对装入方式
绝对装入方式只能将目标模块装入到内存中事先制定的位置，只适用于单道程序环境。
编译时，如果知道程序将驻留在内存的什么位置，那么编译程序将产生绝对地址的目标代码。
程序中使用的绝对地址，既可在编译或汇编时给出，也可由程序员直接赋予。

2、可重定位装入方式
在多道程序环境下，所得到的目标模块的起始地址通常是从0开始的，程序中的其他地址也都是相对于起始地址计算的。
采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。
通常是把装入时对目标程序中指令和数据的修改过程称为重定位(又因为地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位)。

3、动态运行时装入方式
可重定位装入方式不允许程序运行时在内存中移动位置，然而实际情况是，在运行过程中程序在内存中的位置可能经常要改变，此时就应该采用动态运行时装入方式。
动态运行时的转入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种转换推迟到程序真正执行时才进行。
为了不影响指令的执行速度，这种方式需要一个重定位寄存器支持。 

二、程序的链接
1、静态链接
在程序运行前，先将各个目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。

2、装入时动态链接
将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。
即在装入一个目标块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它们装入内存。
<1>便于修改和更新
<2>便于实现对目标模块的共享

3、运行时动态链接
对某些目标模块的链接，是在程序执行中需要模块时，才对它进行的链接。
加快程序的装入过程；节省大量的内存空间。

4.3 连续分配方式
为一个用户程序分配一个连续的内存空间。

一、单一连续分配
最简单的一种存储管理方式，只能用于单用户、单任务的操作系统中。
把内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低地址部分，用户区是除系统区以外的全部内存空间。

二、固定分区分配
最简单的一种可运行多道程序的存储管理方式。                                                                                                                                                   
将内存用户空间划分为若干固定大小的区域，在每个分区中只装入一道作业。

三、动态分区分配
根据进程的实际需要，动态地为之分配内存空间。

四、动态重定位分区分配
1、动态重定位的引入
<1>在连续分配方式中，必须把一个系统或用户程序装入一个连续的内存空间。
<2>不能被利用的小分区称为"零头"或"碎片"。
<3>将内存中的所有作业进行移动，使他们全部相邻，这样既可把原来分散的多个小分区拼接成一个大分区。

2、动态重定位的实现
动态运行时装入方式、重定位寄存器

五、对换
1、对换的引入
<1>把内存中暂时不能运行的进程或暂时不用的程序和数据调出到外存上，再把已具备运行条件的进程或进程所需的程序和数据调入内存中。
对换是提高内存利用率的有效措施。
<2>如果对换是以整个进程为单位的，便称为整体对换或进程对换，这种对换被广泛应用在分时系统中。
<3>如果对换是以页或段为单位的，则分别称为页面对换和分段对换，又统称为部分对换。其目的是实现虚拟存储系统。

2、对换空间的管理
<1>在具有对换功能的OS中，通常把外存分为文件区和对换区。前者存放文件，后者存放从内存对换出的进程。
<2>对对换空间管理的主要目标是提高进程换入和换出的速度。为此，采取连续分配方式，较少考虑外存中的碎片问题。

3、进程的换出与换入
<1>进程的换出。
每当一个进程由于创建子进程而需要更多内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出。

<2>进程的换入

4.4 基本分页存储管理方式
连续分配方式会形成许多"碎片"；
如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是段，则称为分段存储管理方式。

在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，或纯分页存储管理方式，它不具有支持实现虚拟存储器的功能，要求把每个作业都装入内存后方能运行。

一、页面与页表
1、页面
<1>将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始。
<2>将内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框，从0开始编号。
<3>在给进程分配内存时，以块为单位将进程中的若干页分别装入到多个可以不相邻的物理块中。
<4>进程的最后一页经常装不满一块而形成了不可利用的碎片，称为页内碎片。
<5>分页系统中，页面大小应适中，应是2的幂，通常为512B~8KB。

2、地址结构
页号+位移量

3、页表
系统为每个进程建立了一张页面映像表，简称页表。实现从页号到物理块号的地址映射。

4.5 基本分段存储管理方式
引入分段存储管理方式的目的是为了满足程序员在编程和使用上多方面的要求。这种存储方式已经成为当今所有存储管理方式的基础。

一、分段存储管理方式的引入
<1>方便编程
通常用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。

<2>信息共享
在实现对程序和数据的共享时，是以信息的逻辑单元位基础的。
分页系统中页只是存放信息的物理单位，并无完整意义，不便于实现共享。

<3>信息保护
信息保护同样是对信息的逻辑单元进行保护。

<4>动态增长
实际应用时，有些段在使用过程中会不断地增长，而事先又无法确切知道数据段会增长的多长。

<5>动态链接
动态链接要在运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段调入内存并进行链接。
可见，动态链接也要求以段为管理单位。


4.6 虚拟存储器的基本概念
一、虚拟存储器的引入
1、常规存储器管理方式的特征
<1>一次性
需要将作业全部装入内存后方能运行。

<2>驻留性
作业装入内存后，便一直驻留在内存中，直到作业运行结束。

2、局部性原理
程序在执行时将呈现出局部性规律，即在一个较短的时间内，程序的执行仅局限在某个部分，相应的，它所访问的存储空间也局限于某个区域。
<1>时间局限性
如果程序中的某条指令一旦执行，则不仅以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。

<2>空间局限性
一旦程序程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。

3、虚拟存储器的定义
<1>基于局部性原理，应用程序在运行之前，没有必要全部装入内存，仅需将那些当前要运行的少数页面或段先装入内存便可运行。
<2>如果内存已满，无法装入新的页(段)，则还需在利用页(段)的置换功能，将内存中暂时不用的页(段)调至磁盘上。
<3>所谓虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和决定。
<4>虚拟存储器运行速度接近于内存速度。

二、虚拟存储器的实现方法
虚拟存储器的实现，都毫无例外地建立在离散分配的存储管理方式基础上。
//估计也是使用外存中的swap区域，只不过在swap中也是使用离散分配的方式保存页(段)的。(xiao)

1、请求分页系统
系统需要提供的硬件支持和相应的软件：

2、请求分段系统
系统需要提供的硬件支持和相应的软件：

第五章 设备管理
5.1 I/O系统
I/O系统是用于实现数据输入、输出及数据存储的系统。在I/O系统中，除了需要直接用于I/O和存储信息的设备外，还需要有相应的设备控制器和高速总线。
在有的大、中型计算机系统中，还配置了I/O通道和I/O处理机。

一、I/O设备
1、I/O设备的类型
<1>按设备的使用特性分类
存储设备(也称为外存、后备存储器、辅助存储器)
输入/输出设备

<2>按传输速率分类
低速设备，每秒几字节至数百字节     键盘、数百、语音输入/输出设备
中速设备，每秒数千字节至数十万字节    行式打印机、激光打印机
高速设备，每秒数百个千字节到千兆字节    磁带机、磁盘机、光盘机

<3>按信息交换的单位分类
块设备，用于存储信息。它属于有结构设备。   磁盘
字符设备，用于数据的输入和输出，其基本单位是字符。它属于无结构类。

<4>按设备的共享属性分类
独占设备:在一段时间内只允许一个用户(进程)访问的设备，即临界资源。独占设备的分配有可能引起进程死锁。

共享设备:在一段时间内允许多个进程同时访问的设备。当然，对每一个时刻而言，该设备仍然只允许一个进程访问。 
		 共享设备必须是可寻址的和可随机访问的设备。 磁盘
		 共享设备不仅可获得良好的设备利用率，而且它也是实现文件系统和数据库系统的物质基础。

虚拟设备:通过虚拟技术将一台独占设备变换为若干台逻辑设备，共若干个用户(进程)同时使用。

2、设备与控制器之间的接口
通常设备并不是直接和CPU进行通信，而是与设备控制器通信。
<1>数据信号线
用于在设备和设备控制器之间传送数据信号。
数据->转换器->缓冲器->设备控制器
设备控制器->缓冲器->转换器->数据

<2>控制信号线
由设备控制器向I/O设备发送控制信号时的通路。信号规定了设备将要执行的操作(读、写、磁头移动等)。
读：由设备向设备控制器传送数据
写：从设备控制器接收数据

<3>状态信号线
传送指示设备当前状态的信号。状态有正在读(写)；已读(写)完成，并准备好新的数据传送。

二、设备控制器
设备控制器是计算机中的一个实体，其主要职责是控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换。
它是CPU与I/O设备之间的接口。
它是一个可编制的设备，当控制多个设备时，应含有多个设备地址。

设备控制器的复杂性因不同设备而异，且相差很大。分为两类，一是用于控制字符设备的控制器；二是控制块设备的控制器。
//说明计算机中有多个设备控制器

1、设备控制器的基本功能
<1>接收和识别CPU命令    Read、Write、Format等
控制寄存器

<2>数据交换
数据寄存器
CPU与控制器之间：通过数据总线，由CPU并行地把数据写入控制器或从控制器并行地读出数据
控制器与设备之间的数据交换：设备将数据输入到控制器或从控制器传送给设备

<3>标识和报告设备的状态
状态寄存器
控制器应记下设备的状态供CPU了解。当设备处于发送就绪状态时，CPU才能启动控制器从设备中读数据。

<4>地址标识
地址译码器
系统中的每一个设备都有一个地址，设备控制器必须能够识别它所控制的设备地址。

<5>数据缓冲

<6>差错控制
设备控制器负责对I/O设备传送过来的数据进行差错检测。若发现传送中出现了错误，通常是将差错检测码置位，并向CPU报告。
CPU将本次传送来的数据作废，并重传一次。

2、设备控制器的组成
<1>设备控制器与处理机的接口
实现CPU与设备控制器之间的通信。共有三类信号线：数据线、地址线、控制线
数据线与数据寄存器、控制/状态寄存器 相连接。

<2>设备控制器与设备的接口
一个接口连接一台设备。每个接口中都存在数据、控制、状态三种类型的信号。

<3>I/O逻辑
I/O逻辑实现对设备的控制。它通过一组控制线与处理机交互。

三、I/O通道
1、I/O通道设备的引入
<1>虽然在CPU与I/O设备之间增加了设备控制器，已能大大减少CPU对I/O的干预，但当主机所配置的外设很多时，CPU负担仍然很重。
为此，在CPU与设备控制器之间又增加了通道。

<2>其目的是为了建立独立的I/O操作，不仅数据的传送能独立于CPU，而且也希望有关对I/O操作的组织、管理及其结束处理尽量独立，以保证CPU有更多的时间去进行数据处理。

<3>在设置了通道后，CPU只需向通道发送一条I/O指令。通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道程序完成了规定的I/O任务后，才向CPU发中断信号。

<4>I/O通道是一种特殊的处理机。其指令类型单一；其没有自己的内存，与CPU共享内存。

2、通道类型

四、总线系统
计算机系统的各部件，如CPU、存储器以及各种I/O设备(控制器)之间的联系都是通过总线来实现的。
总线的性能使用总线的时钟频率、带宽和相应的总线传输速率等指标来衡量的。

5.2 I/O控制方式
在I/O控制方式的整个发展过程中，始终贯穿着这样一条宗旨：即尽量减少主机对I/O控制的干预，把主机从繁杂的I/O控制事务中解脱出来，以便更多地去完成数据处理任务。

一、程序I/O方式
早期计算机系统中，无中断机构，处理机对I/O设备的控制采用程序I/O方式，或称为忙--等待方式。即在处理机向控制器发出一条I/O指令起送输入设备输入程序时，
要同时把状态寄存器中的忙/闲标志busy置为1，然后不断地循环测试busy。
当busy等于1时，表示输入机尚未输完一个字(符)，处理机应继续对该标志进行测试，直到busy等于0，表明输入机已将输入数据送入控制器中的数据寄存器中。
于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一个字(符)的I/O。

由于CPU的高速和I/O设备的低速，致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中。

二、中断驱动I/O控制方式
当进程要启动某个I/O设备工作时，便由CPU向相应的设备控制器发出一条I/O命令，然后立即返回继续执行原来的任务。
设备控制器于是按照该命令的要求去控制指定I/O设备。此时CPU与I/O设备并行操作。
一旦数据进入数据寄存器，控制器便通过控制线向CPU发送一中断信号，由CPU检查输入过程中是否出错，
若无错，便向控制器发送取走数据的信号，然后再通过控制器及数据线将数据写入内存指定的单元。

三、直接存储器访问(DMA)I/O控制方式
1、DMA控制方式的引入
虽然中断驱动I/O比程序I/O更高效，但它仍是以字(节)为单位进行I/O的，每当完成一个字(节)的I/O时，控制器便向CPU请求一次中断。
为了进一步减少CPU对I/O的干预引入了直接存储器访问方式。
<1>传输数据的基本单位是数据块
<2>所传送的数据是从设备直接送入内存，或者相反
<3>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，整个数据块的传送是在控制器的控制下完成的。

四、I/O通道控制方式
1、I/O通道控制方式的引入
虽然DMA方式比起中断方式已经显著减少了CPU的干预，即已经由字(节)为单位的干预减少到以数据块为单位的干预。
但CPU每发出一条I/O指令，也只能去读(写)一个连续的数据块。
而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区域，或者相反时，则必须由CPU分别发出多条I/O指令及进行多次中断处理才能完成。

I/O通道方式即把对一个数据块的读(写)为单位的干预减少为对一组数据块的读(写)及有关控制和管理为单位的干预。
I/O通道方式可实现CPU、通道和I/O设备三者的并行操作。
当CPU要完成一组相关读(写)操作及有关控制时，只需向I/O通道发一条指令，以给出其所要执行的通道程序的首地址和要访问的I/O设备，
通道接到该指令后，通过执行通道程序便可完成CPU指定的I/O任务。

5.3 缓冲管理
为了缓和CPU与I/O设备速度不匹配的矛盾，提高CPU和I/O设备的并行性，几乎所有的I/O设备在与处理机交换数据时都用了缓冲区。
缓冲管理的主要职责就是组织好这些缓冲区，并提供获得和释放缓冲区的手段。

一、缓冲的引入
1、缓和CPU与I/O设备间速度不匹配的矛盾。
2、减少对CPU的中断频率，放宽对CPU中断响应时间的限制。
3、提高CPU和I/O设备之间的并行性。

二、单缓冲和双缓冲
1、单缓冲
<1>每当用户进程发出一I/O请求时，操作系统便会在主存中为它分配一缓冲区。
<2>在字符设备输入时，缓冲区用于暂存用户输入的第一行数据，输入期间用户进程被挂起等待数据输入完毕；
   在输出时，用户进程将一行数据输入到缓冲区后，继续进行处理。
             当用户进程已有第二行数据输出时，如果第一行数据尚未被提取完毕，则此时用户进程应阻塞。

2、双缓冲
为了加速输入和输出的速度，提高设备利用率，人们又引入了双缓冲区机制，也称为缓冲对换。

三、循环缓冲
当输入与输出的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作。
可将多个缓冲组成循环缓冲形式。

1、循环缓冲的组成
<1>多个缓冲区
用于装输入数据的空缓冲区R
已装满数据的缓冲区G
计算进程正在使用的现行工作缓冲区C。

<2>多个指针
指示计算进程下一个可用缓冲区G的指针 nextg
指示输入进程下次可用的空缓冲去R的指针 nexti
指示计算进程正在使用的缓冲区指针 current

2、循环缓冲区的使用

3、进程同步
使用输入循环缓冲，可使输入进程和计算进程并行执行。相应的，指针nexti和nextg将不断沿着顺时针方向移动：
<1>nexti追赶上nextg：说明输入进程的输入速度大于计算进程处理数据的速度，已经把全部可用的缓冲区装满。
     此时输入进程应阻塞。这种情况称为系统受计算限制。
	 
<2>nextg追赶上nexti：说明输入数据的速度低于计算进程处理数据的速度，使全部装输入数据的缓冲区被抽空。
	 此时计算进程应阻塞。这种情况称为系统受I/O限制。
	 
四、缓冲池
缓冲区仅适用于某特定的I/O进程和计算进程，因而属于专用缓冲。
目前广泛流行公用缓冲池(Buffer Pool)，在池中设置了过个可供若干进程共享的缓冲区。

1、缓冲池的组成
既可用于输入又可用于输出的公用缓冲池。
<1>空闲缓冲区   队列
<2>装满输入数据的缓冲区   队列
<3>装满输出数据的缓冲区   队列

5.4 I/O软件

5.6 磁盘存储器的管理
三、磁盘高速缓存(disk cache)
1、磁盘高速缓存的形式
<1>磁盘高速缓存，并非通常意义下的内存和CPU之间所增设的一个小容量高速存储器，而是利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。
<2>它在逻辑上属于磁盘，而在物理上是驻留在内存中的盘块。
<3>磁盘高速缓存在内存中可以分为两种形式：一是在内存中开辟一个单独的存储空间来作为磁盘高速缓存，其大小固定，不会受应用程序多少的影响；
	二是把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O时共享，此时高速缓存大小不固定。
	
2、数据交付方式
是指将磁盘高速缓存中的数据传送给请求者进程。
<1>数据交付
<2>指针交付

3、置换算法
<1>如同请求调页(段)一样，将磁盘中的盘块数据读入高速缓存时，同样会出现因高速缓存中已装满盘块数据而需要将该数据先换出的问题。
<2>常见的置换算法：最近最久未使用算法LRU、最近未使用算法NRU、最少使用算法LFU

4、周期性地写回磁盘

/****************************************************************************/
内存、ROM、RAM
1、ROM和RAM都是内存；
2、RAM是买电脑时看到的那个内存，电脑运行一些程序，系统时都会装入这个内存； 
   ROM是固定的内存，只是电脑启动时会读取用来帮助启动那些硬件啥滴。。。电脑进入系统后用的就是RAM和硬盘了，硬盘是外存。
3、内存在电脑中起着举足轻重的作用。内存一般采用半导体存储单元，包括随机存储器（RAM），只读存储器（ROM），以及高速缓存（CACHE）。
/****************************************************************************/

第六章 文件管理
6.1 文件和文件系统
文件系统的管理功能，是通过把它所管理的程序和数据组织成一系列文件的方法来实现的。
文件是指具有文件名的若干相关元素的集合。
元素通常是记录。
记录是一组有意义的数据项的集合。

文件系统的概念，将数据组成分为数据项、记录、文件三级。

一、文件、记录和数据项
1、数据项
在文件系统中，数据项时最低级的数据组织形式，可分为两种类型：
<1>基本数据项
用于描述一个对象的某种属性的字符集，是数据组织中可以命名的最小逻辑单元，即原子数据，又称为数据元素或字段。
eg：描述一个学生的基本数据项有 学号、姓名、年龄、班级等

<2>组合数据项
由若干基本数据项组成的，简称组项。
eg：经理便是一个组项。

基本数据项除了数据外，还应有数据类型。

2、记录
<1>记录是一组数据项的集合，用于描述一个对象在某方面的属性。
   一个记录应包含哪些数据项，取决于需要描述对象的哪个方面。而一个对象，由于它所处的环境不同可把他作为不同的对象。

<2>在诸多记录中，为了能唯一标识一个记录，需要在各个数据项中确定一个或几个数据项，把他们的集合称为关键字(key)。

3、文件
<1>文件是指由创建者所定义的、具有文件名的一组相关元素的集合。分为有结构文件和无结构文件两种。
<2>有结构文件中，文件由若干相关记录组成；无结构文件则被看成是一个数据流。
<3>文件在文件系统中是一个最大的数据单元，它描述了一个对象集。例如可将一个班的学生记录作为一个文件。

二、文件类型和文件系统模型
1、文件类型
为了便于管理和控制文件，将文件分为若干种类型。

2、文件系统模型
用户(程序)->文件系统接口->对象操作和管理的软件集合->对象及其属性

<1>对象及其属性
文件系统管理的对象有：
1)文件：文件管理的直接对象
2)目录：为了方便用户对文件的存取和检索，在文件系统中必须配置目录，每个目录项中，必须包含文件名及该文件所在的物理地址(或指针)。
3)磁盘(磁带)存储空间：文件和目录必定占用存储空间。

<2>对对象操作和管理的软件集合
这是文件系统的核心部分，文件系统的功能大多在这层实现。包括：
 对文件存储空间的管理
 对文件目录的管理
 用于将文件的逻辑地址转换为物理地址的机制
 对文件读写的管理等
 
<3>文件系统的接口
1)命令接口：用户与文件系统交互的接口
2)程序接口：用户程序与文件系统的接口。用户程序可通过系统调用来取得文件系统的服务。

三、文件操作
用户通过文件系统所提供的系统调用实施对文件的操作。
1、最基本的文件操作
<1>创建文件：先为文件分配必要的外存空间，并在文件系统目录中创建一个目录项。
<2>删除文件：先删除文件的目录项，再回收该文件所占用的存储空间。
<3>读文件：在系统调用中给出文件名和应读入的内存目标地址。
<4>写文件：在系统调用中给出文件名及该文件在内存中的(源)地址。
<5>截断文件：如果一个文件的内容已经陈旧而需要全部更新时，如果文件名及其属性均无改变时，
		可采取截断的文件的方法，即将原有文件的长度设置为0，或者说放弃原有文件的内容。
<6>设置文件的读写位置

2、文件的打开和关闭操作
	所谓"打开"，是指系统将文件的属性(包括该文件在外存上的物理位置)从外存拷贝到内存打开文件表的一个表目中，
并将该表目的编号(或称为索引)返回给用户。以后，当用户再要求对该文件进行相应操作时，便可利用系统所返回的索引号向系统提出
操作请求。系统便可直接利用该索引号到打开文件表中去查找，从而避免了对该文件的再次检索。
	如果用户已经不再需要对该文件实施相应的操作时，可利用"关闭"系统调用来关闭此文件，OS将会把该文件从打开文件表中删除。
	
3、其他文件操作


6.2 文件的逻辑结构
对于任何一个文件都存在以下两种形式的结构：
<1>文件的逻辑结构
从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于文件的物理特征，又称为文件组织。

<2>文件的物理结构
又称为文件的存储结构，是指文件在外存上的存储组织形式。

无论是文件的逻辑结构还是物理结构，都会影响对文件的检索速度。

一、文件逻辑结构的类型
文件的逻辑结构可分为两大类：一类是有结构文件，是指由一个以上的记录构成的文件，又称为记录式文件；
							其二是无结构文件，是指由字符流构成的文件，故又称为流式文件。

1、有结构文件
在记录式文件中，每个记录都用于描述实体集中的一个实体，各个记录有着相同或不同数目的数据项。记录的长度可分为定长和不定长两类。
<1>顺序文件
这是由一系列的记录按照某种顺序排列所形成的文件。其中的记录通常是定长记录，因而能用较快的速度查找文件中的记录。
(顺序文件中的记录可以是定长的，也可以是变长的。)

<2>索引文件
当记录为可变长度时，通常为之建立一张索引表，并为每个记录设置一个表项，以加快对记录检索的速度。

<3>索引顺序文件
为每一组记录中的第一个记录设置一个表项。

2、无结构文件
如果说大量的数据结构和数据库是采用有结构的文件形式的话；大量的源程序、可执行文件、库函数等，所采用的就是无结构的文件形式，即流式文件。其长度以字节为单位。
在UNIX系统中，所有的文件都被看作是流式文件，即使有结构文件。系统不对文件进行格式处理。

二、顺序文件
1、逻辑记录的顺序
<1>串结构：各记录间的顺序与关键字无关，通常的方法是由时间来决定。
<2>顺序结构：文件中所有的记录按关键字(词)排列。
对顺序结构文件有更高的检索效率。

2、对顺序文件(Sequential File)的读/写操作

3、顺序文件的优缺点
顺序文件的最佳应用场合是在对诸记录进行批量存取时，即每次要读或写一大批记录时。
此时，顺序文件的读取效率是所有逻辑文件中最高的。
此外，也只有顺序文件才能存储在磁带上。

查找/修改/增加/删除 记录困难。

三、索引文件
为变长记录文件建立一张索引表，对主文件中的每个记录，在索引表中设有一个相应的表项，用于记录该记录的长度L及指向该记录的指针。
(指向该记录在逻辑地址空间的首地址。)
索引表按记录键排序的，因此，索引表本身是一个定长记录的顺序文件。

每次要向索引文件中增加一个新纪录时，必须对索引表进行修改。

四、索引顺序文件
<1>是最常见的一种逻辑文件形式。有效克服了边长记录文件不便于直接存取的缺点，而且付出的代价也不算太大。
<2>将顺序文件中的所有记录分为若干组；
   为顺序文件建立一张索引表，在表中为每组中的第一个记录建立一个索引项，其中含有该记录的键值和指向该记录的指针。
<3>多级索引。

五、直接文件和哈希文件
1、直接文件
<1>可根据给定的记录键值，直接获取指定记录的物理地址。换言之，记录键值本身就决定了记录的物理地址。
<2>记录键值到记录物理地址的转换：键值转换。

2、哈希文件
<1>目前应用最广泛的一种直接文件。利用hash函数(散列函数)，将记录键值转换为相应记录的地址。
<2>通常由Hash函数所求得的并非是相应记录的地址，而是指向一目录表相应表目的指针，该表明的内容指向相应记录所在的物理块。

6.3 外存分配
一、连续分配

二、链接分配

6.7 数据一致性控制

易失性存储器(内存)

只要将数据分别存储到多个文件中时，便可能是数据一致性出现问题。

一、事务
1、事务的定义
<1>事务是用于访问和修改各种数据项的一个程序单元。
  事务是一系列相关读和写操作。
<2>只有分布在不同位置的统一数据所进行的读写(含修改)操作全部完成时，才能再以托付操作来终止事务。
   只要有一个读写或修改操作失败，便执行夭折操作。
<3>一个夭折的事务，通常已经执行了一些操作，因而可能已对某些数据做了修改。为了避免引起数据的不一致性，必须将该事务内
   刚被修改的数据项恢复成原来的情况。“事务回退(rolled back)”
<4>一个事务在对一批数据执行修改操作时，要么全部完成，并用修改后的数据去替代原来的数据；要么一个也不修改。“原子性”操作

2、事务记录(Transaction Record)
记录在事务运行时数据项修改的全部信息，又称为运行记录，存放在稳定存储器中。

事务名
数据项名
旧值
新值

3、恢复算法
undo<Ti> //把所有被事务Ti修改过的数据恢复为修改前的值
redo<Ti> //把所有被事务Ti修改过的数据设置为新值

二、检查点
1、检查点的作用
目的是对事务记录表中事务记录的清理工作经常化。

三、并发控制
1、利用互斥锁实现“顺序性”

2、利用互斥锁和共享锁实现顺序性
互斥锁:只允许一个事务去读或写。
共享锁:允许多个事务对相应的对象执行读操作，不允许其中任何一个事务对对象执行写操作。

四、重复数据的数据一致性问题
1、重复文件的一致性

2、盘块号一致性的检查

3、链路数一致性检查

























