4.11 类型转换
1. 如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代。
换句话说，如果两种类型可以相互转换，它们就是关联的。

eg: int val = 3.5 + 3;   //编译器可能会警告损失了精度
C++不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后在求值。称为隐式转换。
- 算术类型之间的隐式转换被设计为尽可能避免精度损失。如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型。
- 3转换成double，然后执行浮点数加法，所得结果的类型是double。
- 执行初始化。double类型的结果转换成int类型的值，该值被用来初始化ival。

2. 何时发生隐式类型转换
- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。(6.6.1)

4.11.1 算术转换
算术转换的含义是把一种算术类型转换成另一种算术类型。
算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。

eg：表达式中既有浮点类型也有整型时，整数值将转换成相应的浮点类型。

1. 整型提升
<1>整型提升负责把小整数类型转换成较大的整数类型。

<2>对于bool、char、singed char、unsigned char、short、unsigned short等类型来说，只要它们所有可能的值都能存在int中，它们就会提升为int类型；
否则，提升为unsigned int类型。

<3>较大的char类型(wchar_t、char16_t、char32_t)提升为int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种类型。
前提是转换后的类型要能容纳原类型所有可能的值。

2. 无符号类型的运算对象
如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。但是如果某个运算对象是无符号的，那么转换结果就要依赖于机器中各个整数类型的相对大小了。

step1: 像往常一样，首先执行整型提升。如果结果的类型匹配，无需进一步转换。
如果(提升后)运算对象的类型都是有符号的或无符号的，则小类型的运算对象转换成较大的类型。

step2: 如果一个运算对象是无符号类型的、另一个运算对象时有符号类型的，而且无符号类型不小于有符号类型，那么有符号运算对象转换成无符号的。
eg: int和unsigned int，则int类型的运算对象转换为unsigned int类型。
//如果int类型的值恰好为负数，结果将以2.1.2介绍的方法转换，并带来该节描述的所有副作用。

step3：剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。
如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。
eg: long和unsigned int，并且long和unsigned int的大小相同，long类型的运算对象转换成unsigned int类型。
	如果long类型占用的空间比unsigned int更多，则unsigned int类型的运算对象转换成long类型。

4.11.2 其他隐式类型转换
1. 数组转换为指针
<1>大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。
eg:
int ia[10];
int *ip = ia;	//ia转换成指向数组首元素的指针
注：当数组被用作decltype关键字的参数；用作取地址符&、sizeof、typeid等运算符的运算对象时，上述转换不会发生。
	如果用一个引用来初始化数组，上述转换也不会发生。???

2. 指针的转换
- 常量整数值0或字面值nullptr能转换成任意指针类型；
- 指向任意非常量的指针能转换成void *；
- 指向任意对象的指针能转换成const void*。

3. 转换成布尔类型
存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果是false；否则转换结果为true。
eg:
char *cp = get_string();
if (cp) /* */			//如果指针cp不是0，条件为真
while (*cp) /* */		//如果*cp不是空字符，条件为真

4. 转换成常量
允许将指向非常量类型的指针转换成指向相应的常量类型的指针；对于引用也是这样。
注：相反的转换并不存在，因为它试图删掉底层const。

5. 类类型定义的转换
类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝。
//详见7.5.4

4.11.3 显式转换
1. 命名的强制类型转换
<1>一个命名的强制类型转换具有如下形式： cast-name<type>(expression);
其中，type是转换的目标类型，expression是要转换的值。
	cast-name是static_cast\dynamic_cast\const_cast\reinterpret_cast中的一种。

<2>dynamic_cast支持运行时识别，将在19.2介绍。

<3>static_cast
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

eg:
- 把较大的算术类型赋值给较小的类型：
//一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息；当执行了显式类型转换之后，警告信息就会消失(关闭)。

- 执行编译器无法自动执行的类型转换。使用static_cast找回存在于void*指针中的值。
void *p = &d; //任何非常量对象的地址都能存入void *
double *dp = static_cast<double*>(p);	//将void *转换回初始的指针类型
注：必须确保转换后所得的类型就是指针所指向的类型。类型一旦不符，将会产生未定义的后果。

<3>const_cast
const_cast只能改变运算对象的底层const。
对于将常量对象转换成非常量对象的行为，一般称为"去掉const性质"。一旦去掉了某个对象的const性质，编译器就不再阻止对该对象进行写操作了。
const_cast常常用于有函数重载的上下文中，关于函数重载将在6.4介绍。

eg：
const char *pc;
char *p = pc;					 //错误：从类型const char*到类型char*的转换无效 [-fpermissive]
char *p = const_cast<char*>(pc); //正确：但是通过p写值是未定义的行为。

<4>reinterpret_cast
为运算对象的位模式提供较低层次上的重新解释。
reinterpret_cast本质上依赖与机器。使用reinterpret_cast是非常危险的。

eg：
int *ip;
char *pc = reinterpret_cast<char*>(ip);		//必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。

2. 建议避免强制类型转换

3. 旧式的强制类型转换
<1>早期版本的C++中，显式地进行强制类型转换包含两种形式：
type(expr);				//函数形式的强制类型转换
(type)expr;				//C语言风格的强制类型转换

<2>使用旧式的强制类型转换时，如果换成const_cast和static_cast也合法，则其行为与对应的命名转换一致；
如果替换后不合法，则其行为与reinterpret_cast类似。
eg：
int a = 10;
char *p = (char *)&a;

const char *b = "123";
char *c = (char *)b;


6.6.1、7.5.4、6.4