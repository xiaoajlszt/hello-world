15.1 OOP概述
面向对象程序设计的核心思想是数据抽象、继承和动态绑定。
- 通过使用数据抽象，可以将类的接口与实现分离；
- 通过使用继承，可以定义相似的类型并对其相似关系建模；
- 通过使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。//动态绑定也称为运行时绑定

1. 继承
基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

2. 动态绑定
当使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。	//需要派生类是公有派生类型

15.2 定义基类和派生类
15.2.1 定义基类
作为继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不执行任何实际操作。

1. 成员函数与继承
<1>基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。
对于前者，基类通常将其定义为虚函数。

<2>任何构造函数之外的非静态函数都可以是虚函数。
//关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。

<3>如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。

<4>成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。

2. 访问控制与集成
<1>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。
- 同其他用户访问一样，派生类能访问公有成员，而不能访问私有成员。
- protected：派生类有权访问该成员，同时禁止其他用户访问。

15.2.2 定义派生类
1. 派生类必须通过使用类派生列表明确指出它是从哪些基类继承而来的。
//首先是冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符(public、protected、private)。

2. 访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。
<1>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。
<2>能将公有派生类型的对象绑定到基类的引用或指针上。

3. 派生类中的虚函数
<1>派生类经常(但不总是)覆盖它继承的虚函数。
如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通函数，派生类会直接继承其在基类中的版本。

<2>派生类可以在这样的函数之前加上virtual关键字，但并不是非得这么做。

<2>C++新标准允许派生类显示地注明它将使用哪个成员函数改写基类的虚函数。
具体措施是在 该函数的形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面 增加override关键字。

4. 派生类对象及派生类向基类的类型转换
<1>一个派生类对象包含多个组成部分：
- 一个含有派生类自己定义的(非静态)成员的子对象；
- 一个与基类对应的子对象；//如果有多个基类，这样的子对象也有多个

//在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

<2>因为派生类对象中含有与基类对应的组成部分，所以能把派生类的对象当成基类对象来使用。
而且能将基类的指针或引用绑定到派生类对象中的基类部分上。

eg:
Quote item;			//基类对象
Bulk_quote bulk;	//派生类对象
Quote *p = &item;	//p指向Quote对象
p = &bulk;			//p指向bulk的Quote部分
Quote &r = bulk;	//r绑定到bulk的Quote部分

这种转换通常称为派生类到积累的类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换。

5. 派生类构造函数
<1>每个类控制它自己的成员初始化过程
尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。

<2>派生类构造函数是通过构造函数初始化列表将实参传递给基类构造函数的。
eg:
Bulk_quote(/**/):Quote(bookNo,price),min_qty(qty),dicount(disc){}
//Quote的构造函数负责初始化Bulk_quote对象的基类部分。当Quote构造函数的函数体结束后，对象的基类部分也就完成了初始化，接下来初始化由派生类直接定义的成员。
最后运行Bulk_quote构造函数的函数体。

//除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。
如果，想用其他的基类构造函数，需要以类名加圆括号内的实参列表的形式Quote(bookNo,price)为构造函数提供初始值。
这些实参将帮助编译器决定到底应该用哪个构造函数类初始化派生类对象的基类部分。

<3>eg:
class A
{
    public:
        A()=default;

        A(int age, string name): age(age), name(name)
        {
            cout << "Enter constructor1" << endl;
        }

    private:
        int age;
        string name;
};


class B: public A
{
    public:
        B()=default;
        B(int height, int age, string name):height(height), A(age, name){ }

    private:
        int height;
};


int main()
{
    B b;	//调用2个默认构造函数
    B b1(160, 10, "Xiao Hong");		//调用2个非默认构造函数
    return 0;
}


6. 派生类使用基类的成员
<1>派生类可以访问基类的公有成员和受保护成员。

<2>遵循基类的接口
尽管从语法上来说可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。
派生类应该遵循基类的接口，通过调用基类的构造函数来初始化那些从基类中继承而来的成员。

7. 继承与静态成员
<1>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论有多少派生类，对于静态成员来说都只存在唯一的实例。

<2>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。
假设某静态成员是可访问的，则既能通过基类使用它也能通过派生类使用它。//也可以通过类对象(引用)、指针使用它。

8. 派生类的声明
<1>声明中包含类名但不包含它的派生列表。

9. 被用作基类的类
<1>如果要将某个类用作基类，则该类必须已经定义而非是仅仅声明。

10. 防止继承的发生
<1>C++11新标准提供了一种防止继承发生的方法，即在类名之后跟一个关键字final。

15.2.3 类型转换与继承
1. 静态类型与动态类型
<1>静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；

<2>动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知。

<3>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。

2. 不存在从基类向派生类的隐式类型转换......
<1>一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。

<2>即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类向派生类的转换：
Bulk_quote bulk;
Quote *itemP = &bulk;		//正确：动态类型是Bulk_quote
Bukl_quote *bulkP = itemP;  //错误：不能将基类转换为派生类

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。
- 如果基类中含有一个或多个虚函数，可以使用dynamic_cast(19.2.1)请求一个类型转换，该转换的安全检查将在运行时执行；
- 如果已经某个基类向派生类的转换是安全的，则可以使用static_cast(4.11.3)来强制覆盖掉编译器的检查工作。

3. ......在对象之间不存在类型转换
<1>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。
//派生类对象转换成基类类型实际转换过程往往与预期有所差别。

15.3 虚函数
1. 对虚函数的调用可能在运行时才被解析
<1>通常情况下，如果不适用某个函数，则无须为该函数提供定义。
但是必须为每一个虚函数都提供定义，而不管它们是否被用到，这是因为连编译器也无法确定到底会使用哪个虚函数。

<2>动态绑定只有当通过指针或引用调用虚函数时才会发生。
当通过一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时就会将调用的版本确定下来。
类似的，对非虚函数的调用也是在编译时进行绑定的。

2. 派生类中的虚函数
<1>一旦某个函数被声明为虚函数，则所有派生类中的它都是虚函数。
派生类中可以再一次使用virtual关键字指出该函数的性质，但不是必须的。

<2>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型和返回值类型必须与被它覆盖的基类函数完全一致。
//例外情况：当类的虚函数返回类型是类本身的指针或引用时，返回值类型可以不一致。

3. final和override说明符
<1>如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同，编译器将认为新定义的函数与基类中的函数是相互独立的。

<2>C++11新标准中可以使用override关键字来说明派生类中的虚函数。
如果使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。

<3>还可以把某个虚函数指定为final，之后任何尝试覆盖该函数的操作都将引发错误。

<4>final和override说明符出现在形参列表(包括const或引用修饰符)以及尾置返回类型(6.3.3)之后。
注意必须是虚函数才能使用这两个说明符。

4. 虚函数与默认实参
<1>如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。
如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本。

<2>因此，如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好保持一致。

eg:
class CA{
    public:
        virtual void eat(int a = 3)
        {
            printf("CA eat,");
            printf("%d,",a);
        }
};

class CB:public CA{
    public:
        int a;

        virtual void eat(int a = 4)
        {
            printf("CB eat,");
            printf("%d,",a);
        }
};

int main()
{
    CA *a = new CB();
    a->eat();

    CB *b = new CB();
    b->eat();

    return 0;
}

//输出：CB eat,3,CB eat,4,

5. 回避虚函数的机制
<1>在某些情况下，希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的。
eg:强制用基类中定义的版本，而不管baseP的动态类型是什么。
double undiscounted = baseP->Quote::net_price(42);		//该调用将在编译时进行绑定。

<2>通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制。
//通常是当一个派生类的虚函数需要调用它覆盖的基类的虚函数版本时。

15.4 抽象基类
1. 纯虚函数
<1>纯虚函数无须定义。
通过在函数体的位置书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。

<2>也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。不能在类内部为一个=0的函数提供函数体。

2. 含有纯虚函数的类是抽象基类
<1>含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类。
不能(直接)创建一个抽象基类的对象，可以定义抽象基类派生类(前提是这些派生类不是抽象基类)的对象。

<2>抽象基类的派生类必须覆盖抽象基类的纯虚函数，否则它们仍是抽象基类。

3. 派生类构造函数只初始化它的直接基类
eg：
父类：Quote					含有两个数据成员bookNo、price
子类：Disc_quote			含有两个数据成员quantity、discount
子类的子类：Bluk_quote		含有零个数据成员

<1>Bluk_quote的直接基类是Disc_quote，间接基类是Quote。
每个Bluk_quote对象包含三个子对象：一个(空的)Bluk_quote部分、一个Disc_quote子对象和一个Quote子对象。

<2>每个类各自控制其对象的初始化过程。	//构造函数的调用次序如下：
即使Bluk_quote没有自己的数据成员，它也仍然需要提供一个接受四个参数的构造函数。
Bulk_quote(const std::string& book, double price, std::size_t qty, double disc):Disc_quote(book, price, qty, disc) { }

该构造函数将它的实参传递给Disc_quote的构造函数，随后Disc_quote的构造函数继续调用Quote的构造函数。
- Quote的构造函数首先初始化bulk的bookNo和price成员；
- 当Quote的构造函数结束后，开始运行Disc_quote的构造函数，初始化bulk的quantity和discount成员；
- 最后运行Bluk_quote的构造函数。

15.5 控制访问与继承
每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问。

0. 派生类能访问基类的public、protected，不能访问private。

1. 受保护的成员
<1>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。
- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。
- 和公有成员类似，受保护的成员对于派生类的成员和派生类的友元来说是可访问的。
//派生类的成员或派生类的友元只能访问派生类对象中的基类部分的受保护成员，派生类对于基类对象中的受保护成员没有任何访问特权!!!

2. 公有、私有和受保护继承
<1>某个类对其继承而来的成员的访问权限受到两个因素的影响：
- 基类中该成员的访问权限；
- 派生类的派生列表中的访问说明符。

<2>派生类访问说明符对于派生类的成员(以及派生类的友元)能够访问其直接基类的成员没什么影响。
对于基类成员的访问限制只和基类中的访问说明符有关。

<3>派生类访问说明符的目的是控制派生类用户(包括派生类的派生类)对基类成员的访问权限。
- 如果是公有继承，则所有成员将遵循其原有的访问说明符；
- 如果是私有继承，则所有成员都为private；
- 如果是保护继承，则所有公有成员都为protected。

3. 派生类向基类转换的可访问性
<1>假设D继承B：
- 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；否则，用户代码不能使用该转换。
- 不论D以什么方式继承B，D的成员函数和D的友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
- 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和D派生类的友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。

<2>类的设计与受保护的成员
- 不考虑继承的话，可以认为类有两种不同的用户：普通用户和类的实现者。
普通用户编写的代码使用类的对象，这部分代码只能访问类的公有成员；
实现者负责编写类的成员和友元代码，成员和友元既能访问类的公有部分，也能访问类的私有部分。

- 如果进一步考虑继承的话就会出现第三种用户，即派生类。
基类应该将其接口成员声明为公有的；
将属于其实现的部分分为两组：一组可供派生类访问，声明为受保护的。
							另一组只能由基类及基类的友元访问，声明为私有的。

4. 友元和继承
<1>就像友元关系不能传递一样，友元关系也同样不能继承。
基类的友元在访问派生类成员时不具有特殊性，派生类的友元访问基类成员同样如此。

<2>eg
class Base
{
protected:
	int prot_mem;	

	friend class Pal;
};

class Sneaky:public Base
{
private:
	int j;
};

class Pal
{
public:
	int f(Base b) {return b.prot_mem;}	//正确
	int f2(Sneaky s) {return s.j;}		//错误，Pal不是Sneaky的友元
	int f3(Sneaky s) {return s.prot_mem;}	//正确，Pal是Base的友元，对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此。
};

5. 改变个别成员的可访问性
<1>有时候需要改变派生类继承的某个名字的访问级别，通过使用using声明。

<2>eg
class Base
{
public:
	std::size_t size() const {return n;}
protected:
	std::size_t n;
};

class Derived : private Base
{
public:
	using Base::size;
protected:
	using Base::n;
};

因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。
通过using声明语句改变了这些成员的可访问性，之后，Derived的用户将可以使用size成员，Derived的派生类将能使用n。

<3>通过在类的内部使用using声明语句，可以将该类的直接或间接基类中的任何可访问成员标记出来。
//派生类只能为那些它可以访问的名字提供using声明!!!

6. 默认的继承保护级别
<1>默认情况下，使用class关键字定义的派生类是私有继承的；使用struct关键字定义的派生类是公有继承的。
class Base {/* */};
struct D1 : Base {/* */};	//默认public继承
class D2 : Base {/* */};	//默认private继承

<2>struct和class关键字的唯一差别就是默认成员访问说明符以及默认派生访问说明符。除此之外，完全一致。


15.6 继承中的类作用域
