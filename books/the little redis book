第一章 基础知识
1. 在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是0。如果你想切换到一个不同的数据库，你可以使用select命令来实现。
在命令行界面里键入select 1，Redis应该会回复一条OK的信息，然后命令行界面里的提示符会变成类似redis 127.0.0.1:6379[1]>这样。
如果你想切换回默认数据库，只要在命令行界面键入select 0即可。

2. 命令、关键字、值
Redis的5种数据结构中的每一种都至少有一个关键字和一个值。
<1> 关键字用来标识数据块，eg：“users:leto”
<2> 值是关联于关键字的实际值。字符串、整数、JSON等。值可以是任何东西，因为Redis从来不需要去读取或理解它们。
<3> 基本命令，eg：set users:leto "{name: leto, planet: dune, likes: [spice]}"
		      eg：get users:leto

3. 存储器和持久化
Redis是一种持久化的存储器内存储（in-memory persistent store）。对于持久化，默认情况下，Redis会根据已变更的关键字数量来进行判断，然后在磁盘里创建数据库的快照（snapshot）。
可以对此进行设置，如果X个关键字已变更，那么每隔Y秒存储数据库一次。默认情况下，如果1000个或更多的关键字已变更，Redis会每隔60秒存储数据库；而如果9个或更少的关键字已变更，Redis会每隔15分钟存储数据库。


第二章 数据结构
一、字符串(Strings)
1. eg
set users:leto "{name: leto, planet: dune, likes: [spice]}"

<1> strlen <key>  //获取一个关键字对应值的长度
<2> getrange <key> <start> <end>  //返回指定范围内的关键字对应值
<3> append <key> <value>  //会将value附加到已存在的关键字对应值中，如果关键字并不存在，则会建一个新的key-value对。

//增长或缩减一个字符串数据结构的值：(值必须是整数，否则会报错)
<4> incr [key]
<5> incrby [key] [increment]
<6> decr [key]
<7> decrby [key] [decrement]

<8> setbit
<9> getbit

2. 由于通过关键字来获取一个值是如此之快，字符串数据结构很常被用来缓存数据。

二、散列(Hashes)
1. 把Redis成为一种key-value型存储是不太准确的，散列数据结构就是一个很好的例证。
散列与字符串数据结构的区别在于：散列提供了一个额外的间接层(域Field)
hset [key] [field] [value]
hget [key] [field]

2. 同一时间设置多个域	hmset [key] [field] [value] [field value ...]
   同一时间获取多个域   hmget [key] [field] [field ...]
   获取所有的域和值     hgetall [key]
   列出所有的域         hkeys [key]
   删除指定的域         hdel [key] [field] [field ...]

3. 散列好处是能够提取、更新和删除具体的数据片段，而不必去获取或写入整个值。

三、列表(Lists)
1. 对于给定的关键字，列表数据结构可以存储和处理一组值。
lpush key value [value ...]
ltrim key start stop
要理解ltrim命令，首先要明白Key所存储的值是一个列表，理论上列表可以存放任意个值。
对于指定的列表，根据所提供的两个范围参数start和stop，ltrim命令会将指定范围外的值都删除掉，只留下范围内的值。

2. eg: 跟踪网站里注册的最新用户
lpush newusers goku		//将一个新用户推到列表的前端
ltrim newusers 0 50		//对列表进行调整，使得该列表只包含50个最近被推入的用户

//ltrim是一个具有O(N)时间复杂度的操作，N是被删除的值的数量。
从上面的例子来看，我们总是在插入了一个用户后再进行列表调整，实际上，其将具有O(1)的时间复杂度（因为N将永远等于1）的常数性能。

四、集合(Sets)
1. 集合数据结构常常用来存储只能唯一存在的值，并提供了许多的基于集合的操作，比如并集。
sadd key member [member ...]
sismember key member
sinter key [key ...]
sinterstore destination key [key ...]

2. eg: 典型用例是朋友名单的实现
<1>
sadd friends:leto ghanima paul chani jessica	//4
sadd friends:duncan paul jessica alia			//3

<2>不管一个用户有多少个朋友，我们都能高效地（O(1)时间复杂度）识别出用户X是不是用户Y的朋友。
sismember friends:leto jessica		//1
sismember friends:leto vladimir		//0

<3>可以查看两个或更多的人是不是有共同的朋友
sinter friends:leto friends:duncan  //1) "paul"  2) "jessica"

<4>可以在一个新的关键字里存储结果
sinterstore friends:leto_duncan friends:leto friends:duncan		//2

3. 有时候需要对值的属性进行标记和跟踪处理，但不能通过简单的复制操作完成，集合数据结构是解决此类问题的最好方法之一。
当然，对于那些需要运用集合操作的地方（例如交集和并集），集合数据结构就是最好的选择。

五、分类集合(Sorted Sets)
1. 最后也是最强大的数据结构是分类集合数据结构。
如果说散列数据结构类似于字符串数据结构，主要区分是域（field）的概念；
那么分类集合数据结构就类似于集合数据结构，主要区分是标记（score）的概念。标记提供了排序（sorting）和秩划分（ranking）的功能。

zadd key [NX|XX] [CH] [INCR] score member [score member ...]
zcount key min max
zrank key member
zrevrank key member

2. eg: 一个秩分类的朋友名单
<1> 
zadd friends:duncan 70 ghanima 95 paul 95 chani 75 jessica 1 vladimir	//5

<2> 标记(socre)为90或更高的人数？
zcount friends:duncan 90 100	//2

<3> 获取chani在名单里的秩(rank)
zrevrank friends:duncan chani	//1
zrevrank friends:duncan paul	//0
zrank friends:duncan chani		//3
zrank friends:duncan paul		//4

//Key存储的Sorted Set默认是根据Score对各个member进行升序的排列，该命令就是用来获取member在该排列里的次序，这就是所谓的秩。

3. 对于分类集合数据结构，最常见的应用案例是用来实现排行榜系统。
事实上，对于一些基于整数排序，且能以标记（score）来进行有效操作的东西，使用分类集合数据结构来处理应该都是不错的选择。

第三章 使用数据结构

//大O、小o等的数学含义
https://www.cnblogs.com/lzsz1212/p/3955218.html

一、大O表示法(Big O Notation)
1. 大O表示法的惯常用途是，描述一些用于处理一定数量元素的行为的综合表现。
在Redis里，对于一个要处理一定数量元素的命令，大O表示法让我们能了解该命令的大概运行速度。
在Redis的文档里，每一个命令的时间复杂度都用大O表示法进行了描述，还能知道各命令的具体性能会受什么因素影响。

<1> 常数时间复杂度O(1)被认为是最快速的，无论我们是在处理5个元素还是5百万个元素，最终都能得到相同的性能。
sismember

<2> 对数时间复杂度O(log(N))被认为是第二快速的，其通过使需扫描的区间不断皱缩来快速完成处理。
对数时间复杂度O(log(N))被认为是第二快速的，其通过使需扫描的区间不断皱缩来快速完成处理。
zadd	//N是在分类集合中的元素数量

<3> 再下来就是线性时间复杂度O(N)，在一个表格的非索引列里进行查找就需要O(N)次操作。
ltrim命令具有O(N)的时间复杂度，但是，在ltrim命令里，N不是列表所拥有的元素数量，而是被删除的元素数量。
//从一个具有百万元素的列表里用ltrim命令删除1个元素，要比从一个具有一千个元素的列表里用ltrim命令删除10个元素来的快速!!!

<4> zremrangebyscore命令会在一个分类集合里进行删除元素操作，其时间复杂度为O(log(N) + M)。
//zremrangebyscore key max mix
//N是指在分类集合中的元素总数量；M是指被删除的元素数量。

<5> sort命令时间复杂度为O(N + M * log(M))

在redis中，当发现一些操作具有O(N)的时间复杂度时，可能可以找到更好的方法去处理。

二、仿多关键字查询(Pseudo Multi Key Queries)
1. 使用散列数据结构，可以摆脱重复的缠绕
<1> 引出
时常，你会想通过不同的关键字去查询相同的值。
例如，你会想通过电子邮件（当用户开始登录时）去获取用户的具体信息，或者通过用户id（在用户登录后）去获取。
有一种很不实效的解决方法，其将用户对象分别放置到两个字符串值里去：
set users:leto@dune.gov "{id: 9001, email: 'leto@dune.gov', ...}"
set users:9001 "{id: 9001, email: 'leto@dune.gov', ...}"
这种方法很糟糕，如此不但会产生两倍数量的内存，而且这将会成为数据管理的恶梦。

<2> 使用域作为一个二级索引，然后去引用单个用户对象。
set users:9001 "{id: 9001, email: leto@dune.gov, ...}"
hset users:lookup:email leto@dune.gov 9001

1) 通过id来获取用户信息：
get users:9001

2) 通过电子邮箱来获取用户信息：//by Ruby
id = redis.hget('users:lookup:email', 'leto@dune.gov')
user = redis.get("users:#{id}")

三. 引用和索引


四. 数据交互和流水线(Round Trips and Pipelining)
<1> 与服务器频繁交互是redis的一种常见模式。

<2> 许多命令能够接受一个或更多的参数；
关联命令(sister-command)可以接受多个参数。

<3> Redis还支持流水线功能。
1) 通常情况下，当一个客户端发送请求到Redis后，在发送下一个请求之前必须等待Redis的答复。使用流水线功能，你可以发送多个请求，而不需要等待Redis响应。
这不但减少了网络开销，还能获得性能上的显著提高。

2) Redis会使用存储器去排列命令，因此批量执行命令是一个好主意。
至于具体要多大的批量，将取决于你要使用什么命令（更明确来说，该参数有多大）。另一方面来看，如果你要执行的命令需要差不多50个字符的关键字，你大概可以对此进行数千或数万的批量操作。

五. 事务(Transactions)
<1>每一个Redis命令都具有原子性，包括那些一次处理多项事情的命令。
此外，对于使用多个命令，Redis支持事务功能。

1) redis实际上是单线程运行的。

2) 虽然redis是单线程运行的，但是我们可以同时运行多个redis客户端进程，常见的并发问题还是会出现。


<2> 方法：
首先要执行multi命令，紧随其后的是所有你想要执行的命令（作为事务的一部分），最后执行exec命令去实际执行命令，或者使用discard命令放弃执行命令。

Redis的事务功能保证了什么：
- 事务中的命令将会按顺序地被执行
- 事务中的命令将会如单个原子操作般被执行（没有其它的客户端命令会在中途被执行）
- 事务中的命令要么全部被执行，要么不会执行

六. 关键字反模式


第四章 超越数据结构

5种数据结构组成了Redis的基础，其他没有关联特定数据结构的命令也有很多。这一章将看看其他的一些重要命令。

一、使用期限(Expiration)
1. Redis允许你标记一个关键字的使用期限。
可以给予一个Unix时间戳形式（自1970年1月1日起）的绝对时间，或者一个基于秒的存活时间。

expire pages:about 30   //30s后删除掉关键字(包括其关联的值)
expireat pages:about 1356933600

2. 这让Redis成为一个理想的缓冲引擎。
使用ttl命令可以知道一个关键字还能存活多久。
使用persist命令可以将关键字的使用期限删掉。

3. setex命令让你可以在一个单独的原子命令里设置一个字符串值，同时里指定一个生存期。
setex pages:about 30 '<h1>about us</h1>....'

二、发布和订阅
1. Redis的列表数据结构有blpop和brpop命令，能从列表里返回且删除第一个（或最后一个）元素，或者被堵塞，直到有一个元素可供操作。这可以用来实现一个简单的队列。
（对于blpop和brpop命令，如果列表里没有关键字可供操作，连接将被堵塞，直到有另外的Redis客户端使用lpush或rpush命令推入关键字为止。）
