第二章 算法

0、算法的定义：
	算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。

1、函数的渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对所有n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐进快于g(n)。

2、算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。
表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。
其中f(n)是问题规模n的某个函数。

推导大O阶：
<1>用常数1取代运行时间中的所有加法常数。
<2>在修改后的运算次数函数中，只保留最高阶项。
<3>如果最高阶项存在且不是1，则去除与这个项目相乘的常数。

eg :
int count = 1;
while(count < n)
{
	count = count * 2;
}
//有多少个2相乘后大于n？ 结果是log2 n

O(1)      常数阶
O(n)      线性阶
O(n^2)    平方阶
O(log n)  对数阶
O(nlog n) nlog n阶
O(n^3)    立方阶
O(2^n)    指数阶

3、最坏情况与平均情况
<1>通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
<2>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。
				 另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。
一般没有特殊说明时，都是指最坏时间复杂度。

4、算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))。
其中，n为问题规模，f(n)为语句关于n所占存储空间的函数。
<1>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数变量和输入数据外，还需要存储对数据操作的存储单元。
<2>当不用限定词地使用"复杂度"时，通常都是指时间复杂度。


第三章 线性表

0、线性表(List)
零个或多个数据元素的有限序列。 
<1>序列：元素之间是有顺序的。
<2>要是相同类型的元素。
<3>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。

1、线性表的顺序存储结构
线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。  //数组

#define MAXSIZE 20     //存储空间初始分配量
typedef int ElemType;  //假定类型为int
typedef struct
{
	ElemType data[MAXSIZE];
	int length;   //线性表当前长度
}SqList;

<1>存取
1)该存储方式下，可以随时算出线性表中任意位置的地址：loc(ai) = loc(a1) + (i - 1) * c
不管是第一个还是最后一个，都是相同的时间。
2)该存储方式下，对每个线性表位置的存入或者取出数据，对于计算机来说都是相等时间，也就是一个常数。
即，它的存取时间复杂度为O(1)。把具有这种特点的存储结构称为随机存取结构。

<2>插入与删除
1)时间复杂度都是O(n)。

<3>线性表顺序存储结构的优缺点
1)适合元素个数不太变化，更多是存取数据的应用。

2)优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间；
		可以快速地存取表中任一位置的元素。
		
3)缺点：插入和删除操作需要移动大量元素；
		当线性表长度变化较大时，难以确定存储空间的容量；
		造成存储空间的"碎片"。

2、线性表的链式存储结构
用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。

typedef int ElemType;  //假定类型为int
typedef struct Node
{
	ElemType data;
	struct Node *next;
}node;
typdef struct Node *LinkList; //定义LinkList   //typdef (struct Node *)LinkList;

<1>链式结构中，除了要存储数据元素信息外，还要存储它的后继元素的存储地址。
1)数据域：存储数据元素信息的域
2)指针域：存储直接后继位置的域
这两部分信息组成数据元素ai的存储映像，称为结点(Node)。

3)n个节点链结成一个链表，即为线性表的链式存储结构。因为此链表的每个结点中只包含一个指针域，所以叫做单链表。

<2>头指针
1)头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。
2)头指针具有标识作用，所以常常用以头指针冠以链表的名字。
3)无论链表是否为空，头指针均不为空。头指针是链表的必要元素。

<3>头结点
1)头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义(也可以存储线性表的长度等附加信息)；
2)有了头结点，对第一个元素结点前插入结点和删除第一个结点，其操作与其他结点的操作就统一了。
3)头结点不一定是链表必须要素。

<4>线性链表的最后一个节点指针为空(NULL)。

<5>单链表的读取
需要从头开始找，时间复杂度为O(n)。

<6>单链表的插入和删除
时间复杂度为O(n)。由两部分组成：遍历查找到第i个元素；插入和删除元素。

对于插入或删除数据越频繁的操作，单链表的效率优势越明显。

3、单链表结构与顺序存储结构优缺点
<1>存储分配方式：
1)顺序存储结构用一段连续的存储单元依次存储线性表的数据元素；
2)单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。

<2>时间性能
1)查找：
	顺序存储结构 O(1)
	单链表		 O(n)

2)插入和删除
	顺序存储结构需要平均移动表长一半的元素 O(n)
	单链表在先找到某位置的指针后O(n)，插入和删除时间仅为 O(1)

<3>空间性能
1)顺序存储结构需要预分配存储空间，分太大，浪费；分太小，溢出
2)单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制


4、静态链表

5、循环链表

6、双向链表
typedef int ElemType;  //假定类型为int
typedef struct DulNode
{
	ElemType data;
	struct DulNode *prior;
	struct DulNode *next;
}dulNode, *DuLinkList;

第四章  栈和队列
4.2 栈的定义
1、栈(stack)是限定仅在表尾进行插入和删除操作的线性表。
<1>允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。
<2>栈又称为后进先出的线性表。LIFO(Last in first out)结构。
<3>栈底是固定的，最先进栈的只能在栈底。
<4>栈的插入操作，叫做进栈、压栈、入栈。
	栈的删除操作，叫做出栈、弹栈。

<5>栈是线性表，具有线性关系，即前驱后继关系。

2、进栈出栈变化形式
<1>栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制。
也就是说，不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证栈顶元素出栈即可。
<2>eg：3个整数1、2、3依次进栈，会有哪些出栈次序？
1 2 3进     3 2 1出
1进1出 2进2出 3进3出
...

4.3 栈的抽象数据类型
理论上线性表的操作特性它都具备。插入和删除，改名为push和pop。

4.4 栈的顺序存储结构及实现
1、结构定义：
typedef int SElemType;  //SElemType类型根据实际情况而定，这里假定为int
typedef struct
{
	SElemType data[MAXSIZE];
	int top; //用于栈顶指针
}SqStack;

<1>数组下标为0的一端作为栈底。top变量用来指示栈顶元素在数组中的位置。
<2>当栈存在一个元素时，top等于0。通常把空栈的判断条件定位top等于-1。

4.5 两栈共享空间
1、栈的顺序存储结构不存在线性表插入和删除时需要移动元素的问题。不过它必须事先确定数组存储空间的大小。
对于两个相同类型的栈，我们可以做到最大限度地利用其事先开辟的存储空间来进行操作。
<1>两个相同类型的栈，有可能一个栈已经满了，而另一个栈还有很多存储空间空闲。我们可以用一个数组来存储两个栈。

<2>让一个栈的栈底为数组的始端(下标为0处)，另一个栈的栈底为数组的末端(下标为n-1处)。
栈1为空时，top1等于-1；栈2为空时，top2等于n。

<3>top1+1等于top2时表示栈满。
极端情况：栈2为空，top1等于n-1时，栈1满；栈1为空，top2等于0时，栈2满。

2、两栈共享空间的结构：
typedef int SElemType;  
typedef struct
{
	SElemType data[MAXSIZE];
	int top1; 
	int top2; 
}SqDoubleStack;

3、使用这样的结构，通常都是在当两个栈的空间需求有相反关系时。并且两个栈的数据类型必须相同。


4.6 栈的链式存储结构及实现













































