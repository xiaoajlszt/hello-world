第3章 文件I/O
3.1 引言
1、本章描述的函数经常被称为不带缓冲的I/O(与第5章中的标准I/O函数相对)。
<1>不带缓冲是指每个read和write都调用内核中的一个系统调用。
<2>这些不带缓冲的I/O函数不是ISO C的组成部分。它们是POSIX(可移植操作系统接口)的组成部分。

3.2 文件描述符
1、对于内核而言，所有打开的文件都通过文件描述符引用。
<1>文件描述符是一个非负整数，当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。

<2>UNIX系统shell把文件描述符0(STDIN_FILENO )与进程的标准输入关联；	
				            1(STDOUT_FILENO)与      标准输出关联；	
                            2(STDERR_FILENO)与      标准错误关联。
标准输入默认指向键盘；标准输出默认指向终端；标准错误默认指向终端。这些常量在头文件<unistd.h>中。

<3>文件描述符的范围0~OPEN_MAX-1。
OPEN_MAX是允许每个进程最多打开的文件数。目前内核中已经没有这个参数，而是通过资源限制(/etc/security/limits.conf)来限制最大文件描述符数目。

3.3 函数open和openat
1、调用open或openat函数打开或创建一个文件
#include <fcntl.h>
int open(const char *path, int oflag, ... /*mode_t mode*/);
int openat(int fd, const char *path, int oflag, ... /*mode_t mode*/);
<1>说明
1)...表示余下的参数的数量及其类型是可变的。
2)对于open而言仅当创建新文件时才使用mode参数。

<2>参数：
oflag：通过|运算组合：

O_RDONLY	只读打开
O_WRONLY	只写打开
O_RDWR		读写打开
O_EXEC		只执行打开
O_SEARCH	只搜索打开(应用于目录)

以上五个必须指定且只能指定一个。下面常量是可选的：

O_APPEND	每次写时都追加到文件的尾端
O_CLOEXEC	把FD_CLOEXEC常量设置为文件描述符标志
O_CREAT		若文件不存在则创建它。
			使用此选项时，open/openat函数需同时说明参数mode，用于指明该新文件的访问权限。
O_DIRECTORY	如果path引用的不是目录，则出错
O_EXCL		如果同时指定了O_CREAT，且文件已经存在，则报错。
			用于测试一个文件是是否存在，如果不存在，则创建该文件，这使测试和创建两者称为一个原子操作。
eg：ret = open("/home/xiaopeng/python/1", O_RDONLY | O_EXCL | O_CREAT); 存在返回负数，不存在返回正数。

O_NOCTTY	如果path引用中端设备，则不讲该设备分配作为此进程的控制中端。
O_NOFOLLOW	如果path引用的是一个符号链接，则出错。
O_NONBLOCK	如果path引用的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式。

O_SYNC		使每次write等待物理I/O操作完成，包括由该write操作引起的文件属性更新所需的I/O。
O_TRUNC		如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0。
O_TTY_INIT	如果打开一个还未打开的中端设备，设置非标准termios参数值。

O_DSYNC		使每次write要等待物理I/O操作完成，但是如果该写操作不影响读取刚写入的数据，则不需要等待文件属性被更新。
            O_DSYNC和O_SYNC标志有微妙的区别，仅当文件属性需要更新以反映文件数据变化时，
            O_DSYNC标志才影响文件属性，而设置O_SYNC标志后，数据和属性总是同步更新。
O_RSYNC     使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作都完成。

2、由open和openat函数返回的文件描述符一定是最小的未用描述符数值。
这一点被某些应用程序用来在标准输入、标准输出、标准错误上打开新的文件。(先关闭标准输出，然后在打开另一个文件)

3、fd参数区分open和openat
<1>path参数指定的是绝对路径，这种情况下，fd参数被忽略，openat函数就相当于open函数;
<2>path参数指定的是相对路径，fd参数指出了相对路径名在文件系统中的开始地址。fd参数是通过打开相对路径名所在的目录来获取的;
<3>path参数指定的是相对路径，fd参数具有特殊值AT_FDCWD，这种情况下，路径名在当前工作目录中获取。

openat希望解决：
<1>让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。
<2>可以避免TOCTTOU错误。(time-of-check-to-time-of-use)
如果两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的。
因为这两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用结果不再有效。

4、文件名和路径名截断
#include <linux/limits.h>
#define NAME_MAX         255    /* # chars in a file name */
#define PATH_MAX        4096    /* # chars in a path name including nul */

<1>POSIX.1中，常量_POSIX_NO_TRUNC决定是要截断过长的文件名或路径名，还是返回一个出错。
1)根据文件系统的类型，该值可以变化。通过fpathconf或pathconf来查询目录具体支持何种行为，到底是截断过长的文件名还是返回出错。
2)若该值有效，则在整个路径名超过PATH_MAX，或路径名中的任一文件名超过NAME_MAX时，出错返回，并将errno设为ENAMETOOLONG。

3.4 函数create
1、也可以调用creat函数创建一个新文件：
#include <fcntl.h>
int creat(const char *path, mode_t mode);	//成功，返回为只写打开的文件描述符；失败，返回-1。
等效于：
open(path, O_WRONLY | O_CREAT | O_TRUNC, mode); //O_TRUNC：如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0。(清空)

2、由于现在open函数提供了O_CREAT和O_TRUNC选项，因此也就不再需要单独的creat函数。
<1>creat的不足之处是它以只写方式打开所创建的文件。

3.5 函数close
1、可以调用close函数关闭一个打开的文件:
#include <unistd.h>
int close(int fd); //若成功，返回0；若失败，返回-1。
<1>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。
<2>当一个进程终止时，内核自动关闭它所有的打开文件。
很多程序都利用这一功能而不显式地用close关闭打开的文件。

3.6 函数lseek
1、每个打开文件都有一个与其相关联的“当前文件偏移量”，用于度量从文件开始处计算的字节数。
1)通常读、写操作都是从当前文件的偏移量处开始，并使偏移量增加所读写的字节数。
2)打开一个文件时，除非指定O_APPEND选项，否则该偏移量被设置为0。

2、可以调用lseek显式地为一个打开文件设置偏移量：
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence); //若成功，返回新的文件偏移量；若失败，返回-1。
off_t是带符号数据类型。若off_t是32位整型，则文件最大长度是2^31 - 1。
对参数offset的解释与参数whence的值有关：
<1>whence为SEEK_SET，则将该文件的偏移量设置为距文件开始处offset个字节；
<2>whence为SEEK_CUR，则将该文件的偏移量设置为其当前值加offset，offset可以为负数；
<3>whence为SEEK_END，则将该文件的偏移量设置为文件长度加offset，offset可以为负数。

3、lseek(fd, 0, SEEK_CUR); //可用于确定某个文件是否可以设置偏移量。
	如果文件描述符指向的是一个管道、FIFO、网络套接字，则返回-1，并将errno设为ESPIPE。

<1>eg:
if(lseek(STDIN_FILENO, 0 ,SEEK_CUR) == -1)
	printf("can not seek!\n");
else
	printf("seek OK!\n");
	
./a.out < /etc/passwd
seek OK!

cat < /etc/passwd | ./a.out
can not seek!

<2>通常，文件的当前偏移量应当是一个非负整数。对于普通文件，其偏移量必须是非负数。

<3>lseek仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作。该偏移量将用于下一个读或写操作。

3、文件偏移量可以大于文件的当前长度，这样，对该文件的下一次写将加长该文件，并在文件中构成一个空洞。
<1>位于文件中，但没有写过的字节都被读为0。
<2>文件空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关。

int fd = creat("file.hole", FILE_MODE);
write(fd, buf1, 10);
lseek(fd, 16384, SEEK_SET)
write(fd, buf2, 10);

ls -l file.hole		16394
od -c file.hole		//观察文件的实际内容  -c表示以字符方式打印文件内容。

ls -ls file.hole file.nohole //虽然两个文件的长度相同(16394)，但无空洞的文件占用了20个磁盘块；有空洞的文件只占用了8个磁盘块。

4、因为lseek使用的偏移量是用off_t类型表示的，所以允许具体实现根据各自特定的平台自行选择合适的数据类型。
<1>大多数平台提供两组接口处理文件偏移量，一组是32位文件偏移量，一组是64位文件偏移量。
<2>尽管可以实现64位文件偏移量，但是能否创建一个大于2GB(2^31 - 1字节)的文件则依赖于底层文件系统的类型。

	
3.7 函数read
1、调用read函数从打开文件中读取数据：
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes); //返回读到的字节数，若已经到文件末尾，返回0；出错返回-1。
<1>有多种情况使得读到的字节数少于要求读的字节数。

3.8 函数write
1、调用write函数向打开文件写数据：
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes); //若成功返回已写的字节数；若出错，返回-1。
<1>返回值通常与参数nbytes的值相同，否则表示出错。
write出错的常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制。

3.9 I/O的效率
1、eg
#define BUFFSIZE   4096

int main()
{
    int n;
    char buf[BUFFSIZE];

    while((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
        if(write(STDOUT_FILENO, buf, n) != n)
            printf("write error!");

    if(n < 0)
        printf("read error!");

    return 0;
}

<1>对UNIX系统内核而言，文本文件和二进制代码文件并无区别。所以本程序对这两种文件都有效。
<2>如何选取BUFFSIZE的值：
测试所用的文件系统是ext4，器磁盘块长度为4096字节。可以看出系统CPU时间的几个最小值差不多出现在BUFFSIZE为4096及以后的位置，
继续增加缓冲区长度对此时间几乎没有影响。

<3>大多数文件系统为改善性能都采用某种预读(read ahead)技术。
当检测到正进行顺序读取时，系统就试图读入比应用所要求的更多数据，并假想应用很快就会读这些数据。

3.10 文件共享
1、内核使用三种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响：
<1>每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每个文件描述符占用一项：
1)文件描述符标志；
2)指向一个文件表项的指针。

<2>内核为所有打开文件维持一张文件表。每个文件表项包含：
1)文件状态标志(读、写、添写、同步和阻塞等)；
2)当前文件偏移量；
3)指向该文件v节点的表项的指针。

<3>每个打开文件(或设备)都有一个v节点(v-node)结构。
1)v节点包含了文件类型和对此文件进行各种操作函数的指针。
对于大多数文件，v节点还包含了该文件的i节点(i-node，索引节点)。

2)这些信息是在打开文件时从磁盘上读入内存的，所以，文件的所有相关信息都是随时可用的。

3)创建v节点结构的目的是对一个计算机系统上的多文件系统类型提供支持。(虚拟文件系统)

4)Linux没有使用v节点，而是使用了通用的i节点结构。
Linux没有把相关数据结构分为i节点和v节点，而是采用一个与文件系统相关的i节点和一个与文件系统无关的i节点。

2、两个独立进程打开同一个文件
<1>假定第一个进程在文件描述符3上打开该文件，另一个进程在文件描述符4上打开该文件。 //结构1
<2>打开该文件的每个进程都获得各自的一个文件表项。//结构2	
之所以每个进程都获得自己的文件表项，是因为这可以使每个进程都有自己对该文件的当前偏移量。

<3>但对于一个给定的文件只有一个v节点表项。//结构3

3、说明
<1>每当完成一个write后，在文件表项中的当前文件偏移量即增加所写入的字节数。
如果这导致当前文件偏移量超出了当前文件长度，则将i节点表项中的当前文件长度设置为当前文件偏移量。

<2>如果用O_APPEND标志打开一个文件，则相应标志会被设置到文件表项的文件状态标志中。
每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。
这使得每次写入的数据都追加到文件的当前末尾位置。

<3>若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。
这与用O_APPEND标志打开文件是不同的。

<4>lseek函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作。

4、可能有多个文件描述符指向同一个文件表项。
<1>dup函数
<2>fork，父子进程各自的每一个打开文件描述符共享同一个文件表项。

5、文件描述符和文件状态标志的作用范围有区别：
前置只用于一个进程的一个描述符，而后者则应用于指向该给定文件表项的任何进程的所有描述符。

6、多个独立进程读取同一个文件可以正确工作；多个独立进程写同一个文件时，则可能产生预想不到的结果。

3.11 原子操作
1、追加到一个文件
每个进程都已经打开了该文件，但并未使用O_APPEND标志。每个进程还需要调用lseek和write。
<1>任何要求多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核有可能会临时挂起进程。
<2>UNIX系统为这样的操作提供了一种原子操作方法，即在打开文件时设置O_APPEND标志。

2、函数pread和pwrite
1、SUS包括了XSI扩展，该扩展允许原子性地定位并执行I/O，pread、pwrite就是这种扩展。
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset); //返回读到的字节数，若已经到文件尾，返回0；出错返回-1。
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); //若成功，返回已写的字节数，若出错，返回-1。

<1>调用pread相当于调用lseek后调用read，但是pread又与这种顺序调用有如下区别：
1)调用pread时，无法中断其定位和读操作;
2)不更新当前文件偏移量。

<2>调用pwrite相当于调用lseek后调用write，但也有类似的区别。

3、创建一个文件
对于open函数同时指定O_CREAT、O_EXEC选项时，检查文件是否存在和创建文件这两个操作是作为一个原子操作执行的。

3.12 函数dup和dup2
1、下面两个函数都可以用于复制一个现有的文件描述符：
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);
若成功，返回新的文件描述符;若出错，返回-1。

<1>由dup返回的新文件描述符一定是当前可用文件描述符中的最小值。
<2>dup2可以用fd2参数指定新描述符的值。
1)如果fd2已经打开，则先将其关闭；
2)如果fd等于fd2，则dup2返回fd2，而不关闭它。
3)否则fd2的FD_CLOEXEC文件描述符标志就被清除，这样fd2在进程调用exec时是打开状态。

<3>这些函数返回的新文件描述符与参数fd共享同一个文件表项。

<4>每个文件描述符都有它自己的一套文件描述符标志。新的描述符在执行时关闭(close-on-exec)标志总是由dup函数清除。

2、复制一个描述符的另一种方法是fcntl函数。
<1>dup(fd);        等效于	fcntl(fd, F_DUPFD, 0);
<2>dup2(fd,fd2);	等效于	close(fd2);	fcntl(fd, F_DUPFD, fd2);
dup2并不完全等同于close加上fcntl:
1)dup2是一个原子操作，而close和fcntl包括两个函数调用。
2)dup2和fcntl有一些不同的errno。

3.13 函数sync、fsync、fdatasync
1、传统的UNIX系统实现，在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都是通过缓冲区进行。
当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。
这种方式称为延迟写(delayed write)。

2、通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。
为了保证磁盘上实际文件系统与缓冲区中内容的一致，UNIX提供了sync、fsync和fdatasync三个函数。
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);
成功返回0；出错返回-1。
void sync(void);

<1>sync只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。
通常称为update的系统守护进程会周期性地调用sync函数，这就保证了定期冲洗(flush)内核的块缓存区。
命令sync也调用了sync函数。

<2>fsync函数只对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束后才返回。

<3>fdatasync函数类似于fsync，但它只影响文件的数据部分。而fsync还会同步更新文件的属性部分。

3.14 函数fcntl
1、fcntl函数可以改变已经打开文件的属性：
#include <fcntl.h>
int fcntl(int fd, int cmd, .../*int arg*/);	//成功则依赖于cmd(标志)，出错返回-1。

<1>fcntl函数又以下5类功能：
1)复制一个已有的描述符(F_DUPFD\F_DUPFD_CLOEXEC)
2)获取/设置文件描述符标志(F_GETFD\F_SETFD)
3)获取/设置文件状态标志(F_GETFL\F_SETFL)
4)获取/设置异步I/O所有权(F_GETOWN\F_SETOWN)
5)获取/设置记录锁(F_GETLK\F_SETLK\F_SETLKW)

<2>标志
F_DUPFD		复制文件描述符fd。新文件描述符作为函数返回值返回。
			它是尚未打开的各描述符中大于或等于第3个参数(取整)中各值的最小值。
			新描述符与fd共享同一文件表项，但新描述符有自己的一套文件描述符标志，
			其中FD_CLOEXEC文件描述符标志被清除(清除表示该描述符在exec时仍保持有效)。

F_DUPFD_CLOEXEC		复制文件描述符，设置与描述符关联的FD_CLOEXEC文件描述符标志的值，返回新文件描述符。


3.15 函数ioctl
ioctl函数一直是I/O操作的杂物箱。不能用本章中其他函数表的I/O操作通常都能用ioctl表示。
#include <sys/ioctl.h>
int ioctl(int fd, int request, ...);	//出错返回-1；成功返回其他值





































































