第七章、进程环境
7.2 main函数
1、main函数原型
int main(int argc, char *argv[]) / int main(int argc, char **argv)
argc: 命令行参数的数目
argv：指向参数的各个指针所构成的数组。其中第0个参数是程序的全名。
说明：当内核执行C程序时，在调用main之前首先调用一个特殊的启动例程。
可执行程序文件将此启动例程指定为程序的起始地址。(这是由连接编辑器设置的，而连接编辑器则由C编译器调用)
启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用的main函数做好安排。

2、注：启动例程
<1>启动例程是这样编写的：使得从main返回后立即调用exit函数。
如果将启动例程以C代码形式表示(常常用汇编语言编写)，则他调用main函数的形式可能是：
exit(main(argc,argv));


7.3 进程终止
1、有8中方式使进程终止，其中5种为正常终止：
<1>从main返回(return)
<2>调用exit
<3>调用_exit或_Exit
<4>最后一个线程从启动例程返回(return)
<5>从最后一个线程调用pthread_exit

异常终止有3种方式：
<1>调用abort
<2>接到一个信号
<3>最后一个线程对取消请求做出响应

2、退出函数
3个函数用于正常终止一个程序：_exit和_Exit立即进入内核；exit则先执行一些清理处理，然后返回内核。

<1>由于历史原因，exit函数总是执行一个标准I/O库的清理关闭操作：
对于所有打开的流调用fclose函数。造成所有输出缓存中的所有数据都被冲洗(写到文件上)。

<2>3个退出函数都带一个整型参数，称为终止状态。大多数UNIX系统shell都提供检查进程终止状态的方法。(echo $?)
如果出现下面的任意一种情况，则该进程的终止状态是未定义的。
1)调用这些函数时不带终止状态；
2)main执行了一个无返回值的return；
3)main没有声明返回类型为整数。

但是，若main的返回类型是整型，并且main执行到最后一条语句时返回(隐式返回)，那么该进程的终止状态为0。//C99标准引入
编译时加上 -std=c99 选项。
(历史上，若main函数终止时没有显式使用return语句或调用exit函数，那么进程终止状态是未定义的。)

<3>main函数返回一个整型值与用该值调用exit是等价的。即exit(0)等价于return 0。

3、函数atexit
按照ISO C(ANSI C是ISO C的前生，两者都是标准C)的规定，一个进程可以登记至多32个函数，这些函数将由exit自动调用。
称这些函数为终止处理程序，并调用atexit函数来登记这些函数。
<1>函数说明
int atexit(void (*func)(void)); //成功返回0
其中，atexit的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回某个值。
exit调用这些函数的顺序和登记顺序相反。若多次登记同一个函数，也会被多次调用。

<2>根据ISO C和POSIX.1，exit首先调用各终止处理程序，然后关闭(通过fclose)所有打开流。

4、一个C程序如何启动和终止的
<1>内核使程序执行的唯一方法是调用一个exec函数。
<2>进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用_exit或_Exit。
<3>进程也可以非自愿地由一个信号使其终止。

7.4 命令行参数
1、当执行一个程序时，调用exec的进程可以将命令行参数传递给该新程序。这是UNIX shell的一部分常规操作。
2、ISO C和POSIX.1都要求argv[argc]是一个空指针。因此遍历操作可以：
for(loop=0;loop<argc;loop++)
for(loop=0;NULL!=argv[loop])

7.5 环境表
1、每个程序都接收到一张环境表。
<1>与参数表类似，环境表也是一个字符指针数组，其中每个指针包含一个C字符串的地址。
<2>全局变量environ则包含了该指针数组的地址: extern char ** environ;
称environ为环境指针，指针数组为环境表，其中各个指针指向的字符串为环境字符串。

2、通常用getenv和putenv函数来访问特定的环境变量，而不是用environ变量。
如果要看整个环境，则必须使用environ指针。

7.6 C程序的存储空间布局
1、C程序由下列部分组成：

高地址 ----------------------------------------------- 低地址

命令行参数和环境变量 -> 栈 -> 堆 -> BSS -> 初始化数据 -> 正文

对于32位Inter X86处理器，正文段从0x08048000单元开始，栈底则在0xC0000000之下开始。
(在这种特定结构中，栈从高地址向低地址方向增长)
堆顶和栈顶之间未用的虚地址空间很大。

<1>正文段。这是由CPU执行的机器指令部分。
通常正文段是可以共享的，即使是频繁执行的程序(文本编辑器、C编译器、shell等)在存储器中也只需要一个副本。
通常正文段是只读的，以防止程序由于意外而修改其指令。

<2>初始化数据段
通常将此段称为数据段，它包含了程序中需要明确初始化的全局变量。

<3>未初始化数据段
通常称为BSS段。在程序开始执行之前，内核将此段中的全局数据初始化为0或者空指针。

<4>栈
1)自动变量以及每次函数调用时所需保存的信息都存放在此段中。
2)最近被调用的函数栈上为其自动和临时变量分配存储空间。
自动变量(就是局部变量？)、临时变量(如:i++这种临时存储++后的值的？)

自动变量：auto关键字(通常省略，编译器会自动添加该关键字)
C程序是面向过程的，在C代码中会出现大量的函数模块，每个函数都有其生命周期（也称作用域），
在函数生命周期中声明的变量通常叫做局部变量，也叫自动变量。

<5>堆
通常在堆中进行动态存储分配。

2、a.out中还有若干其他类型的段，如包含符号表的段、包含调试信息的段以及包含动态共享库链接的段等。
这部分并不装载到进程执行的程序映像中。

3、未初始化数据段的内容并不存放在磁盘程序文件中。其原因是，内核在程序开始运行之前将它们都设为0。
需要存放在磁盘程序文件中段只有正文段和初始化数据段。

4、size(1)命令显示正文段、数据段、bss段的长度(以字节为单位)
$ size termination1.exe 
text    data     bss     dec     hex filename
1184     552       8    1744     6d0 termination1.exe
其中，第4、5列分别以十进制和十六进制表示3段总长度。


7.7 共享库
1、共享库使得可执行可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。
程序第一次执行(装入内存时链接？)或者第一次调用(运行时链接？)某个库函数时，用动态链接的方法将程序与共享库函数相链接。
<1>减少了每个可执行文件的长度，但增加了一些运行时间开销;
<2>可以用库函数的新版本替代老版本而无需对使用该库的程序重新连接编辑。(假设共享库函数接口不变)

2、eg
gcc -static termination1.c -Wall -g -o 1.exe
gcc termination1.c -Wall -g -o 2.exe	//gcc默认使用共享库

ls -al //发现静态链接的文件更大
size 1.exe
size 2.exe //发现使用共享库后，可执行文件的正文和数据段的长度都明显减小。

7.8 存储空间分配
1、ISO C说明了3个用于存储空间动态分配的函数：
#include <stdlib.h>
<1>void *malloc(size_t size);
分配指定字节数的存储区。此存储区的初始值不确定。
<2>void *calloc(size_t nobj, size_t size);
为指定数量指定长度的对象分配存储空间。该空间中每一位(bit)都初始化为0。
<3>void *realloc(void *ptr, size_t newsize); //newsize是存储区的新长度，若ptr为NULL，则realloc和malloc相同。
增加或减少以前分配区的长度。
1)通常用于增加存储区长度，新增区域内的初始值不确定。
2)若在原存储区后有足够的空间可扩充，则可在原存储区位置向高地址方向扩充，无需移动任何原先的内容，并返回与入参相同的指针值。
3)若在原存储区后没有足够的空间，则realloc分配另一个足够大的存储区，并将现存的内容复制到新分配的存储区。
然后释放原存储区，返回新分配的指针。
因为这种存储区可能会移动位置，所以不应当使任何指针指在该区中。

说明：
1)这三个函数，若成功返回非空指针；若失败，返回NULL。
2)这三个函数返回的指针一定是适当对齐的，使其可用于任何数据对象。
eg：如果最苛刻的对齐要求是double必须在8的倍数地址单元处开始，那么这3个函数返回的指针都应该这样对齐。

<4>void free(void *ptr);
释放ptr指向的存储空间，被释放的空间通常被送入可用存储区池。

2、这些分配例程通常用sbrk系统调用实现。该系统调用扩大或缩小进程的堆。

3、大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息(分配块的长度、指向下一个分配块的指针等)。

4、可能的错误
<1>如果超过一个已分配区的尾端或者在已分配区起始位置之前进行写操作，则会改写另一块的管理记录信息或内容。
<2>释放一个已经释放的块。
<3>忘记释放。

5、替代的存储空间分配程序

7.9 环境变量
环境字符串的形式是： name=value。内核并不查看这些字符串，它们的解释完全取决于各个应用程序。

1、ISO C定义了一个函数getenv，可以用其取环境变量值，但是该标准又称环境的内容是由实现定义的。
#include <stdlib.h>
char *getenv(const char *name); //返回指向name关联的value指针；若未找到返回NULL。

2、除了获取环境变量的值，有时也需要改变现有变量的值，或者增加新的环境变量。
<1>只能影响当前进程以及其后生成和调用的任何子进程的环境变量。
int putenv(char *str); //成功返回0,失败返回非0
取形式为name=value的字符串，将其放入环境表中。如果name已经存在，则先删除原先的定义。

int setenv(const char *name, const char *value, int rewrite);
将name设置为value。如果name已经存在：若rewrite非0,则先删除原先的定义;若rewrite为0,则不删除原先定义，也不设置为新的value。

int unsetenv(const char *name);
删除name的定义，即使不存在也不出错。

3、环境表(指向name=value字符串的指针数组)和环境字符串通常存放在进程存储空间的顶部。
<1>删除一个字符串，只需要在环境表中找到该指针，然后将所有后续指针都向环境表首部顺次移动一个位置。
<2>增加或修改字符串就困难很多。环境表和环境字符串不能再向高地址方向(顶部)扩展;
同时也不能移动在它之下的各栈帧，所以也不能向低地址方向(底部)扩展。
使得该空间长度不能增加。需要使用malloc分配存储空间。


7.10 函数setjmp和longjmp
1、在C中，goto语句不能跨越函数;而执行这种功能的是函数setjmp和longjmp。
这两个函数对于处理发生在很深层次嵌套函数调用中的出错情况是非常有用的。

7.11 函数getrlimit和setrlimit
1、每个进程都有一组资源限制，其中一些可以用getrlimit和setrlimit函数查询和更改。
#include <sys/resource.h>
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);//成功返回0,失败返回非0

struct rlimit{
    rlim_t rlim_cur;    //soft limit: current limit
    rlim_t rlim_max;    //hard limit：maximum value for rlim_cur
};

<1>进程的资源限制通常是在系统初始化时由0号进程建立的，然后由后续进程继承。

2、更改资源限制时，必须遵循下列规则：
<1>任何一个进程都可以将一个软限制值更改为小于或等于其硬限制值。
<2>任何一个进程都可以降低其硬限制值，但它必须大于或等于其软限制值。这种降低对于普通用户来说是不可逆的。
<3>只有超级用户可以提高硬限制值。

常量RLIM_INFINITY指定了一个无限量的限制。


第8章 进程控制
8.2 进程标识
1、每个进程都有一个非负整型表示的唯一进程ID。
<1>由于进程ID是惟一的，常将其用作其他标识符的一部分以保证其唯一性。
<2>虽然是唯一的，但是进程ID是可复用的。当一个进程终止后，其ID就成为复用的候选者。(大多数UNIX系统实现了延迟复用算法)
<3>系统中有一些专用进程。
1)ID为0的进程通常是调度进程，常常被称为交换进程(swapper)。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。
2)ID为1的进程通常是init进程，在自举过程结束时由内核调用。该进程的程序文件为/sbin/init。
该进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件，并将系统引导到一个状态(如多用户)。
init进程不会终止。
init进程是一个普通的用户进程，不是内核中的系统进程。它以超级用户特权运行。
init进程会成为所有孤儿进程的父进程。

UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 10:14 ?        00:00:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 21

2、每个UNIX系统实现都有它自己的一套提供操作系统服务的内核进程。
<1>某些UNIX的虚拟存储器实现中，进程ID2是页守护进程，此进程负责支持虚拟存储器系统的分页操作。

3、除了进程ID，每个进程还有一些其他标识符：
#include <unistd.h>
pid_t getpid(void);		//返回当前进程ID
pid_t getppid(void);	//返回父进程ID
uid_t getuid(void);		//返回当前进程的实际用户ID
uid_t geteuid(void);	//返回当前进程的有效用户ID
gid_t getgid(void);		//返回当前进程的实际组ID
gid_t getegid(void);	//返回当前进程的有效组ID

8.3 函数fork
1、当前进程可以调用fork函数创建一个子进程。
#include <unistd.h>
pid_t fork(void);	//返回值：子进程返回0，父进程返回子进程ID；若出错返回-1。
<1>fork函数被调用一次，但返回两次。

<2>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。
子进程获得父进程数据空间、堆、栈的副本。因此父进程和子进程并不共享这些存储空间。父进程和子进程共享正文段。

--------------------------------------------------------------------------------------------------------------------
注:
1、由于fork之后经常跟随着exec，所以现在很多实现并不执行一个父进程数据段、栈、堆的完全副本。
使用COW(Copy-On-Write，写时复制)技术作为替代，这些区域由父进程和子进程共享，而且内核将它们的访问权限设置为只读。
如果父进程和子进程中的任何一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一页。

2、全局变量对于每个进程都有独立的副本。不会互相影响。

3、疑惑：子进程为什么要拷贝父进程的数据段、栈、堆？
个人理解：例如有一个全局变量g_id1，父进程中已经赋值为10，那么创建子进程后，子进程会记住g_id1的值为10。
--------------------------------------------------------------------------------------------------------------------

<3>一般来说，在fork之后，父进程和子进程的先后执行顺序是不确定的，取决于内核所使用的调度算法。
//内核有意选择先执行子进程，因为一般子进程都会马上调用exec()函数，这样可以避免写时拷贝的额外开销。
如果先执行父进程，有可能会开始向地址空间写入。

<4>eg
int globvar = 6;
char buf[] = "a write to stdout\n";

int main(void)
{
    int var;
    pid_t pid;

    var = 88;
    if(write(STDOUT_FILENO, buf, sizeof(buf)-1 != sizeof(buf)-1))
    {
        err_sys("write error!");
    }
    printf(“before fork\n”);

    if((pid = fork()) < 0)
    {
        err_sys("fork error!");
    }
    else if(0 == pid)
    {
        globvar++;
        var++;
    }
    else
    {
        sleep(2);
    }

    printf("pid = %ld, glob = %d, var = %d\n", (long)getpid(), globvar, var);
    exit(0);
}

1)write函数不带缓冲，因此其数据写入标准输出一次。
2)标准I/O库是带缓冲的，如果标准输出连接到终端设备，则它是行缓冲;否则它是全缓冲。
因此，当以交互方式运行该程序时只得到该printf输出的行一次;当将标准输出重定向到一个文件时，却得到printf输出行两次。
其原因是，在fork之前调用了printf一次，调用fork时，该行数据仍在缓冲区中，然后在将父进程数据空间复制到子进程中时，
该缓冲区数据也被复制到子进程中，此时父进程和子进程各自有了带该行内容的缓冲区。

<5>fork失败的原因
1)系统中已经有太多的进程。
2)该实际用户ID的进程总数超过了系统限制。CHILD_MAX

<6>fork用法
1)父进程希望复制自己，使父进程和子进程同时执行不同的代码段。(网络服务进程，父进程监听，子进程处理)
2)一个进程要执行一个不同的程序。这对shell是常见的情况。该情况下，子进程从fork返回后立即调用exec。

2、文件共享
<1>在重定向父进程的标准输出时，子进程的标准输出也被重定向。
fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。父进程和子进程每个相同的打开描述符共享一个文件表项。(同一个文件偏移量等)

<2>如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步(如上例中的sleep)，那么它们的输出就会互相混合。

<3>fork之后处理文件描述符的情况：
1)父进程等待子进程完成。
这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应的更新。

2)父进程和子进程各自执行不同的程序段。
这种情况下，父进程和子进程各自关闭他们不需要使用的文件描述符，这样就不会干扰对方使用的文件描述符。


8.4 vfork
1、可移植的应用程序不应使用该函数。

2、vfork函数用于创建一个新进程，新进程的目的是exec一个新程序。
<1>vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec(或exit)，于是也不会引用该地址空间。
在子进程调用exec(或exit)之前，子进程运行在父进程的空间中。
<2>vfork保证子进程先运行，子进程调用exec或exit之后父进程才可能被调度运行。


8.5 函数exit
1、5中正常终止和3中异常终止
<1>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开的描述符，释放它所使用的存储器等。
<2>对于任意一种终止，我们都希望进程能通知其父进程它是如何终止的。
1)对于3个终止函数(exit\_exit\_EXIT)，实现这一点的方法是，将其退出状态作为参数传递给函数。
2)在异常情况下，内核产生一个指示其异常终止原因的终止状态。
在任意情况下，父进程都能调用wait或waitpid函数取得子进程的终止状态。
----------------------------------------------------------------------------
“退出状态”和“终止状态”：在最后调用_exit时，内核将退出状态转换成终止状态。
----------------------------------------------------------------------------

2、如果父进程在子进程之前终止又将如何？
对于父进程已经终止的所有进程，他们的父进程都变为init进程(进程号为1)。

3、如果子进程在父进程之前终止，那么父进程如何得到子进程的终止状态？
内核为每个终止子进程保存了一定量的信息，所以当父进程调用wait或waitpid时，可以得到这些信息。
这些信息至少包括：进程ID、进程的终止状态、进程使用CPU时间总量。

4、在UNIX中，一个已经终止，但其父进程尚未对其进行善后处理(获取终止进程的有关信息、释放它仍占用的资源)的进程称为僵死进程。
<1>ps命令将僵死进程的状态打印为Z。
<2>由init进程收养的进程终止时是不会变为僵死进程的。因为init只要有子进程终止，就会调用一个wait函数取得其终止状态。
这样就防止了在系统中塞满僵死进程。


8.6 函数wait和waitpid
1、当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。
<1>因为子进程终止是一个异步事件(可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。
<2>父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。系统默认动作是忽略。

2、调用wait或waitpid的进程
<1>如果其所有子进程都还在运行，则阻塞;
<2>如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回;
<3>如果它没有任何子进程，则立即出错返回。
如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回;如果在随机时间点调用wait，则进程可能会阻塞。

3、函数
#include <sys/wait.h>
pid_t wait(int *statloc); //成功返回终止子进程的ID
pid_t waitpid(pid_t pid, int *statloc, int options);

<1>在一个进程终止前，wait使其调用者阻塞;waitpid有一选项，可使调用者不阻塞。
<2>waitpid并不等待其调用之后的第一个终止进程，它有若干选项，可以控制它所等待的进程。



8.10 函数exec
1、fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序。
<1>当进程调用exec函数时，该进程执行的程序完全替换为新程序，从其main函数开始执行。
<2>exec并不创建新进程，只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。

2、有7种不同的exec函数可供使用，它们统称为exec函数。


第九章 进程关系
9.4 进程组
1、每个进程除了有一个进程ID外，还属于一个进程组。
<1>进程组是一个或多个进程的集合，通常，它们是在同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。
<2>每个进程组有一个唯一的进程组ID。函数getpgid返回调用进程的进程组ID。
#include <unistd.h>
pid_t getpgid(pid_t pid); //返回该进程的进程组ID，若pid为0(getpgid()或getpgid(0)),返回调用进程的进程组ID

<3>每个进程组有一个组长进程，进程组ID等于组长进程的ID。
1)进程组组长可以创建一个进程组、创建该组中的进程，然后终止。
2)只要某个进程组中有一个进程存在，该进程组就存在，这与其组长进程是否终止无关。
3)从进程组创建开始到其中最后一个进程离开为止，称为进程组的生命期。
4)进程组中的最后一个进程可以终止，也可以转移到另一个进程组。

2、setpgid可以加入一个现有的进程组或创建一个新进程组。
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid); 
//将pid进程的进程组ID设置为pgid。如果两者相等，则将pid进程设置为进程组组长。
如果pid为0,则使用调用者的进程ID;如果pgid为0,则由pid指定的进程ID用作进程组ID。

<1>一个进程只能将它自己或它的子进程设置为进程组ID。在它的子进程调用了exec之后，它就不再更改该子进程的进程组ID。
<2>大多数作业控制shell中，在fork之后调用该函数，使父进程设置子进程的进程组ID，并且也使子进程设置自己的进程组ID。


9.5 会话
1、会话是一个或多个进程组的集合。
<1>通常由shell的管道将几个进程编程一组的。
eg：
proc1 | proc2 &         //包括proc1和proc2的进程组
proc3 | proc4 | proc5  

<2>进程调用setsid函数建立一个新会话。
#include <unistd.h>
pid_t setsid(void);


9.8 作业控制
作业控制允许在一个终端上启动多个作业(进程组)，它控制哪个作业可以访问终端以及哪些作业在后台运行。


第十章 信号



第13章 守护进程
守护进程(daemon)是生存期长的一种进程。它们常常在系统引导装入时启动，仅在系统关闭时才终止。
它们没有控制终端，是在后台运行的。UNIX系统有很多守护进程，它们执行日常事务活动。

13.2 守护进程的特征
1、常用的系统守护进程
[root@rcp src]# ps -efj | more
UID        PID  PPID  PGID   SID  C STIME TTY          TIME CMD
root         1     0     1     1  0 8月02 ?       00:00:24 /usr/lib/systemd/systemd --switched-root --system --deserialize 21
root         2     0     0     0  0 8月02 ?       00:00:00 [kthreadd]
root         3     2     0     0  0 8月02 ?       00:00:00 [ksoftirqd/0]
root         5     2     0     0  0 8月02 ?       00:00:00 [kworker/0:0H]
root         6     2     0     0  0 8月02 ?       00:00:03 [kworker/u32:0]
root         8     2     0     0  0 8月02 ?       00:00:00 [migration/0]
root         9     2     0     0  0 8月02 ?       00:00:00 [rcu_bh]
root        10     2     0     0  0 8月02 ?       00:00:00 [rcuob/0]
root        11     2     0     0  0 8月02 ?       00:00:00 [rcuob/1]
root        12     2     0     0  0 8月02 ?       00:00:00 [rcuob/2]
root        13     2     0     0  0 8月02 ?       00:00:00 [rcuob/3]
root        14     2     0     0  0 8月02 ?       00:00:00 [rcuob/4]
root        15     2     0     0  0 8月02 ?       00:00:00 [rcuob/5]
root        16     2     0     0  0 8月02 ?       00:00:00 [rcuob/6]
root        17     2     0     0  0 8月02 ?       00:00:00 [rcuob/7]
root        18     2     0     0  0 8月02 ?       00:00:00 [rcuob/8]
root        19     2     0     0  0 8月02 ?       00:00:00 [rcuob/9]
root        20     2     0     0  0 8月02 ?       00:00:00 [rcuob/10]

<1>父进程为0的各个进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。
(init是个例外，它是由内核在引导装入时启动的用户层次的命令。)
1)内核进程通常存在于系统的整个生命周期中，它们以超级用户特权运行，无控制中断、无命令行。
2)内核守护进程的名字出现在方括号中。
3)该版本的linux使用一个名为kthreadd的特殊内核进程来创建其他内核进程，所以kthreadd表现为其他内核进程的父进程。
4)对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。

2、大多数守护进程都以超级用户特权运行。所有的守护进程都没有控制终端，其终端名设置为问号。
用户层守护进程的父进程是init进程。

3、编程规则






































