第七章、进程环境
7.2 main函数
1、main函数原型
int main(int argc, char *argv[]) / int main(int argc, char **argv)
argc: 命令行参数的数目
argv：指向参数的各个指针所构成的数组。其中第0个参数是程序的全名。
说明：当内核执行C程序时，在调用main之前首先调用一个特殊的启动例程。
可执行程序文件将此启动例程指定为程序的起始地址。(这是由连接编辑器设置的，而连接编辑器则由C编译器调用)
启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用的main函数做好安排。

2、注：启动例程
<1>启动例程是这样编写的：使得从main返回后立即调用exit函数。
如果将启动例程以C代码形式表示(常常用汇编语言编写)，则他调用main函数的形式可能是：
exit(main(argc,argv));


7.3 进程终止
1、有8中方式使进程终止，其中5种为正常终止：
<1>从main返回(return)
<2>调用exit
<3>调用_exit或_Exit
<4>最后一个线程从启动例程返回(return)
<5>从最后一个线程调用pthread_exit

异常终止有3种方式：
<1>调用abort
<2>接到一个信号
<3>最后一个线程对取消请求做出响应

2、退出函数
3个函数用于正常终止一个程序：_exit和_Exit立即进入内核；exit则先执行一些清理处理，然后返回内核。

<1>由于历史原因，exit函数总是执行一个标准I/O库的清理关闭操作：
对于所有打开的流调用fclose函数。造成所有输出缓存中的所有数据都被冲洗(写到文件上)。

<2>3个退出函数都带一个整型参数，称为终止状态。大多数UNIX系统shell都提供检查进程终止状态的方法。(echo $?)
如果出现下面的任意一种情况，则该进程的终止状态是未定义的。
1)调用这些函数时不带终止状态；
2)main执行了一个无返回值的return；
3)main没有声明返回类型为整数。

但是，若main的返回类型是整型，并且main执行到最后一条语句时返回(隐式返回)，那么该进程的终止状态为0。//C99标准引入
编译时加上 -std=c99 选项。
(历史上，若main函数终止时没有显式使用return语句或调用exit函数，那么进程终止状态是未定义的。)

<3>main函数返回一个整型值与用该值调用exit是等价的。即exit(0)等价于return 0。

3、函数atexit
按照ISO C(ANSI C是ISO C的前生，两者都是标准C)的规定，一个进程可以登记至多32个函数，这些函数将由exit自动调用。
称这些函数为终止处理程序，并调用atexit函数来登记这些函数。
<1>函数说明
int atexit(void (*func)(void)); //成功返回0
其中，atexit的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回某个值。
exit调用这些函数的顺序和登记顺序相反。若多次登记同一个函数，也会被多次调用。

<2>根据ISO C和POSIX.1，exit首先调用各终止处理程序，然后关闭(通过fclose)所有打开流。

4、一个C程序如何启动和终止的
<1>内核使程序执行的唯一方法是调用一个exec函数。
<2>进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用_exit或_Exit。
<3>进程也可以非自愿地由一个信号使其终止。

7.4 命令行参数
1、当执行一个程序时，调用exec的进程可以将命令行参数传递给该新程序。这是UNIX shell的一部分常规操作。
2、ISO C和POSIX.1都要求argv[argc]是一个空指针。因此遍历操作可以：
for(loop=0;loop<argc;loop++)
for(loop=0;NULL!=argv[loop])

7.5 环境表
1、每个程序都接收到一张环境表。
<1>与参数表类似，环境表也是一个字符指针数组，其中每个指针包含一个C字符串的地址。
<2>全局变量environ则包含了该指针数组的地址: extern char ** environ;
称environ为环境指针，指针数组为环境表，其中各个指针指向的字符串为环境字符串。

2、通常用getenv和putenv函数来访问特定的环境变量，而不是用environ变量。
如果要看整个环境，则必须使用environ指针。

7.6 C程序的存储空间布局
1、C程序由下列部分组成：

高地址 ----------------------------------------------- 低地址

命令行参数和环境变量 -> 栈 -> 堆 -> BSS -> 初始化数据 -> 正文

对于32位Inter X86处理器，正文段从0x08048000单元开始，栈底则在0xC0000000之下开始。
(在这种特定结构中，栈从高地址向低地址方向增长)
堆顶和栈顶之间未用的虚地址空间很大。

<1>正文段。这是由CPU执行的机器指令部分。
通常正文段是可以共享的，即使是频繁执行的程序(文本编辑器、C编译器、shell等)在存储器中也只需要一个副本。
通常正文段是只读的，以防止程序由于意外而修改其指令。

<2>初始化数据段
通常将此段称为数据段，它包含了程序中需要明确初始化的全局变量。

<3>未初始化数据段
通常称为BSS段。在程序开始执行之前，内核将此段中的全局数据初始化为0或者空指针。

<4>栈
1)自动变量以及每次函数调用时所需保存的信息都存放在此段中。
2)最近被调用的函数栈上为其自动和临时变量分配存储空间。
自动变量(就是局部变量？)、临时变量(如:i++这种临时存储++后的值的？)

自动变量：auto关键字(通常省略，编译器会自动添加该关键字)
C程序是面向过程的，在C代码中会出现大量的函数模块，每个函数都有其生命周期（也称作用域），
在函数生命周期中声明的变量通常叫做局部变量，也叫自动变量。

<5>堆
通常在堆中进行动态存储分配。

2、a.out中还有若干其他类型的段，如包含符号表的段、包含调试信息的段以及包含动态共享库链接的段等。
这部分并不装载到进程执行的程序映像中。

3、未初始化数据段的内容并不存放在磁盘程序文件中。其原因是，内核在程序开始运行之前将它们都设为0。
需要存放在磁盘程序文件中段只有正文段和初始化数据段。

4、size(1)命令显示正文段、数据段、bss段的长度(以字节为单位)
$ size termination1.exe 
text    data     bss     dec     hex filename
1184     552       8    1744     6d0 termination1.exe
其中，第4、5列分别以十进制和十六进制表示3段总长度。


7.7 共享库
1、共享库使得可执行可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。
程序第一次执行(装入内存时链接？)或者第一次调用(运行时链接？)某个库函数时，用动态链接的方法将程序与共享库函数相链接。
<1>减少了每个可执行文件的长度，但增加了一些运行时间开销;
<2>可以用库函数的新版本替代老版本而无需对使用该库的程序重新连接编辑。(假设共享库函数接口不变)

2、eg
gcc -static termination1.c -Wall -g -o 1.exe
gcc termination1.c -Wall -g -o 2.exe	//gcc默认使用共享库

ls -al //发现静态链接的文件更大
size 1.exe
size 2.exe //发现使用共享库后，可执行文件的正文和数据段的长度都明显减小。

7.8 存储空间分配
1、ISO C说明了3个用于存储空间动态分配的函数：
#include <stdlib.h>
<1>void *malloc(size_t size);
分配指定字节数的存储区。此存储区的初始值不确定。
<2>void *calloc(size_t nobj, size_t size);
为指定数量指定长度的对象分配存储空间。该空间中每一位(bit)都初始化为0。
<3>void *realloc(void *ptr, size_t newsize); //newsize是存储区的新长度，若ptr为NULL，则realloc和malloc相同。
增加或减少以前分配区的长度。
1)通常用于增加存储区长度，新增区域内的初始值不确定。
2)若在原存储区后有足够的空间可扩充，则可在原存储区位置向高地址方向扩充，无需移动任何原先的内容，并返回与入参相同的指针值。
3)若在原存储区后没有足够的空间，则realloc分配另一个足够大的存储区，并将现存的内容复制到新分配的存储区。
然后释放原存储区，返回新分配的指针。
因为这种存储区可能会移动位置，所以不应当使任何指针指在该区中。

说明：
1)这三个函数，若成功返回非空指针；若失败，返回NULL。
2)这三个函数返回的指针一定是适当对齐的，使其可用于任何数据对象。
eg：如果最苛刻的对齐要求是double必须在8的倍数地址单元处开始，那么这3个函数返回的指针都应该这样对齐。

<4>void free(void *ptr);
释放ptr指向的存储空间，被释放的空间通常被送入可用存储区池。

2、这些分配例程通常用sbrk系统调用实现。该系统调用扩大或缩小进程的堆。

3、大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息(分配块的长度、指向下一个分配块的指针等)。

4、可能的错误
<1>如果超过一个已分配区的尾端或者在已分配区起始位置之前进行写操作，则会改写另一块的管理记录信息或内容。
<2>释放一个已经释放的块。
<3>忘记释放。

5、替代的存储空间分配程序

7.9 环境变量
环境字符串的形式是： name=value。内核并不查看这些字符串，它们的解释完全取决于各个应用程序。

1、ISO C定义了一个函数getenv，可以用其取环境变量值，但是该标准又称环境的内容是由实现定义的。
#include <stdlib.h>
char *getenv(const char *name); //返回指向name关联的value指针；若未找到返回NULL。

2、除了获取环境变量的值，有时也需要改变现有变量的值，或者增加新的环境变量。
<1>只能影响当前进程以及其后生成和调用的任何子进程的环境变量。
int putenv(char *str); //成功返回0,失败返回非0
取形式为name=value的字符串，将其放入环境表中。如果name已经存在，则先删除原先的定义。

int setenv(const char *name, const char *value, int rewrite);
将name设置为value。如果name已经存在：若rewrite非0,则先删除原先的定义;若rewrite为0,则不删除原先定义，也不设置为新的value。

int unsetenv(const char *name);
删除name的定义，即使不存在也不出错。

3、环境表(指向name=value字符串的指针数组)和环境字符串通常存放在进程存储空间的顶部。
<1>删除一个字符串，只需要在环境表中找到该指针，然后将所有后续指针都向环境表首部顺次移动一个位置。
<2>增加或修改字符串就困难很多。环境表和环境字符串不能再向高地址方向(顶部)扩展;
同时也不能移动在它之下的各栈帧，所以也不能向低地址方向(底部)扩展。
使得该空间长度不能增加。需要使用malloc分配存储空间。


7.10 函数setjmp和longjmp
1、在C中，goto语句不能跨越函数;而执行这种功能的是函数setjmp和longjmp。
这两个函数对于处理发生在很深层次嵌套函数调用中的出错情况是非常有用的。

7.11 函数getrlimit和setrlimit
1、每个进程都有一组资源限制，其中一些可以用getrlimit和setrlimit函数查询和更改。
#include <sys/resource.h>
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);//成功返回0,失败返回非0

struct rlimit{
    rlim_t rlim_cur;    //soft limit: current limit
    rlim_t rlim_max;    //hard limit：maximum value for rlim_cur
};

<1>进程的资源限制通常是在系统初始化时由0号进程建立的，然后由后续进程继承。

2、更改资源限制时，必须遵循下列规则：
<1>任何一个进程都可以将一个软限制值更改为小于或等于其硬限制值。
<2>任何一个进程都可以降低其硬限制值，但它必须大于或等于其软限制值。这种降低对于普通用户来说是不可逆的。
<3>只有超级用户可以提高硬限制值。

常量RLIM_INFINITY指定了一个无限量的限制。


第8章 进程控制
8.2 进程标识
1、每个进程都有一个非负整型表示的唯一进程ID。
<1>由于进程ID是惟一的，常将其用作其他标识符的一部分以保证其唯一性。
<2>虽然是唯一的，但是进程ID是可复用的。当一个进程终止后，其ID就成为复用的候选者。(大多数UNIX系统实现了延迟复用算法)
<3>系统中有一些专用进程。
1)ID为0的进程通常是调度进程，常常被称为交换进程(swapper)。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。
2)ID为1的进程通常是init进程，在自举过程结束时由内核调用。该进程的程序文件为/sbin/init。
该进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件，并将系统引导到一个状态(如多用户)。
init进程不会终止。
init进程是一个普通的用户进程，不是内核中的系统进程。它以超级用户特权运行。
init进程会成为所有孤儿进程的父进程。

UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 10:14 ?        00:00:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 21

2、每个UNIX系统实现都有它自己的一套提供操作系统服务的内核进程。
<1>某些UNIX的虚拟存储器实现中，进程ID2是页守护进程，此进程负责支持虚拟存储器系统的分页操作。

3、除了进程ID，每个进程还有一些其他标识符：
#include <unistd.h>
pid_t getpid(void);		//返回当前进程ID
pid_t getppid(void);	//返回父进程ID
uid_t getuid(void);		//返回当前进程的实际用户ID
uid_t geteuid(void);	//返回当前进程的有效用户ID
gid_t getgid(void);		//返回当前进程的实际组ID
gid_t getegid(void);	//返回当前进程的有效组ID

8.3 函数fork
1、当前进程可以调用fork函数创建一个子进程。
#include <unistd.h>
pid_t fork(void);	//返回值：子进程返回0，父进程返回子进程ID；若出错返回-1。
<1>fork函数被调用一次，但返回两次。

<2>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。
子进程获得父进程数据空间、堆、栈的副本。因此父进程和子进程并不共享这些存储空间。父进程和子进程共享正文段。

--------------------------------------------------------------------------------------------------------------------
注:
1、由于fork之后经常跟随着exec，所以现在很多实现并不执行一个父进程数据段、栈、堆的完全副本。
使用COW(Copy-On-Write，写时复制)技术作为替代，这些区域由父进程和子进程共享，而且内核将它们的访问权限设置为只读。
如果父进程和子进程中的任何一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一页。

2、全局变量对于每个进程都有独立的副本。不会互相影响。

3、疑惑：子进程为什么要拷贝父进程的数据段、栈、堆？
个人理解：例如有一个全局变量g_id1，父进程中已经赋值为10，那么创建子进程后，子进程会记住g_id1的值为10。
--------------------------------------------------------------------------------------------------------------------

<3>一般来说，在fork之后，父进程和子进程的先后执行顺序是不确定的，取决于内核所使用的调度算法。
//内核有意选择先执行子进程，因为一般子进程都会马上调用exec()函数，这样可以避免写时拷贝的额外开销。
如果先执行父进程，有可能会开始向地址空间写入。




































