第11章 线程
11.2 线程概念
1、每个线程都包含有表示执行环境所必须的信息，其中包含：
进程标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。

2、进程的所有信息对该进程的所有线程都是共享的，包括：
可执行程序的代码、程序的全局内存、堆内存、栈、文件描述符等。

//堆是所有线程共享的；栈是每个线程独立的，是线程安全的。
操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。

11.3 线程标识
1、进程ID(pid_t)是整个系统唯一的；线程ID(pthread_t)只在所属进程的上下文中才有意义。

2、线程可以通过调用pthread_self函数获取自身的线程ID。
pthread_equal函数比较两个线程ID。

11.4 线程创建
1、新增线程可以通过pthread_create函数创建。
#include <pthread.h>
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, 
void *(*start_rtm)(void *), void *restrict arg);

<1>线程创建时并不能保证哪个线程会先运行：是新创建的线程还是调用线程。
<2>新创建的线程可以访问进程的地址空间，且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。
<3>函数通过第一个参数tidp返回新建线程的线程ID。


2、eg
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

pthread_t ntid;

void printids(const char *s)
{
    pid_t pid;
    pthread_t tid;

    pid = getpid();
    tid = pthread_self();
    printf("%s pid %lu tid %lu (0x%lx)\n",
            s, (unsigned long)pid, (unsigned long)tid, (unsigned long)tid);
}

void *thr_fn(void *arg)
{
    printids("new thread: ");
    return ((void *)0);
}

int main(void)
{
    int err;
    err = pthread_create(&ntid, NULL, thr_fn, NULL);
    if(err != 0)
        printf("can not create thread!");
    printids("main thread:");
    sleep(1);
    exit(0);
}

[root@opencos apue]# ./thread1 
main thread: pid 11039 tid 139926979872576 (0x7f4349ee0740)
new thread:  pid 11039 tid 139926971586304 (0x7f43496f9700)

<1>undefined reference to ‘pthread_create’
原因：pthread不是linux下的默认的库，也就是在链接的时候，无法找到phread库中函数的入口地址，于是链接会失败。
解决：在gcc编译的时候，附加要加 -lpthread参数即可。

<2>主线程需要休眠，否则可能新线程还没有机会运行，整个进程就已经终止了。

<3>新线程通过调用pthread_self函数获取自己的线程ID，而不是从共享内存，或从线程的启动例程(pthread_create)中以参数形式获取。
本例中，主线程把新线程ID存放在ntid中，但是新线程却不能安全使用它，
因为如果新线程在主线程调用pthread_create返回之前就运行，那么ntid中的内容将是未初始化的。

11.5 线程终止
1、如果进程中的任意线程调用了exit、_EXIT、_exit，那么整个进程就会终止。

2、单个线程可以通过3中方式退出：
<1>线程可以简单地从启动例程中返回，返回值是线程的退出码；
<2>线程可以被同一进程中的其他线程取消。
<3>线程调用pthread_exit。

void pthread_exit(void *rval_ptr);

3、进程中的其他线程也可以通过pthread_join函数访问到rval_ptr。
int pthread_join(pthread_t thread, void **rval_ptr);
调用线程将一直阻塞，直到指定的线程调用pthread_exit、从启动例程中返回、被取消。
<1>如果线程简单地从启动例程返回或调用pthread_exit退出时，rval_ptr就包含退出状态；
<2>如果线程被取消，由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED。
<3>如果对线程的返回值不感兴趣，那么可以把rval_ptr设置为NULL。
这样，调用pthread_join的线程只等待线程终止，并不获取线程的终止状态。

4、eg
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

void *thr_fn1(void *arg)
{
    printf("thread 1 returning!\n");
    return ((void *)1);
}

void *thr_fn2(void *arg)
{
    printf("thread 2 exiting!\n");
    pthread_exit((void *)2);
}

int main(void)
{
    int err;
    pthread_t tid1, tid2;
    void *tret;

    err = pthread_create(&tid1, NULL, thr_fn1, NULL);
    if(0 != err)
        printf("can't create thread1!");

    err = pthread_create(&tid2, NULL, thr_fn2, NULL);
    if(0 != err)
        printf("can't create thread2!");

    err = pthread_join(tid1, &tret);
    if(0 != err)
        printf("can't join with thread1!");
    printf("thread 1 exit code is %ld.\n", (long)tret);

    err = pthread_join(tid2, &tret);
    if(0 != err)
        printf("can't join with thread2!");
    printf("thread 2 exit code is %ld.\n", (long)tret);

    exit(0);
}

[root@opencos apue]# ./thread2
thread 1 returning!
thread 2 exiting!
thread 1 exit code is 1.
thread 2 exit code is 2.

5、pthread_create和pthread_exit函数的无类型指针参数可以传递的值不止一个，这个指针可以传递复杂信息的结构地址。
但要注意，这个结构所使用的内存在调用者完成调用以后必须仍然是有效的。
eg：
<1>在调用pthread_create的线程的栈上分配了该结构，那么其他线程在使用这个结构时内存内容可能已经改变。
<2>线程在自己的栈上分配了该结构，然后把指向结构的指针传给pthread_exit，那么调用pthread_join的线程
试图使用该结构时，这个栈可能已经被撤销，内存已作他用。

为了解决这个问题，可以使用全局结构或者malloc函数分配结构。

6、线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程。
int pthread_cancel(pthread_t tid);
<1>默认情况下，pthread_cancel函数会使得由tid标识的线程的行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit函数。
<2>pthread_cancel并不等待线程终止，只是提出请求。

7、线程可以安排它退出时需要调用的函数，这与进程在退出时可以用atexit函数安排退出是类似的。
<1>这样的函数成为线程清理处理程序。
<2>一个线程可以建立多个清理处理程序。处理程序记录在栈中，执行顺序与注册顺序相反。
void pthread_cleanup_push(void (*rtm)(void *), void *arg);
void pthread_cleanup_pop(int execute);

8、默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。
如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被收回。
在线程被分离后，我们不能用pthread_join函数等待它的状态，此时会产生未定义行为。

<1>可以调用pthread_detach分离线程。
int pthread_detach(pthread_t tid);
也可以通过pthread_create设置线程属性，创建一个处于分离状态的线程。

11.6 线程同步
1、互斥量(mutex)
通过pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。
<1>互斥量本质上是一把锁，在访问共享资源之前对互斥量进行设置(即加锁)，访问完成后释放(解锁)互斥量。
<2>对互斥量加锁后，任何其他试图再次对互斥量加锁的线程都会被阻塞，直到当前线程释放该互斥锁。

2、互斥变量用pthread_mutex_t数据类型表示。使用互斥变量之前，必须首先对它进行初始化。
<1>可以把它设置为常量PTHREAD_MUTEX_INITIALIZER(只是用于静态分配的互斥量)；
<2>也可以通过调用pthread_mutex_init函数进行初始化；
<3>如果动态分配互斥量(如malloc)，在释放内存前需要调用pthread_mutex_destory。

3、对互斥量进行加锁，需要调用pthread_mutex_lock;
<1>如果线程不希望被阻塞，可以使用pthread_mutex_trylock尝试对互斥量进行加锁。
<2>对互斥量进行解锁，需要调用pthread_mutex_unlock。   































