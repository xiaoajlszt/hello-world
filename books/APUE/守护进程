一、守护进程及其特性
守护进程最重要的特性是后台运行；
其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符，控制终端，会话和进程组，工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的父进程（特别是shell）中继承下来的；
最后，守护进程的启动方式有其特殊之处------它可以在Linux系统启动时从启动脚本/etc/rc.d中启动，可以由作业规划进程crond启动，还可以由用户终端（通常是shell）执行。

总之，除开这些特殊性以外，守护进程与普通进程基本上没有什么区别，因此，编写守护进程实际上是把一个普通进程按照上述的守护进程的特性改造成为守护进程。

二、守护进程的编程要点
1. 在后台运行
为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。
if(pid=fork()) exit(0); //是父进程，结束父进程，子进程继续

2. 脱离控制终端，登录会话和进程组
有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。
登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。 
控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们 ，使之不受它们的影响。

方法是在第1点的基础上，调用setsid()使进程成为会话组长：
setsid();

nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。
setsid 就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息：
SETSID(8)                 Linux Programmer’s Manual                 SETSID(8)

NAME
       setsid - run a program in a new session

SYNOPSIS
       setsid program [ arg ... ]

DESCRIPTION
       setsid runs a program in a new session.

说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。
setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。

3. 禁止进程重新打开控制终端
现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：
if(pid=fork()) exit(0); //结束第一子进程，第二子进程继续（第二子进程不再是会话组长）

4. 关闭打开的文件描述符
进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。
按如下方法关闭它们：
for(i=0;i 关闭打开的文件描述符close(i);

5. 改变当前工作目录
进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如/tmp
chdir("/")

6. 重设文件创建掩模
进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：
umask(0);

7. 处理SIGCHLD信号
处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时 生成子进程处理请求。
如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。
在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。
signal(SIGCHLD,SIG_IGN);

这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程。

8. 例子
#include<unistd.h> 
#include<signal.h> 
#include<sys/types.h> 
#include<sys/stat.h> 
#include<stdio.h> 
#include<stdlib.h> 

void init_daemon() 
{ 
	int pid; 
	int i; 
	if(pid = fork())exit(0);//父进程，退出 
	elseif(pid < 0)exit(1);//fork失败 /* 子进程继续执行 */ 
	setsid();//创建新的会话组，子进程成为组长，并与控制终端分离 /* 防止子进程（组长）获取控制终端 */ 
	if(pid = fork())exit(0);//父进程，退出 
	elseif(pid < 0)exit(1);//fork错误，退出 /* 第二子进程继续执行 , 第二子进程不再是会会话组组长*/ 
	for(i = 0; i < NOFILE; i++)/* 关闭打开的文件描述符 */ 
	{ close(i); } 
	chdir("/tmp");/* 切换工作目录 */ 
	umask(0);/* 重设文件创建掩码 */ 
	return; 
}

int main() 
{ 
	FILE*fp; 
	signal(SIGCHLD,SIG_IGN);/* 忽略子进程结束信号，防止出现僵尸进程 */ 
	init_daemon(); 
	while(1) 
	{ 
		sleep(30); 
		if((fp =fopen("test.log","a"))!=NULL) 
		{ 
			fprintf(fp,"%s\n","test message"); 
			fclose(fp); 
		} 
	} 
	
	return 0; 
} 