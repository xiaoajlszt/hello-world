第一章 简介

一、基本概念
1、socket一词翻译为"套接口"更为准确。
首先，作为网络编程API之一的套接口(sockets,始终用复数)跟XTI一样，是应用层到传输层或其他协议层的访问接口。
其次，具体使用的套接口是与Unix管道的某一端类似的东西，我们既可以往这个口写数据，也可以从这个口读数据。
最后，套接口函数使用套接口描述字(discriptor)访问具体的套接口，如果把套接口描述字的简称sockfd翻译成"套接字"倒比较合理。
从这个意义上看，一个套接口可以对应多个套接字，因为Unix的描述字既可以复制，也可以继承；
                一个套接字只能对应一个套接口。

但sockets广泛被翻译为套接字，相应地descriptor被翻译为描述符。

2、套接字编程接口是从顶上三层(会话层、表示层、应用层)进入传输层的接口。
<1>顶上三层处理具体的网络应用(FTP\Telnet\HATT等)的所有细节，却对通信细节了解很少；
   底下四层对具体网络应用了解不多，却处理所有通信细节(发送数据、等待确认、数据排序等)。
<2>顶上三层通常构成所谓的用户进程；底下四层通常作为操作系统内核的一部分提供。

由此可见，第4层和第5层之间的接口是构建API的自然位置。

3、TCP套接字是TCP端点(TCP endpoint)的同义词。

4、全双工、半双工、单工
<1>全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。
<2>半双工，指可以分时进行信号的双向传输（A→B或B→A）。指A→B时，不能B→A；B→A时，不能A→B。即数据发送和数据接受是分时进行的。（汽车的单边放行）
<3>单工，只允许A→B传送信息，而不能B→A传送 。（汽车的单行道）

二、套接字地址结构 --每个协议族都定义了自己的套接字地址结构，这些结构均以sockaddr_开头
1、sockaddr/SA  //通用套接字地址结构
#define SA   struct sockaddr
每当一个套接字函数需要一个指向某个套接字地址结构的指针时，这个指针必须强制转化为一个指向通用套接字地址结构的指针。

2、sockaddr_in  //IPv4套接字地址结构，也称为网际套接字地址结构

三、套接字API
1、int socket(int family, int type, int protocol)
family:指明协议族(协议域)
type:套接字类型
protocol：协议类型常值，若设为0表示选择所设定family和type组合的系统默认值
函数成功返回一个小的非负整数值，与文件描述符类似，称之为套接字描述符。以后所有函数调用(如：connect、read等)就用该描述符来标识这个套接字。

eg：sockfd = socket(AF_INET,SOCK_STREAM,0)
创建一个网际(AF_INET)字节流(SOCK_STREAM)套接字，它是TCP套接字的花哨名字。

2、int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)
sockfd：是由socket函数返回的套接字描述符
servaddr：指向套接字地址结构的指针
addrlen：套接字地址结构的大小

connect函数成功返回0，失败返回-1。

3、int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)
myaddr:指向特定协议的地址结构的指针
addrlen：该地址结构的长度

bind函数把本地协议地址赋予一个套接字（32位的IPv4、128位的IPv6、16位的TCP/UDP端口号）
对于TCP，调用bind函数可以指定一个端口号，或者指定一个IP地址，也可都指定，都不指定。
<1>服务器在启动时捆绑它们总所周知的端口。如果一个TCP客户端或服务器未曾调用bind捆绑到一个端口，当调用connect或listen时，内核就要为相应的套接字选择一个临时端口。
<2>对于TCP客户端表示指派发送数据报的源IP地址；对于TCP服务器表示限制该套接字只接收那些目的地为这个IP地址的客户连接。
<3>通配地址INADDR_ANY(0)

四、转换函数
1、htons //主机到网络 短整数
将端口号转换为网络字节序二进制

五、地址转换函数（ASCII字符串与网络字节序之间转换网际地址）
1、在点分十进制数串与它长度为32位的网络字节序二进制值间转换IPv4地址：
<1>int inet_aton(const char *strptr, struct in_addr *addrptr)//若字符串有效返回1，否则返回0
将strptr所指向的点分十进制C字符串转换成一个32位的网络字节序二进制

<2>char *inet_ntoa(struct in_addr inaddr)//返回指向一个点分十进制数串的指针

<3>in_addr_t inet_addr(const char *strptr)//若字符串有效则返回32位二进制网路字节序IPv4地址，否则返回INADDR_NONE
与inet_aton进行相同转换，该函数已经被废弃，使用inet_aton替代。

2、在点分十进制数串与它长度为32位的网络字节序二进制值间转换IPv4\IPv6地址
<1>int inet_pton(int family, const char *strptr, void *addrptr)//成功1，格式错误0，出错-1
点分十进制字符串->网络字节序二进制

<2>const char *inet_ntop(int family, void *addrptr, char *strptr, size_t len)//成功返回指向结果的指针，出错NULL
网络字节序二进制->点分十进制字符串


第二章 传输层
一、UDP 用户数据报协议
1、UDP是一个简单的传输层协议。应用程序往UDP套接字写入一个消息，该消息随后被封装(encapsulating)到一个UDP数据报，
该数据报又被封装到一个IP数据报，然后发送到目的地。

2、使用UDP进行网络编程所遇到的问题是它缺乏可靠性。
想要确保一个数据报到达其目的地，可以往应用程序中添置一大堆特性：来自对端的确认、本端的超时与重传等。
<1>UDP不提供可靠性，UDP应用必须处理 重复、排序等情况。
<2>UDP不提供流量控制。让较快的UDP发送端以一个UDP接收端难以跟上的速率发送数据报是非常容易的。

3、每个UDP数据报都有一个长度，如果一个数据报正确到达其目的地，那么该数据报的长度将随数据一起传递给接收端应用程序。

4、UDP提供无连接(connectionless)的服务，UDP客户和服务器之间不必存在任何长期的关系。
一个UDP客户可以用同一个UDP套接字发送数据给不同的服务器；一个UDP服务器可以用同一个UDP套接字从若干客户接收数据报。

5、UDP可以是全双工的。

二、TCP 传输控制协议
1、TCP提供客户与服务器之间的连接。TCP客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接。

2、TCP还提供了可靠性。当TCP向另一端发送数据时，它要求对端返回一个确认。
如果没有收到确认，TCP就会自动重传数据并等待更长时间。再数次重传失败之后，TCP才放弃。(一般总时间为4-10分钟)
<1>TCP含有用于动态估算客户和服务器之间的往返时间(round-trip time,RTT)的算法，以便知道等待一个确认需要多少时间。
<2>TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序。
<3>分节是TCP传递给IP的数据单元，如果这些分节都顺利到达，接收端TCP将先根据分节中数据的序列号重新排序，再把结果数据传递给接收应用。
<4>接收端TCP可以丢弃重复数据。

3、TCP提供流量控制(flow control)。TCP总是告诉对端在任何时刻它一次能够从对端接收多少字节的数据，称为通告窗口(advertised window)。
<1>该窗口指出任意时刻接收缓冲区当前可用的空间，从而确保发送端发送的数据不会使接收缓冲区溢出。
<2>该窗口时刻动态变化：当接收到来自发送端的数据时，窗口大小就减小；当接收端应用从缓冲区中读取数据时，窗口大小就增大。

4、TCP链接时全双工的(full-duplex)。
在一个给定的连接上，应用可以在任何时刻在进出两个方向上，既发送数据又接收数据。
因此，TCP必须为每个数据流方向跟踪诸如序列号和通告窗口大小等状态信息。

需要的话，也可以把它转换为一个单工连接。

三、SCTP  流控制传输协议
1、SCTP在客户和服务器之间提供关联(association)，并向TCP那样给应用提供可靠性、排序、流量控制以及全双工的数据传送。
<1>SCTP支持多宿而涉及不止两个地址(单个SCTP端点能够支持多个IP地址，可以增强应对网络故障的健壮性)。因此这里使用关联而不是连接。
<2>与TCP不同，SCTP是面向消息的(message-oriented)。它提供各个记录的按序传递服务。
<3>与UDP一样，由发送端写入的每条记录的长度随数据一道传递给接收端应用。

2、SCTP可以在所关联的端点之间提供多个流，每个流各自可靠地按序递传消息。
一个流上某个消息丢失不会阻塞同一个关联其他流上消息的投递。
<1>这种做法与TCP相反，就TCP而言，在单一字节流中任何位置的字节丢失都将阻塞该连接上其后所有数据的传递。直到该丢失被修复为止。


2.6 TCP连接的建立和终止
一、三路握手
服务器必须准备好接受外来的连接。通常调用socket、bind、listen三个函数完成，称为被动打开。

1、SYN J
客户通过调用connect发起主动打开。
客户TCP发送一个SYN同步分节，告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。
通常该SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部及可能有的TCP选项。

2、SYN K, ACK J+1
服务器必须确认(ACK)客户的SYN，同时自己也发送一个SYN分节。该分节中含有服务器将在同一连接中发送的数据的初始序列号。
服务器在单个分节中发送SYN和对客户SYN的ACK。

3、ACK K+1
客户必须确认服务器的SYN。

注：因为SYN占据一个字节的序列号空间，所以每一个SYN的ACK中的确认号就是该SYN的初始序列号加1。

二、TCP选项
每个SYN可以包含多个TCP选项：
1、MSS选项 TCP_MAXSEG  -- 流量控制
发送SYN的TCP一端使用该选项通告对端它的最大分节大小(maximum segment size,MSS)，也就是它在本连接的每个TCP分节中愿意接受的最大数据量。
发送端TCP使用接收端的MSS值作为所发送分节的最大大小。 

2、窗口规模选项  SO_RCVBUF
<1>TCP连接任何一端能够通告对端的最大窗口大小是65535，因为在TCP首部中相应的字段占16位。
<2>为了有更大的窗口以获得尽可能大的吞吐量，这个新选项指定TCP首部中的通告窗口必须扩大(即左移)的位数(0~14)。
因此所提供的最大窗口接近1GB。65535*2的14次方。
<3>使用该选项的前提是TCP连接的两端都必须支持这个选项。

3、时间戳选项
<1>这个选项对于高速网络连接是必要的，它可以防止由失而复现的分组可能造成的数据损坏。
<2>它是一个较新的选项，也以类似于窗口规模选项的方式协商处理。作为网络编程人员，我们无需考虑这个选项。

三、TCP连接终止
TCP建立一个连接需要3个分节，终止一个连接则需4个分节。
1、FIN M
某个应用进程首先调用close，执行主动关闭。该端的TCP发送一个FIN分节，表示数据发送完毕。

2、ACK M+1
接收到这个FIN的对端执行被动关闭。这个FIN由TCP确认。
它的接收也作为一个文件结束符传递给接收端应用进程(放在已排队等候该应用进程接收的任何其他数据之后)，
因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。

3、FIN N
一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。

4、ACK N+1
接收到这个最终FIN的原发送端TCP确认整个FIN。

注：
1、在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的。这称为半关闭。
2、无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况下是由客户执行主动关闭的。

四、TCP状态转换图

五、观察分组
1、客户和服务器通告的MSS值可以不相同。
2、一旦建立一个连接，客户就构造一个请求并发送给服务器。
<1>服务器对客户请求的确认是伴随其应答发送的。这种做法叫做捎带(piggybacking)，通常在服务器处理请求并产生应答的时间少于200ms时发生。
<2>如果服务器需要更长的时间，那么我们将先看到确认，再看到应答。
3、终止连接时，执行主动关闭的那一端将进入TIME_WAIT状态。
4、如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答，那么使用TCP会有8个分节的开销。
<1>如果改为UDP，那么只需要交换两个分组(一个承载请求、一个承载应答)。
然而从TCP到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的细节从传输层转到UDP应用进程。
UDP需要交互的数据量少，避免了TCP连接建立和终止所需的开销。 


2.7 TIME_WAIT状态
1、主动关闭的那端会经历TIME_WAIT状态，该端点停留在这个状态的持续时间是最长分节生命期MSL的两倍。2MSL
<1>任何TCP实现都必须为MSL选择一个值(2分钟或30秒)。MSL是任何IP数据报能在因特网中存活的最长时间。
因为每个数据报含有一个称为跳限(hop limit)的8位字段，它的最大值是255，我们假设具有最大跳限(255)的分组在网络中存在的时间不可能超过MSL秒。

2、分组在网络中迷途通常是路由异常的结果。造成迷途的重复分组(或漫游的重复分组)，TCP必须正确处理这些重复分组。

3、TIME_WAIT状态的作用：
<1>可靠地实现TCP全双工连接的终止；//可能需要重传最终的ACK
<2>允许老的重复分节在网络中消逝。 //为了在相同的IP和端口之间建立新的TCP连接


2.9 端口号
1、IANA(因特网已分配数值权威机构)维护着一个端口号分配状况的清单。
<1>众所周知的端口 0-1023，这些端口由IANA分配和控制。可能的话，相同的端口号就分配给TCP、UDP、SCTP的同一给定服务。
eg：不论TCP还是UDP，端口号80都被赋予web服务器。
    支持FTP的任何TCP/IP实现都把端口号21分配给FTP服务器。
	
<2>已登记的端口 1024-49151

<3>动态或私用端口 49152-65535
临时端口

2、Unix系统有保留端口的概念，小于1024的端口。这些端口只能赋予特权用户进程的套接字。
<1>所有IANA众所周知的端口都是保留端口。分配使用这些端口的服务器必须以超级用户特权启动(如：FTP服务器)。

3、有少数客户(而不是服务器)需要一个保留端口用于客户/服务器认证。

4、套接字对
一个TCP连接的套接字对是一个定义该连接的两个端点的四元组。
<1>套接字对唯一标识一个网络上的每个TCP连接。
<2>就SCTP而言，一个关联由一组本地IP地址、一个本地端口、一组外地IP地址、一个外地端口标识。
同一个关联可能需要多个四元组标识，这些四元组的IP地址各不相同，但端口号是一样的。
<3>标识每个端点的两个值(IP和端口号)通常称为一个套接字。

2.10 TCP端口号与并发服务器
1、服务器：当服务器接收并接受某个客户连接时，它fork一个自身副本，让子进程来处理该客户的请求。
<1>需要在服务器主机上区分监听套接字和已连接套接字。
<2>已连接套接字和监听套接字使用相同的本地端口。
<3>在多宿服务器上，连接一旦建立，已连接套接字的本地地址随即填入(确定)。

2、TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定哪个端点接收某个到达的分节。
eg：服务端可能存在IP的端口号完全一样的子进程套接字。但它们对应客户的套接字不一样。

2.11 缓冲区大小及限制
影响IP数据报大小的限制：
1、IPv4数据报最大大小是65535字节，包括IPv4的首部。(其总长度字段占16位)

2、IPv6数据报最大大小是65575字节，包括40字节的IPv6首部。
	IPv6有一个特大净荷选项，它把净荷长度字段扩展到32位，不过这个选项需要MTU(最大传输单元)超过65535的数据链路提供支持。

3、许多网络有一个可由硬件规定的MTU。以太网的MTU是1500字节。
<1>IPv4要求的最小链路MTU是68字节。这允许最大的IPv4首部(20+40字节)拼接最小的片段(IPv4首部中片段偏移字段以8个字节为单位)。
<2>IPv6要求的最小链路MTU为1280字节。IPv6可以运行在MTU小于此最小值的链路上，不过需要特定于链路的分片和重组功能。使得这些链路看起来具有至少1280字节的MTU。

4、在两个主机之间的路径中最小的MTU称为路径MTU。1500字节的以太网MTU是当今常见的路径MTU。
两个主机反方向的路径MTU可以不一致，因为在因特网中路由选择往往不对称。

5、当一个IP数据报将要从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4、IPv6都会执行分片。
这些片段在达到最终目的地之前通常不会被重组。
<1>IPv4主机对其产生的数据报执行分片，IPv4路由器对其转发的数据报执行分片
<2>IPv6主机对其产生的数据报执行分片，IPv6路由器不对其转发的数据报执行分片
<3>IPv4首部的DF位若被设置，那么不管是发送这些数据报的主机还是转发它们的路由器，都不允许对他们分片。
当路由器接收到一个超过其链路MTU大小且设置了DF位的IPv4数据报时，它将产生一个ICMPv4出错消息。
<4>IPv6路由器不执行分片，每个IPv6数据报于是隐含一个DF位。
当IPv6路由器接收到一个超过其外出链路MTU大小的IPv6数据报时，它将产生一个ICMPv6出错消息。

6、IPv4的DF位和IPv6的隐含DF位可用于路径MTU发现。

7、最小重组缓冲区大小：是IPv4和IPv6的任何实现都必须保证支持的最小数据报大小。 -- 与分片相关
<1>其值对于IPv4为576字节；对于IPv6为1500字节。例如，对于IPv4，我们不能判断某个给定目的地能否接受577字节的数据报。

8、MSS(最大分节大小)：用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量。
<1>MSS的目的是告诉对端其重组缓冲区大小的实际值(重组缓冲区大小=分片的最大大小(xiao))，从而避免分片。
<2>MSS经常设置成MTU减去IP和TCP首部的固定长度。IPv4 - 1500-20-20   IPv6 - 1500-20-40
<3>MSS值是一个16位字段，限定其最大值为65535。MSS不包括TCP首部。
<4>MSS为65535时被视为表示"无限"的一个特殊值。此时它所发送数据报的大小限制就是接口MTU。

9、总结：
MSS - 传输层 TCP
最小重组缓冲区大小 - 网络层 IP
MTU - 数据链路层

一、TCP输出
1、每个TCP套接字有一个发送缓冲区，可以使用SO_SNDBUF套接字选项来更改缓冲区大小。

2、当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。
如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区；或是套接字发送缓冲区中已有其他数据)，
该应用进程被投入睡眠(假设该套接字为阻塞套接字)。此时，内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区。

3、因此，从写一个TCP套接字的write调用成功返回，仅仅表示我们可以重新使用原来的应用进程缓冲区，并不代表对端的TCP或应用进程已经收到数据。

4、本端的TCP提取套接字发送缓冲区中的数据，并把它发送给对端TCP。对端TCP必须确认收到数据，本端TCP才能从套接字缓冲区中丢弃已确认的数据。

5、本端TCP以MSS大小或更小的块把数据传递给IP，同时给每个数据块安上一个TCP首部以构成TCP分节。
其中MSS或是由对端通告的值，或是536(IPv4最小重组缓冲区字节数576 - IPv4首部字节数20 - TCP首部字节数20)。

6、IP给每个TCP分节安上一个IP首部以构成IP数据报(分组)，并按照其目的的IP地址查找路由表确定外出接口。然后把数据报传递给相应的数据链路。
<1>IP可能在把数据传递给数据链路前将其分片。不过MSS选项的目的之一就是试图避免分片。

7、每个数据链路都有一个输出队列。如果队列已满，那么新到的分组将被丢弃，并沿协议栈向上返回一个错误(从数据链路到IP再到TCP)。
TCP注意到这个错误，并在以后某个时刻重传相应的分节。应用程序并不知道这种暂时的情况。

应用程序缓冲区 - TCP套接字发送缓冲区 - MSS大小数据 - TCP分节 - 数据报(分组) - (可能需要对分组进行分片) - 数据链路输出队列

二、UDP输出
1、任何UDP套接字都有发送缓冲区大小，我们可以使用SO_SNDBUF套接字选项更改它。
<1>不过它仅仅是可以写到该套接字的UDP数据报的大小上限。它实际上并不存在。
<2>如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。
<3>因为UDP是不可靠的，它不必保存应用进程数据报的副本，因此无需一个真正的发送缓冲区。
应用进程的数据在沿协议栈向下传递时，通常被复制到某种格式的一个内核缓冲区中，然而当该数据被发送后，这个副本就被数据链路层丢弃了。

2、本端的UDP简单地给来自用户的数据报安上8个字节的首部构成UDP数据报，然后传递给IP。

3、IP给UDP数据报安上相应的IP首部构成IP数据报。执行路由操作确定外出接口，
<1>如果适合MTU，直接把数据报加入数据链路层输出队列。
<2>否则，分片后再把每个每个片段加入数据链路层的输出队列。

4、如果某个UDP应用发送大数据报，那么它们相比TCP应用数据更有可能被分片。因为TCP会把应用数据划分成MSS大小的块，UDP却没有对等的手段。

5、从写一个UDP套接字的write调用成功返回，表示所写的数据报或其所有片段已被加入数据链路层的输出队列。
如果该队列没有足够的空间，内核会返回一个ENOBUFS的错误给它的应用进程。


2.12 标准因特网服务
1、这些服务通常由Unix主机的inetd守护进程提供。
所有服务同时使用TCP和UDP提供，并且这两个协议使用的端口号相同。
2、服务名由/etc/services文件映射到对应的端口号
3、为了应付针对它们的拒绝服务攻击和其他资源使用攻击，这些简单的服务通常被禁用。


2.13 常见因特网应用的协议使用


附录 A
1、IP层提供无连接、不可靠的数据报递送服务，它会尽最大努力将IP数据报递送到指定的目的地。
<1>不保证数据报一定达到；不保证数据报达到顺序与发送顺序一致；不保证数据报只到达一次。
<2>任何期望的可靠性必须由上层提供支持。对于TCP\SCTP应用程序而言，这是由TCP\SCTP本身完成的；对于UDP应用程序而言，这得由应用程序完成。
<3>IP层最重要的功能之一是路由。每个数据报包含一个源地址和一个目的地址。

一、IPv4首部
    名称        长度       取值 
    版本         4位         4
  首部长度       4位        包含任何选项在内的整个IP首部包含32位字长的数量。因为最大取值为15，所以IP首部最大长度为15*32/8=60字节。扣除首部固定部分20字节，最多允许40字节的选项。
  服务类型(TOS)  8位        已经被替换为两个字段：6位"区分服务码点"和2位"显示拥塞通知"。可以通过IP_TOS套接字选项设置该字段。
  总长度        16位        包括IPv4首部在内的整个IP数据报的字节长度。数据报中的数据量=总长度-4*首部长度
  标识          16位        由IP模块为每个IP数据报设置成不同的值，用于分片和重组。
                            该字段必须就源IPv4地址、目的IPv4地址和协议这三个字段至少在数据报的网络存活期唯一标识每个IP数据报。
							如果分组不会被分片(如设置了DF位)，那么就不需要设置此字段。
  DF(不要分片)   1位        用于分片和重组；用于路径MTU发现	
  MF(还有片段)   1位        用于分片和重组
  片段偏移      13位        用于分片和重组
  存活时间(TTL)  8位        字段由本IP数据报的发送者设置，并由转发它的每个路由器递减(-1)。当减为0时，相应路由器就丢弃该数据报。
                            任何IP数据报的生命期限定为最多255跳。默认值是64。可通过套接字选项IP_TTL\IP_MULTICAST_TTL查询和修改这个默认值。
  协议           8位        指定包含在本IP数据报中的数据类型。1-ICMPv4  2-IGMPv4  6-TCP  17-UDP
  首部检验和    16位        只对IP首部进行计算。
  源IPv4地址    32位
 目的IPv4地址   32位
  选项          最多40字节(320位)

二、IPv6首部
1、IPv6首部固定40字节。
2、净荷长度(16位)：是IPv6首部之后所有内容的字节长度(扩展首部也计算在内)。字段值为0表示实际长度超过16位字段的表示范围。(可见不存在只含有IPv6首部的IPv6数据报)
   净荷：承载上层协议数据单元的长度。
3、下一个首部：类似于IPv4的协议字段。6-TCP  17-UDP
   一个IPv6数据报可以在其40字节的首部之后跟以多个首部。这就是本字段称为"下一个首部"而非"协议"的原因。
4、跳限(hop limit)：类似于IPv4的TTL。
5、IPv6的源地址和目的地址都是128位的。

6、与IPv4的区别
<1>IPv6采用更大的地址字段。IPv6首部更简单，首部越简单，路由器处理越快。
<2>IPv6没有首部长度字段。
<3>如果首部本身64位对齐，那么两个IPv6地址字段也在64位边界对齐。这样可以加快在64位体系结构上的处理。
   而即使在64为对齐的IPv4首部中IPv4地址字段也只是32位对齐的。
<4>IPv6首部没有其自身的校验和字段。
<5>IPv6没有广播。对于IPv4是可选的多播却是IPv6的一个组成部分。向子网中所有系统发送数据报的任务是由全节点多播组处理的。
<6>IPv6路由器不对所转发的分组执行分片。如果不经分片无法转发某个分组，路由器就丢弃该分组，同时向其源头发送一个ICMPv6错误。
	IPv6的分片只发生在IPv6数据报的源头主机上。
<7>IPv6要求支持路径MTU发现功能。如果某个节点没有实现这个功能，它就不能发送超过IPv6最小链路MTU(1280字节)的数据报。
<8>IPv6要求支持认证和安全选项。这些选项出现在固定首部之后。















