第一章 简介

一、基本概念
1、socket一词翻译为"套接口"更为准确。
首先，作为网络编程API之一的套接口(sockets,始终用复数)跟XTI一样，是应用层到传输层或其他协议层的访问接口。
其次，具体使用的套接口是与Unix管道的某一端类似的东西，我们既可以往这个口写数据，也可以从这个口读数据。
最后，套接口函数使用套接口描述字(discriptor)访问具体的套接口，如果把套接口描述字的简称sockfd翻译成"套接字"倒比较合理。
从这个意义上看，一个套接口可以对应多个套接字，因为Unix的描述字既可以复制，也可以继承；
                一个套接字只能对应一个套接口。

但sockets广泛被翻译为套接字，相应地descriptor被翻译为描述符。

2、套接字编程接口是从顶上三层(会话层、表示层、应用层)进入传输层的接口。
<1>顶上三层处理具体的网络应用(FTP\Telnet\HATT等)的所有细节，却对通信细节了解很少；
   底下四层对具体网络应用了解不多，却处理所有通信细节(发送数据、等待确认、数据排序等)。
<2>顶上三层通常构成所谓的用户进程；底下四层通常作为操作系统内核的一部分提供。

由此可见，第4层和第5层之间的接口是构建API的自然位置。

3、TCP套接字是TCP端点(TCP endpoint)的同义词。

二、套接字地址结构 --每个协议族都定义了自己的套接字地址结构，这些结构均以sockaddr_开头
1、sockaddr/SA  //通用套接字地址结构
#define SA   struct sockaddr
每当一个套接字函数需要一个指向某个套接字地址结构的指针时，这个指针必须强制转化为一个指向通用套接字地址结构的指针。

2、sockaddr_in  //IPv4套接字地址结构，也称为网际套接字地址结构

三、套接字API
1、int socket(int family, int type, int protocol)
family:指明协议族(协议域)
type:套接字类型
protocol：协议类型常值，若设为0表示选择所设定family和type组合的系统默认值
函数成功返回一个小的非负整数值，与文件描述符类似，称之为套接字描述符。以后所有函数调用(如：connect、read等)就用该描述符来标识这个套接字。

eg：sockfd = socket(AF_INET,SOCK_STREAM,0)
创建一个网际(AF_INET)字节流(SOCK_STREAM)套接字，它是TCP套接字的花哨名字。

2、int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)
sockfd：是由socket函数返回的套接字描述符
servaddr：指向套接字地址结构的指针
addrlen：套接字地址结构的大小

connect函数成功返回0，失败返回-1。

3、int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)
myaddr:指向特定协议的地址结构的指针
addrlen：该地址结构的长度

bind函数把本地协议地址赋予一个套接字（32位的IPv4、128位的IPv6、16位的TCP/UDP端口号）
对于TCP，调用bind函数可以指定一个端口号，或者指定一个IP地址，也可都指定，都不指定。
<1>服务器在启动时捆绑它们总所周知的端口。如果一个TCP客户端或服务器未曾调用bind捆绑到一个端口，当调用connect或listen时，内核就要为相应的套接字选择一个临时端口。
<2>对于TCP客户端表示指派发送数据报的源IP地址；对于TCP服务器表示限制该套接字只接收那些目的地为这个IP地址的客户连接。
<3>通配地址INADDR_ANY(0)

四、转换函数
1、htons //主机到网络 短整数
将端口号转换为网络字节序二进制

五、地址转换函数（ASCII字符串与网络字节序之间转换网际地址）
1、在点分十进制数串与它长度为32位的网络字节序二进制值间转换IPv4地址：
<1>int inet_aton(const char *strptr, struct in_addr *addrptr)//若字符串有效返回1，否则返回0
将strptr所指向的点分十进制C字符串转换成一个32位的网络字节序二进制

<2>char *inet_ntoa(struct in_addr inaddr)//返回指向一个点分十进制数串的指针

<3>in_addr_t inet_addr(const char *strptr)//若字符串有效则返回32位二进制网路字节序IPv4地址，否则返回INADDR_NONE
与inet_aton进行相同转换，该函数已经被废弃，使用inet_aton替代。

2、在点分十进制数串与它长度为32位的网络字节序二进制值间转换IPv4\IPv6地址
<1>int inet_pton(int family, const char *strptr, void *addrptr)//成功1，格式错误0，出错-1
点分十进制字符串->网络字节序二进制

<2>const char *inet_ntop(int family, void *addrptr, char *strptr, size_t len)//成功返回指向结果的指针，出错NULL
网络字节序二进制->点分十进制字符串


第二章 传输层
一、UDP 用户数据报协议
1、UDP是一个简单的传输层协议。应用程序往UDP套接字写入一个消息，该消息随后被封装(encapsulating)到一个UDP数据报，
该数据报又被封装到一个IP数据报，然后发送到目的地。

2、使用UDP进行网络编程所遇到的问题是它缺乏可靠性。
想要确保一个数据报到达其目的地，可以往应用程序中添置一大堆特性：来自对端的确认、本端的超时与重传等。
<1>UDP不提供可靠性，UDP应用必须处理 重复、排序等情况。
<2>UDP不提供流量控制。让较快的UDP发送端以一个UDP接收端难以跟上的速率发送数据报是非常容易的。

3、每个UDP数据报都有一个长度，如果一个数据报正确到达其目的地，那么该数据报的长度将随数据一起传递给接收端应用程序。

4、UDP提供无连接(connectionless)的服务，UDP客户和服务器之间不必存在任何长期的关系。
一个UDP客户可以用同一个UDP套接字发送数据给不同的服务器；一个UDP服务器可以用同一个UDP套接字从若干客户接收数据报。

5、UDP可以是全双工的。

二、TCP 传输控制协议
1、TCP提供客户与服务器之间的连接。TCP客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接。

2、TCP还提供了可靠性。当TCP向另一端发送数据时，它要求对端返回一个确认。
如果没有收到确认，TCP就会自动重传数据并等待更长时间。再数次重传失败之后，TCP才放弃。(一般总时间为4-10分钟)
<1>TCP含有用于动态估算客户和服务器之间的往返时间(round-trip time,RTT)的算法，以便知道等待一个确认需要多少时间。
<2>TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序。
<3>分节是TCP传递给IP的数据单元，如果这些分节都顺利到达，接收端TCP将先根据分节中数据的序列号重新排序，再把结果数据传递给接收应用。
<4>接收端TCP可以丢弃重复数据。

3、TCP提供流量控制(flow control)。TCP总是告诉对端在任何时刻它一次能够从对端接收多少字节的数据，称为通告窗口(advertised window)。
<1>该窗口指出任意时刻接收缓冲区当前可用的空间，从而确保发送端发送的数据不会使接收缓冲区溢出。
<2>该窗口时刻动态变化：当接收到来自发送端的数据时，窗口大小就减小；当接收端应用从缓冲区中读取数据时，窗口大小就增大。

4、TCP链接时全双工的(full-duplex)。
在一个给定的连接上，应用可以在任何时刻在进出两个方向上，既发送数据又接收数据。
因此，TCP必须为每个数据流方向跟踪诸如序列号和通告窗口大小等状态信息。

需要的话，也可以把它转换为一个单工连接。

三、SCTP  流控制传输协议
1、SCTP在客户和服务器之间提供关联(association)，并向TCP那样给应用提供可靠性、排序、流量控制以及全双工的数据传送。
<1>SCTP支持多宿而涉及不止两个地址(单个SCTP端点能够支持多个IP地址，可以增强应对网络故障的健壮性)。因此这里使用关联而不是连接。
<2>与TCP不同，SCTP是面向消息的(message-oriented)。它提供各个记录的按序传递服务。
<3>与UDP一样，由发送端写入的每条记录的长度随数据一道传递给接收端应用。

2、SCTP可以在所关联的端点之间提供多个流，每个流各自可靠地按序递传消息。
一个流上某个消息丢失不会阻塞同一个关联其他流上消息的投递。
<1>这种做法与TCP相反，就TCP而言，在单一字节流中任何位置的字节丢失都将阻塞该连接上其后所有数据的传递。直到该丢失被修复为止。


2.6 TCP连接的建立和终止
一、三路握手
服务器必须准备好接受外来的连接。通常调用socket、bind、listen三个函数完成，称为被动打开。

1、SYN J
客户通过调用connect发起主动打开。
客户TCP发送一个SYN同步分节，告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。
通常该SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部及可能有的TCP选项。

2、SYN K, ACK J+1
服务器必须确认(ACK)客户的SYN，同时自己也发送一个SYN分节。该分节中含有服务器将在同一连接中发送的数据的初始序列号。
服务器在单个分节中发送SYN和对客户SYN的ACK。

3、ACK K+1
客户必须确认服务器的SYN。

注：因为SYN占据一个字节的序列号空间，所以每一个SYN的ACK中的确认号就是该SYN的初始序列号加1。

二、TCP选项
每个SYN可以包含多个TCP选项：
1、MSS选项 TCP_MAXSEG
发送SYN的TCP一端使用该选项通告对端它的最大分节大小(maximum segment size,MSS)，也就是它在本连接的每个TCP分节中愿意接受的最大数据量。
发送端TCP使用接收端的MSS值作为所发送分节的最大大小。 

2、窗口规模选项  SO_RCVBUF
<1>TCP连接任何一端能够通告对端的最大窗口大小是65535，因为在TCP首部中响应的字段占16位。
<2>为了有更大的窗口以获得尽可能大的吞吐量，这个新选项指定TCP首部中的通告窗口必须扩大(即左移)的位数(0~14)。
因此所提供的最大窗口接近1GB。65535*2的14次方。
<3>使用该选项的前提是TCP连接的两端都必须支持这个选项。

3、时间戳选项
<1>这个选项对于高速网络连接是必要的，它可以防止由失而复现的分组可能造成的数据损坏。
<2>它是一个较新的选项，也以类似于窗口规模选项的方式协商处理。作为网络编程人员，我们无需考虑这个选项。

三、TCP连接终止
TCP建立一个连接需要3个分节，终止一个连接则需4个分节。
1、FIN M
某个应用进程首先调用close，执行主动关闭。该端的TCP发送一个FIN分节，表示数据发送完毕。

2、ACK M+1
接收到这个FIN的对端执行被动关闭。这个FIN由TCP确认。
它的接收也作为一个文件结束符传递给接收端应用进程(放在已排队等候该应用进程接收的任何其他数据之后)，
因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。

3、FIN N
一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。

4、ACK N+1
接收到这个最终FIN的原发送端TCP确认整个FIN。

注：
1、在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的。这称为半关闭。
2、无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况下是由客户执行主动关闭的。

四、TCP状态转换图

五、观察分组
1、客户和服务器通告的MSS值可以不相同。
2、一旦建立一个连接，客户就构造一个请求并发送给服务器。
<1>服务器对客户请求的确认是伴随其应答发送的。这种做法叫做捎带(piggybacking)，通常在服务器处理请求并产生应答的时间少于200ms时发生。
<2>如果服务器需要更长的时间，那么我们将先看到确认，再看到应答。
3、终止连接时，执行主动关闭的那一端将进入TIME_WAIT状态。
4、如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答，那么使用TCP会有8个分节的开销。
<1>如果改为UDP，那么只需要交换两个分组(一个承载请求、一个承载应答)。
然而从TCP到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的细节从传输层转到UDP应用进程。
UDP需要交互的数据量少，避免了TCP连接建立和终止所需的开销。 


2.7 TIME_WAIT状态
1、主动关闭的那端会经历TIME_WAIT状态，该端点停留在这个状态的持续时间是最长分节生命期MSL的两倍。2MSL
<1>任何TCP实现都必须为MSL选择一个值(2分钟或30秒)。MSL是任何IP数据报能在因特网中存活的最长时间。
因为每个数据报含有一个称为跳限(hop limit)的8位字段，它的最大值是255，我们假设具有最大跳限(255)的分组在网络中存在的时间不可能超过MSL秒。

2、分组在网络中迷途通常是路由异常的结果。造成迷途的重复分组(或漫游的重复分组)，TCP必须正确处理这些重复分组。

3、TIME_WAIT状态的作用：
<1>可靠地实现TCP全双工连接的终止；//可能需要重传最终的ACK
<2>允许老的重复分节在网络中消逝。 //为了在相同的IP和端口之间建立新的TCP连接


2.9 端口号
 
































