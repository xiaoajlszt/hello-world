4.1 简介/动机
1、使用多线程编程，以及类似Queue的共享数据结构，这个编程任务可以规划成几个执行特定函数的线程。
<1>UserRequestThread:负责读取客户端输入。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中。
<2>RequestProcessor:该线程负责从队列中获取请求并进行处理，为第三个线程提供输入。
<3>ReplyThread:负责向用户输出，将结果传回给用户(如果是网络应用)了；或者把数据写到本地文件系统或数据库中。

4.2 线程和进程
1、由于每个进程都拥有自己的内存和数据栈等，所以只能采用进程间通信(IPC)的方式共享信息。

2、线程在同一个进程下执行，共享相同的上下文。
<1>某个线程运行时，它可以被抢占(中断)和临时挂起(睡眠)，这种做法叫做让步(yielding)。
<2>两个或多个线程访问同一片数据，由于数据访问顺序不同，可能导致结果不一致。这种情况通常称为竞争条件。

4.3 线程和Python
1、全局解释器锁
<1>Python代码的执行是由Python虚拟机（解释器主循环）进行控制的。
1)在主循环中任一时刻只能有一个控制线程在执行。
尽管Python解释器中可以运行多个线程，但是在任意给定时刻只有一个线程会被解释器执行。

<2>对Python虚拟机的访问是由全局解释器锁(GIL)控制的。这个锁就是用来保证同时只能有一个线程运行的。
1)I/O密集型的Python程序要比计算密集型的代码更好地利用多线程环境。

/*************************************************************************************/
http://www.cnblogs.com/webber1992/p/6209338.html  //多核CPU使用python多线程是鸡肋！！！

在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。推荐使用多进程：
每个进程有各自独立的GIL，互不干扰，这样在多核CPU下就可以真正意义上的并行执行，
所以在python中，多核CPU时，多进程的执行效率优于多线程。        
/*************************************************************************************/

2、退出线程
<1>退出函数
当一个线程完成函数的执行时就会退出。此外还可以调用如下方法退出：
thread.exit() //退出线程
sys.exit()	  //退出进程
SystemExit    //抛出异常

<2>thread模块
主线程退出之后，所有其他线程都会在没有清理的情况下直接退出。

<3>threading模块
会确保所有重要的子线程退出前，保持整个进程的存活。

<4>主线程应该做一个好的管理者，负责了解每个单独线程需要执行什么，每个派生的线程需要哪些数据或参数，
这些线程执行完成后会提供什么结果。这样，主线程就可以收集每个线程的结果，然后汇总成一个有意义的最终结果。

3、在Python中使用线程
<1>python虽然支持多线程编程，但还是需要取决于它所允许的操作系统。
<2>python使用兼容POSIX的线程，也就是众所周知的pthread。

4、不使用线程的情况

5、Python的threading模块
<1>Python提供了多个模块支持多线程编程，包括thread、threading、Queue模块等。
thread-提供了基本的线程和锁定支持
threading-提供了更高级别、功能更全面的线程管理
queue-可以创建一个队列数据结构，用于在多线程之间进行共享。

<2>推荐使用更高级别的threading模块，而不使用thread模块。
1)其中一个重要原因是thread对进程何时退出没有控制，当主线程结束时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理；
threading能确保重要的子线程在进程退出前结束。thread模块在python中被重命名为_thread。

2)另一个原因是thread模块不支持守护线程。
当主线程退出时，所有子线程都将终止。需要引入守护线程阻止这种情况发生。

threading模块支持守护线程。守护线程一般是一个等待客户端请求服务的服务器。如果没有客户端请求，守护线程就是空闲的。
如果把一个线程设置为守护线程，表示该线程是不重要的，进程退出时不需要等待这个线程执行完成。
如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。
thread.daemon = True
一个新的子线程会继承父线程的守护标记。整个Python程序(可理解为主线程)将在所有非守护线程退出后才退出。

4.4 thread模块
1、除了派生线程外，thread模块还提供了基本的同步数据结构，
称为锁对象（lock object，也叫原语锁、简单锁、互斥锁、互斥和二进制信号量）。

2、thread模块的函数
<1>start_new_thread(function,args,kwargs=None) //派生一个新的线程，使用给定的args和可选的kwargs来执行function
即使function函数不需要参数，args也要传递一个空元组()。
<2>allocate_lock()  //分配LockType锁对象
<3>exit()  			//退出线程指令

3、LockType锁对象的方法
acquire(wait=None)  尝试获取锁对象
locked()            如果当前锁正在被占用则返回True，否则返回False。
release()           释放锁

4、示例4-3 使用线程和锁(mtsleepB.py)
<1>调用sleep()作为同步机制 -> 引入锁作为同步机制
保证主线程等待子线程全部完成后再接着执行。

<2>每个线程被分配一个已获得的锁，当sleep()时间到达时，释放对应的锁，向主线程表明该线程已经完成。

5、多线程应用程序编程应当使用更高级别的模块，比如threading模块。

4.5 threading模块
除了Thread类以外，该模块还包括许多非常好用的同步机制。

1、Thread类  //表示一个执行线程的对象
<1>Thread对象数据属性
name	线程名
ident	线程标识符
daemon	是否为守护线程

<2>Thread对象方法
_init_		实例化一个线程对象
_init_(group=None, target=None, name=None, args=(), kwargs={}, verbose=None, daemon=None)
start()		开始执行该线程
run()		定义线程功能的方法(通常在子类中被应用开发者重写)
join(timeout=None)	直至启动的线程终止之前一直挂起，除非给出了timeout(秒)
getName()	返回线程名			//弃用，直接操作属性
setName(name)	设定线程名		//弃用，直接操作属性
isAlivel/is_alive()	线程是否存活	//驼峰式isAlivel 2.6已经弃用
isDaemon()	是否为守护线程      //弃用，直接操作属性
setDaemon(deamonic)	把线程的守护标识设置为布尔值daemonic，必须在线程start之前调用 //弃用，直接操作属性

<3>使用Thread类创建线程
- 创建Thread的实例，传给它一个函数     //Thread类实例化时，传递给它一个函数、参数
- 创建Thread的实例，传给它一个可调用的类实例	//Thread类实例化时，传递给它一个类对象(类实例)
- 派生Thread的子类，并创建子类的实例 (推荐)
//MyThread子类构造函数必须先调用其基类的构造函数。MyThread类中改写run()方法。

2、threading模块的其他函数
active_count()		当前活动的Thread对象个数
current_thread()	返回当前的Thread对象
enumerate()			返回当前活动的Thread对象列表
settrace(func)		为所有线程设置一个trace函数
setprofile(func)	为所有线程设置一个profile函数
stack_size(size=0)	返回新创建线程的栈大小；或为后续创建的线程设定栈的大小为size

4.6 单线程和多线程执行对比
























