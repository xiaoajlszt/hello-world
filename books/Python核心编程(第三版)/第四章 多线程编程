4.1 简介/动机
1、使用多线程编程，以及类似Queue的共享数据结构，这个编程任务可以规划成几个执行特定函数的线程。
<1>UserRequestThread:负责读取客户端输入。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中。
<2>RequestProcessor:该线程负责从队列中获取请求并进行处理，为第三个线程提供输入。
<3>ReplyThread:负责向用户输出，将结果传回给用户(如果是网络应用)了；或者把数据写到本地文件系统或数据库中。

4.2 线程和进程
1、由于每个进程都拥有自己的内存和数据栈等，所以只能采用进程间通信(IPC)的方式共享信息。

2、线程在同一个进程下执行，共享相同的上下文。
<1>某个线程运行时，它可以被抢占(中断)和临时挂起(睡眠)，这种做法叫做让步(yielding)。
<2>两个或多个线程访问同一片数据，由于数据访问顺序不同，可能导致结果不一致。这种情况通常称为竞争条件。

4.3 线程和Python
1、全局解释器锁
<1>Python代码的执行是由Python虚拟机（解释器主循环）进行控制的。
1)在主循环中任一时刻只能有一个控制线程在执行。
尽管Python解释器中可以运行多个线程，但是在任意给定时刻只有一个线程会被解释器执行。

<2>对Python虚拟机的访问是由全局解释器锁(GIL)控制的。这个锁就是用来保证同时只能有一个线程运行的。
1)I/O密集型的Python程序要比计算密集型的代码更好地利用多线程环境。

/*************************************************************************************/
http://www.cnblogs.com/webber1992/p/6209338.html  //多核CPU使用python多线程是鸡肋！！！

在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。推荐使用多进程：
每个进程有各自独立的GIL，互不干扰，这样在多核CPU下就可以真正意义上的并行执行，
所以在python中，多核CPU时，多进程的执行效率优于多线程。        
/*************************************************************************************/

2、退出线程
<1>退出函数
当一个线程完成函数的执行时就会退出。此外还可以调用如下方法退出：
thread.exit() //退出线程
sys.exit()	  //退出进程
SystemExit    //抛出异常

<2>thread模块
主线程退出之后，所有其他线程都会在没有清理的情况下直接退出。

<3>threading模块
会确保所有重要的子线程退出前，保持整个进程的存活。

<4>主线程应该做一个好的管理者，负责了解每个单独线程需要执行什么，每个派生的线程需要哪些数据或参数，
这些线程执行完成后会提供什么结果。这样，主线程就可以收集每个线程的结果，然后汇总成一个有意义的最终结果。

3、在Python中使用线程
<1>python虽然支持多线程编程，但还是需要取决于它所允许的操作系统。
<2>python使用兼容POSIX的线程，也就是众所周知的pthread。

4、不使用线程的情况

5、Python的threading模块
<1>Python提供了多个模块支持多线程编程，包括thread、threading、Queue模块等。
thread-提供了基本的线程和锁定支持
threading-提供了更高级别、功能更全面的线程管理
queue-可以创建一个队列数据结构，用于在多线程之间进行共享。

<2>推荐使用更高级别的threading模块，而不使用thread模块。
1)其中一个重要原因是thread对进程何时退出没有控制，当主线程结束时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理；
threading能确保重要的子线程在进程退出前结束。thread模块在python中被重命名为_thread。

2)另一个原因是thread模块不支持守护线程。
当主线程退出时，所有子线程都将终止。需要引入守护线程阻止这种情况发生。

threading模块支持守护线程。守护线程一般是一个等待客户端请求服务的服务器。如果没有客户端请求，守护线程就是空闲的。
如果把一个线程设置为守护线程，表示该线程是不重要的，进程退出时不需要等待这个线程执行完成。
如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。
thread.daemon = True
一个新的子线程会继承父线程的守护标记。整个Python程序(可理解为主线程)将在所有非守护线程退出后才退出。

4.4 thread模块
1、除了派生线程外，thread模块还提供了基本的同步数据结构，
称为锁对象（lock object，也叫原语锁、简单锁、互斥锁、互斥和二进制信号量）。

2、thread模块的函数
<1>start_new_thread(function,args,kwargs=None) //派生一个新的线程，使用给定的args和可选的kwargs来执行function
即使function函数不需要参数，args也要传递一个空元组()。
<2>allocate_lock()  //分配LockType锁对象
<3>exit()  			//退出线程指令

3、LockType锁对象的方法
acquire(wait=None)  尝试获取锁对象
locked()            如果当前锁正在被占用则返回True，否则返回False。
release()           释放锁

4、示例4-3 使用线程和锁(mtsleepB.py)
<1>调用sleep()作为同步机制 -> 引入锁作为同步机制
保证主线程等待子线程全部完成后再接着执行。

<2>每个线程被分配一个已获得的锁，当sleep()时间到达时，释放对应的锁，向主线程表明该线程已经完成。

5、多线程应用程序编程应当使用更高级别的模块，比如threading模块。

4.5 threading模块
除了Thread类以外，该模块还包括许多非常好用的同步机制。

1、Thread类  //表示一个执行线程的对象
<1>Thread对象数据属性
name	线程名
ident	线程标识符
daemon	是否为守护线程

<2>Thread对象方法
_init_		实例化一个线程对象
_init_(group=None, target=None, name=None, args=(), kwargs={}, verbose=None, daemon=None)
start()		开始执行该线程
run()		定义线程功能的方法(通常在子类中被应用开发者重写)
join(timeout=None)	直至启动的线程终止之前一直挂起，除非给出了timeout(秒)
getName()	返回线程名			//弃用，直接操作属性
setName(name)	设定线程名		//弃用，直接操作属性
isAlivel/is_alive()	线程是否存活	//驼峰式isAlivel 2.6已经弃用
isDaemon()	是否为守护线程      //弃用，直接操作属性
setDaemon(deamonic)	把线程的守护标识设置为布尔值daemonic，必须在线程start之前调用 //弃用，直接操作属性

<3>使用Thread类创建线程
- 创建Thread的实例，传给它一个函数     //Thread类实例化时，传递给它一个函数、参数
- 创建Thread的实例，传给它一个可调用的类实例	//Thread类实例化时，传递给它一个类对象(类实例)
- 派生Thread的子类，并创建子类的实例 (推荐)
//MyThread子类构造函数必须先调用其基类的构造函数。MyThread类中改写run()方法。

2、threading模块的其他函数
active_count()		当前活动的Thread对象个数
current_thread()	返回当前的Thread对象
enumerate()			返回当前活动的Thread对象列表
settrace(func)		为所有线程设置一个trace函数
setprofile(func)	为所有线程设置一个profile函数
stack_size(size=0)	返回新创建线程的栈大小；或为后续创建的线程设定栈的大小为size

4.6 单线程和多线程执行对比

4.7 多线程实践
1、图书排名示例
<1>_main()返回之后(脚本最后一行)，或者使用atexit.register()来注册一个退出函数。

<2>移植到Python3
将python安装包下的Tools/Scripts下面的2to3拷贝到需要转换文件目录中。
2to3 foo.py		//只显示原始2.x脚本与生成的3.x脚本之间的区别
2to3 -w foo.py 	//-w标志让2to3工具使用新生成的3.x脚本重写原始脚本，并将2.x脚本重命名为foo.py.bak

2、同步原语
锁/互斥、信号量

竞争条件
https://en.wikipedia.org/wiki/Race_condition

线程同步
http://en.wikipedia.org/wiki/Critical_section

进程同步
http://en.wikipedia.org/wiki/Synchronization_(computer_ science)

3、锁
<1>锁有两种状态：锁定和未锁定。而且它也只支持两个函数：获得锁和释放锁。
1)当多线程争夺锁时，允许第一个获得锁的线程进入临界区，并执行代码。
之后达到的线程将被阻塞，直到第一个线程执行结束，退出临界区，并释放锁。

<2>语法
1)loops = (randrange(2,5) for x in xrange(randrange(3,7)))
loops是一个生成器。xrange()的结果也是一个生成器。
该表达式的意思为：这里不再把 循环/线程对 硬编码成睡眠4秒和2秒，而是将它们随机混合在一起，创建3~6个线程，每个线程睡眠2~4秒。
>>> for n in loops:
...     print n
... 
4
4
4
2

2)使用集合(set)来记录剩下的还在运行的线程。

<3>存在问题
1)输出可能部分混乱、交错输出(因为多个线程可能并行执行I/O)。
2)多个线程同时修改同一个变量(剩余线程名集合)。

I/O和访问相同的数据结构都属于临界区，因此需要用锁来防止多个线程同时进入临界区。
需呀引入Lock(或RLock)，创建一个锁对象。

<4>版本兼容
2.6之前版本		print '[%s] Started %s' % (ctime(), myname)
2.6+可以使用	print '[{0}] Started {1}'.format(ctime(), myname)
3.x版本			print('[{0}] Started {1}'.format(ctime(), myname))

threading.currentThread()从2.6版本开始重命名为threading.current_thread()，不过旧的写法仍旧保留了下来。

<5>使用上下文管理
1)2.5及以后版本，可以不再调用锁的acquire()和release()方法。
使用with语句，此时每个对象的上下文管理器负责在进入该套件(缩进来标识区域？？)之前调用acquire()并在完成执行之后调用release()。

2)threading模块的对象Lock\RLock\Condition\Semaphore\BoundedSemaphore都包含上下文管理器。
也就是说，它们都可以使用with语句。

4、信号量实例
对于拥有有限资源的应用来说，使用信号量是个不错的决定。

<1>信号量是一个计数器，当资源消耗时递减，当资源释放时递增。
1)python为了简化命名，使用和锁的函数/方法一样的名字：acquire和release。
2)BoundedSemaphore的一个额外功能是这个计数器的值永远不会超过它的初始值，它可以防止其中信号量释放次数多余获得次数的异常。

<2>信号量比锁更加灵活，因为可以有多个线程，每个线程拥有有限资源的一个实例。

<3>语法
1)candytray.acquire(False) //检测是否所有资源都已经消费完。
计数器值不能小于0，因此这个调用一般会在计数器再次增加前被阻塞。通过传入非阻塞标志False，让调用不再阻塞。
而在应当阻塞时返回一个False，指明没有更多资源了。

2)信号量要在lock限制的临界区中使用。对信号量的+/-是原子操作。
---------------------------------------------------------------------------------------
/****************APUE中的信号量*********************/
信号量与已经介绍过的IPC机构(管道、FIFO、消息队列)不同。信号量是一个计数器，用于为多个进程提供对共享数据对象的访问。
为了获得共享资源，进程需要执行下列操作：
1)测试控制该资源的信号量;
2)若此信号量的值为正，则进程可以使用该资源。在这种情况下，进程会将信号量值-1，表示它使用了一个资源单位;
3)否则，若此信号量的值为0，则进程进入休眠状态，直至信号量值大于0.进程被唤醒后，返回步骤1)。
为了正确实现信号量，信号量的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。

常用的信号量形式被称为二元信号量，它控制单个资源，其初始值为1。
但是，一般而言信号量的初值可以是任意一个正值，改值表明有多少个共享资源单位可供共享使用。
----------------------------------------------------------------------------------------

4.8 生产者-消费者问题和Queue/queue模块
虽然可以使用同步原语来构建线程安全的类和数据结构,但Python标准库中也包含了一个实现：Queue对象。

1、简介
<1>2.X版本中的Queue模块在3.X版本中重命名为queue模块。

<2>使用Queue模块提供线程间通信的机制，让线程之间可以互相分享数据。
具体而言，就是创建一个队列，让生产者在其中放入新的商品，消费者消费这些商品。

2、模块属性
<1>Queue模块的类
1)Queue(maxsize=0)
创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则为无限队列。

2)LifoQueue(maxsize=0)
创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则为无限队列。

3)PriorityQueue(maxsize=0)
创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则为无限队列。

<2>Queue模块的异常
Empty	//对空队列调用get*()方法时抛出
Full	//对满队列调用put*()方法时抛出

<3>Queue模块的对象方法
1)qsize()
返回队列大小(当前时间点的确切值。但由于返回时队列大小可能被其他线程修改，所以该值为近视值)

2)empty()
如果队列为空，返回True

3)full()
如果队列已满，返回True

4)put(item, block=True, timeout=None)
将item放入队列。
如果block为True(默认值)且timeout为None，则在有空间之前阻塞；
如果timeout为正值，则最多阻塞timeout秒；
如果block为False，则抛出Full异常。

5)put_nowait(item)
和put(item,False)相同。

6)get(block=True,timeout=None)
从队列中取得元素。如果block为True(默认值)，则在有可用元素之前阻塞。

7)get_nowait()
和get(False)相同。

8)task_done()
用于表示队列中的某个元素已执行完成，该方法会被join()使用。

9)join()
在队列中所有元素执行完毕并调用task_done()信号之前，保持阻塞。


4.9 线程的替代方案
1、通常来说，多线程是一个好东西。不过，由于Python的GIL限制，多线程更适合于I/O密集型应用(I/O释放了GIL，可以允许更多的并发)，
而不是计算密集型应用。对于后一种情况而言，为了实现更好的并行性，需要使用多进程，以便让CPU的其他内核来执行。

2、对于多线程或多进程，threading模块的主要替代品包括：
<1>subprocess模块   //派生进程
<2>multiprocessing模块	//允许为多核或多CPU派生进程
<3>concurrent.futures模块
 

























