第一章 Linux内核简介
1.3 操作系统内核简介
<1>操作系统是指在整个系统中负责完成最 基本功能和系统管理 的那些部分。这些部分应包括内核、设备驱动程序、启动引导程序、
      命令行Shell或者其他种类的用户界面、基本文件管理工具和系统工具。

<2>系统这个词包含了操作系统和所有运行在其上的应用程序。
	  
<3>用户界面是操作系统的外在表象，内核才是操作系统的内在核心。系统其他部分必须依靠内核这部分软件提供的服务，
像管理硬件设备、分配系统资源等。内核有时候被称为管理者或操作系统核心。
	通常一个内核由负责响应中断的中断服务程序；负责管理多个进程从而分享处理器时间的调度程序；
	负责管理进程地址空间的内存管理程序；网络、进程间通信等系统服务程序共同组成。
	  
<4>内核独立于普通应用程序，它一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和受保护的内存空间，统称为内核空间。

<5>应用程序在用户空间执行，它们只能看到允许它们使用的部分系统资源，并且只使用某些特定的系统功能，不能直接访问硬件，
	  也不能访问内核划分给别人的内存范围，还有其他一些使用限制。
	  
<6>当内核运行时，系统以内核态进入内核空间执行；执行普通程序时，系统以用户态进入用户空间执行。

<7>应用程序-->系统调用接口-->内核子系统-->设备驱动程序-->硬件
						  -->设备驱动程序             -->硬件
1)在系统中运行的应用程序通过系统调用来与内核通信。应用程序通常调用库函数，再由库函数通过系统调用界面，让内核代其完成各种不同任务。
   
2)当一个应用程序执行一条系统调用，称为 内核正在代其执行。
	应用程序被称为通过系统调用在内核空间运行；内核被称为运行于进程上下文中。
    应用程序通过系统调用界面陷入内核，是应用程序完成其工作的基本行为方式。
	
<8>内核还负责管理系统的硬件设备   //中断机制
	当硬件设备想要和系统通信时，它首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。
	中断通常对应一个中断号，内核通过这个中断号查找相应的中断服务程序，并调用这个程序相应和处理中断。
	
<9>处理器在任何时间点上的活动必然为以下三者之一：
1)运行于用户空间，执行用户程序
2)运行于内核空间，处理进程上下文，代表某个特定的进程执行
3)运行于内核空间，处理中断上下文，与任何进程无关，处理某个特定的中断

//这些上下文代表着内核活动的范围。
当CPU空闲时，内核就运行一个空进程，处于进程上下文，但运行于内核空间。
	
1.4 Linux内核和传统Unix内核的比较
1、单内核与微内核设计之比较
<1>单内核
1)把内核从整体上作为一个独立的大过程来实现，同时也运行在一个单独的地址空间上。
这样的内核通常以单个静态二进制文件的形式存放于磁盘中，所有内核服务都在这样的一个大内核地址空间上运行。

2)简单、高性能，大多数Unix系统都设计为单模块。
	
<2>微内核
微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。
理想情况下，只有强烈请求特权服务的服务器才运行在特权模式下，其他服务器都运行在用户空间。不过，所有服务器都保持独立并运行在各自地址空间上。

1)不能像单模块那样直接调用函数，而是通过消息传递处理微内核通信，(IPC 进程间通信机制)
2)IPC机制开销大于函数调用;同时涉及内核空间和用户空间的上下文切换。
3)结果，所有实际基于微内核的系统都让大部分或全部服务器位于内核，这样虽可以直接调用函数、消除频繁切换上下文的弊端；
	但违反了微内核设计的初衷。
	
2、linux是一个单内核，也就是说，linux内核运行在单独的内核地址空间上。

3、Linux内核与传统Unix系统之间的差异：
<1>Linux支持动态加载/卸载内核模块。
<2>Linux支持对称多处理(SMP)机制。
<3>Linux内核可以抢占。
<4>Linux对线程支持的实现：内核并不区分线程和其他的一般进程。
<5>Linux提供具有设备类的面向对象的设备模型、热插拔时间。
<6>忽略了一些不好的Unix特性
<7>自由

1.5 Linux内核版本
<1>linux内核分为：稳定和处于开发中 两种。稳定内核具有工业级强度。
<2>linux通过一个简单的命名机制来区分稳定的和处于开发的内核。
2.6.26.1 //主版本号.副版本号.修订版本号.稳定版本号(可选)
1)从副版本号就可以反映出该内核是一个稳定版本还是一个处于开发中的版本：偶数表示稳定版本，奇数表示开发版本。
2)主版本号和副版本号 一起描述了 内核系列。2.6版内核系列

第二章 从内核出发
2.3 编译内核
一、配置内核
<1>make config  //字符界面下的命令行工具
该工具会逐一遍历所有配置项，要求用户选择yes、no或者module。
<2>make menuconfig //基于ncurse库编制的图形界面工具
<3>make gconfig  //基于gtk+的图形工具
<4>make defconfig //基于默认的配置为你的体系结构创建一个配置

执行上述任意一条命令后会生成.config文件保存配置项结果，可以直接修改它。

<5>修改配置文件后，或利用已有的配置文件配置新的代码树时，要验证和更新配置：
make oldconfig

<6>配置选项CONFIG_IKCONFIG_PROC把完整的压缩过的内核配置文件存放在/proc/config.gz下，这样编译一个新内核时就可以很方便地克隆当前的配置。
zcat /proc/config.gz > .config
make oldconfig

<7>一旦内核配置好了就可以编译它了：
make

二、减少编译的垃圾信息
make > .. /detritus

make > /dev/null

三、衍生多个编译作业
<1>make程序能把编译过程拆分成多个并行的作业。其中每个作业独立并发地运行，这有助于极大地加快多处理器系统上的编译过程。
<2>默认情况下，make只衍生一个作业，因为makefile常会出现不正确的依赖信息。多个作业可能互相踩踏，导致编译过程出错。
<3>make -jn //n为要衍生出的作业数目，通常每个处理器上一般衍生出一个或两个作业。
<4>利用distcc或者ccache工具，也可以动态地改善内核的编译时间。

四、完整性内核
<1>怎么安装内核和体系结构以及启动引导工具(boot loader)息息相关。按照启动引导工具的指导将内核镜像拷贝到合适的位置，并且按照启动要求安装。
<2>一定要保证随时有一个或两个可以启动的内核，防止新编译的内核出现问题。


2.4 内核开发的特点
<1>内核编程时既不能访问C库也不能访问标准C头文件
<2>内核编程时必须使用GNU C
<3>内核编程时缺乏像用户空间那样的内存保护机制
<4>内核编程时难以执行浮点运算
<5>内核给每个进程只有一个很小的定长堆栈
<6>由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发
<7>要考虑可移植性的重要性

一、无libc库抑或无标准头文件
<1>对于内核来说，完整的C库或者它的一个子集，都太大、太低效了。
<2>大部分常用的C库函数在内核中都已经得到实现。如linux/string.h

1、头文件

二、GNU C
1、内核并不完全符合ANSI C标准。事实上，内核开发者总是要用到gcc提供的许多语言的扩展部分。(gcc是多种GNU编译器的集合。)
2、内核开发者使用的C语言涵盖了ISO C99标准和GNU C扩展特性。推荐使用gcc 4.4或之后的版本。

3、GNU C与标准C的一些区别
<1>内联函数 inline
C99和GNU C均支持内联函数，可以消除函数调用和返回所带来的开销(寄存器存储和恢复)。
						  编译器会把调用函数的代码和函数本身放在一起优化，所以也有进一步优化代码的可能。
						  代价是代码会变长，占用更多的内存空间和指令缓存。
-内核开发者通常把对时间要求较高，且本身长度较短的函数定义成内联函数。   static inline
-内联函数必须在使用前就定义好，否则编译器就没法把这个函数展开。
-在内核中，为了类型安全和易读性，优先使用内联函数而不是复杂的宏。

<2>内联汇编
-gcc编译器支持在C函数中嵌入汇编指令。通常使用asm()指令嵌入汇编代码。
-linux内核混合使用了C语言和汇编语言。在偏近体系结构的底层或对执行时间要求严格的地方，一般使用汇编语言。内核其他大部分代码使用C语言编写。

<3>分支表明
对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。
内核把这条指令封装成了宏，如likely()和unlikely()。

三、没有内存保护机制
<1>如果一个用户程序试图进行一次非法的内存访问，内核就会发现这个错误，发送SIGSEGV信号，并结束整个进程。
	然而，如果室内和自己非法访问了内存，那后果就很难控制了。
<2>内核中的内存都不分页。也就是说，每用掉一个字节，物理内存就会减少一个字节。

四、不要轻易在内核中使用浮点数
<1>在用户空间的进程内进行浮点操作时，内核会完成从整数操作到浮点数操作的模式转换。因体系结构不同，内核会执行不同的操作。
<2>与用户空间进程不同，内核并不能完美地支持浮点操作，因为它本身不能陷入。

五、容积小而固定的栈
<1>用户空间的程序可以从栈上分配大量的空间来存放变量，甚至巨大的结构体或者是包含数以千计的数据项的数组。
	这是因为用户空间的栈本身就比较大，而且还能动态地增长。
<2>内核栈的准确大小随体系结构变化。内核栈的大小固定两页，也就是说，32位机的内核栈是8KB；64位机是16KB。
	每个处理机都有自己的栈。
	
六、同步和并发
内核很容易产生竞争条件，内核许多特性都要求能够并发地访问共享数据。

七、可移植性的重要性

第三章、进程管理
3.1 进程
<1>进程：进程就是处于执行期的程序。包括：可执行程序代码、打开的文件、挂起的信号、内核内部数据、处理器状态、内存地址空间、
		执行线程、数据段等。
<2>线程：执行线程简称线程，是在进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。
		 内核调度的对象是线程，而不是进程。
		 对linux而言，线程不过是一种特殊的进程。并不特别区分线程和进程。

<3>虚拟处理器：虽然实际上是多个进程共享一个处理器，但虚拟处理器让进程觉得自己在独享处理器。
<4>虚拟内存：让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。
注：同一个进程中  线程之间可以共享虚拟内存，但每个线程都拥有各自的虚拟处理器。

<5>程序本身并不是进程，进程是处于执行期的程序以及相关资源的总称。
	完全可能存在两个或多个不同的进程执行同一个程序，并且两个或两个以上的进程可以共享打开的文件、地址空间之类的资源。
	
<6>fork()系统调用通过复制一个现有进程来创建一个全新的进程。
1)调用fork的进程称为父进程，产生的进程称为子进程。
2)fork系统调用从内核返回两次：一次回到父进程，另一回到新产生的子进程。在返回点这个相同位置上，父进程恢复执行，子进程开始执行。
3)fork()实际上由clone()系统调用实现的。
4)创建新的进程都是为了立即执行新的、不同的程序，而接着调用exec()这组函数可以创建新的地址空间，并把新的程序载入其中。
5)程序通过exit()系统调用退出执行。该系统调用会终止进程并将其占用的资源释放。
	父进程可以通过wait4()系统调用查询子进程是否终结，这其实使得进程拥有等待特定进程执行完毕的能力。
	进程退出执行后被设置为僵死状态，直到它的父进程调用wait()或waitpid()为止。
	
<7>通常创建新的进程都是为了立即执行新的、不同的程序，而接着调用exec()这组函数就可以创建新的地址空间，并把新的程序载入其中。

<8>进程的另一个名字是任务(task)。linux内核通常把进程也叫作任务。这里通常指的是从内核观点所看到的进程。

3.2 进程描述符及任务结构
1、内核把进程列表存放在叫做任务队列(task list)的双向循环链表中。其中每一项都是task_struct类型，称为进程描述符(process descriptor)结构。
	该结构在<linux/sched.h>中，该描述符中包含了一个具体进程的所有信息。
	
一、分配进程描述符
1、linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色(cache coloring)的目的。//进程创建迅速。
<1>通过预先分配和重复使用task_struct，可以避免动态分配和释放所带来的资源消耗。
<2>由于用slab分配器动态生成task_struct，所以只需在栈底(对于向下增加的栈，向低地址增长，栈底为高地址)或
	栈顶(对于向上增加的栈，向高地址增长)创建一个新的结构thread_info。

	向上增长：向高地址增长；向下增长：向低地址增长  //http://blog.csdn.net/pfanaya/article/details/7043992

<3>每个任务的thread_info结构在它的内核栈的尾端部分(低地址部分)。thread_info中的task域中存放着指向该任务实际task_struct的指针。

二、进程描述符的存放
1、PID标识每一个进程，pid_t类型(实际上是int型)
<1>为了与老版本兼容，最大默认设置为32768(short int的最大值)。可以通过/proc/sys/kernel/pid_max来提高上限。
<2>PID保存在进程描述符中。

2、内核中，访问任务通常需要获得指向其task_struct的指针。
<1>current宏查找当前正在运行进程的进程描述符。

三、进程状态
1、进程描述符中的state域描述了进程的当前状态。系统中的每个进程都必然处于五种状态中的一种：
<1>TASK_RUNNING(运行)：进程是可执行的。它或者正在执行，或者在运行队列中等待执行。
	这是进程在用户空间中执行的唯一可能状态。这种状态也可应用到内核空间中正在执行的进程。

<2>TASK_INTERRUPTIBLE(可中断)：进程正在睡眠(也就是说它被阻塞)，等待某些条件的达成。一旦条件达成，内核就会把进程状态设置为运行。
	处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。
	
<3>TASK_UNINTERRUPTIBLE(不可中断)：就算是接收到信号也不会被唤醒，此状态的任务对信号不响应。其他与可中断状态相同。
	这个状态通常在进程必须在等待时不受干扰 或 等待事件很快就会发生时出现。
	
<4>_TASK_TRACED：被其他进程跟踪的进程

<5>_TASK_STOPPED(停止)：进程停止执行。进程没有投入运行也不能投入运行。
	通常发生在接收到SIGSTOP等信号时；此外调试期间收到任何信号，都会使进程进入这种状态。
	
四、设置进程当前状态
内核调用 set_task_state(task,state)
		 set_current_state(state)

五、进程上下文
1、当一个进程执行了系统调用或者触发了某个异常，它就陷入了内核空间。此时，称为内核"代表进程执行"并处于进程上下文中。
在此上下文中current宏是有效的。

2、系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行。

六、进程家族树
1、进程之间存在明显的继承关系，所有的进程都是PID为1的init进程的后代。
	内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本，并执行其他的相关程序。
<1>init进程的进程描述符是作为init_task静态分配的。

2、进程间的关系存放在进程描述符中：
<1>指向父进程描述符的 parent指针  struct task_struct __rcu *parent;
<2>一个称为children的子进程链表   struct list_head children;

3、访问进程
<1>借助init_task
struct task_struct *task;
for(task=current; task!=&init_task; task=task->parent)

<2>任务队列本来就是双向循环链表
next_task()/prev_task()宏

<3>for_each_process(task)宏提供了依次访问整个任务队列的能力

3.3 进程创建
1、其他系统：许多其他系统都提供了产生(spawn)进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。
2、Unix系统：将上述步骤分解到两个单独的函数(fork、exec)中去执行。
			 fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅在于PID、PPID和某些资源的统计量。
			 exec()负责读取可执行文件并将其载入地址空间开始运行。
			 
一、写时拷贝
1、linux的fork()使用写时拷贝(copy-on-write)页实现，可以推迟甚至避免拷贝父进程数据的技术。
	内核此时并不复制整个进程的地址空间，而是让父进程和子进程共享同一个拷贝。
	
2、只有在需要写入时，数据才会复制，从而使各个进程有各自的拷贝。
	在页根本不会被写的情况下(如，fork之后立即调用exec)，它们就无须复制了。
	
二、fork
1、linux通过clone()系统调用实现fork()。
	fork、vfork、__clone库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用()。
	
2、do_fork完成创建中的大部分工作。该函数调用copy_process()函数，然后让进程开始运行。

三、vfork
1、除了不拷贝父进程的页表项外，vfork()与fork()的功能相同。
	子进程作为父进程的一个单独进程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行exec()。
	子进程不能向地址空间写入。
	
2、由于执行fork()时引入了写时拷贝页，并且明确了子进程先执行。vfork的好处就仅限于不拷贝父进程的页表项了。//页表项和页表是一个东西？？

3、理想情况下，系统最高不要调用vfork()，内核也不用实现它。完全可以把vfork()实现成一个普通的fork()。

4、vfork，如果一切执行顺利，子进程会在新的地址空间里运行，而父进程也恢复在原地址空间的运行。确实降低了开销。

3.4 线程在linux中的实现
1、从内核角度来说，没有线程这个概念，linux把所有线程都当做进程来实现。
	线程仅仅被视为一个与其他进程共享某些资源(如地址空间)的进程。每个线程都拥有唯一隶属于自己的task_struct。
	
2、其他系统(如：windows\sun solaris)的内核提供了专门支持线程的机制。相对于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。
	而对于linux，线程知识一种进程间共享资源的手段，linux的进程本身就够轻量级了。
	
一、创建线程
1、线程的创建于普通进程的创建类似，只是要在调用clone()时需要传递一些参数标志来指明需要共享的资源：
<1>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)
上述代码产生的结果和调用fork()差不多，只是父子俩共享地址空间、文件系统资源、文件描述符和信号处理程序。
换句话说，新建的进程和它的父进程就是流行的所谓线程。

<2>普通fork实现：
clone(SIGCHLD,0)

<3>vfork实现：
clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)

2、clone参数标记          
#define CLONE_VM    0x00000100  /* set if VM shared between processes */                             |~ 父子进程共享地址空间                                      
#define CLONE_FS    0x00000200  /* set if fs info shared between processes */                        |~ 父子进程共享文件系统信息                                      
#define CLONE_FILES 0x00000400  /* set if open files shared between processes */                     |~ 父子进程共享打开的文件                                      
#define CLONE_SIGHAND   0x00000800  /* set if signal handlers and blocked signals shared */          |~ 父子进程共享信号处理函数及被阻断的信号                                      
#define CLONE_PTRACE    0x00002000  /* set if we want to let tracing continue on the child too */    |~ 继续调试子进程                                      
#define CLONE_VFORK 0x00004000  /* set if the parent wants the child to wake it up on mm_release */  |~ 调用vfork，父进程准备睡眠，等待子进程将其唤醒                                      
#define CLONE_PARENT    0x00008000  /* set if we want to have the same parent as the cloner */       |~ 指定子进程与父进程拥有同一个父进程                                     
#define CLONE_THREAD    0x00010000  /* Same thread group? */                                         |~ 父进程放入相同的线程组                                      
#define CLONE_NEWNS 0x00020000  /* New namespace group? */                                           |~ 为子进程创建新的命名空间                                      
#define CLONE_SYSVSEM   0x00040000  /* share system V SEM_UNDO semantics */                          |~ 父子进程共享System V SEM_UNDO语言                                      
#define CLONE_SETTLS    0x00080000  /* create a new TLS for the child */                             |~ 为子进程创建新的TLS(thread-local storage)                                      
#define CLONE_PARENT_SETTID 0x00100000  /* set the TID in the parent */                              |~ 设置父进程的TID                                      
#define CLONE_CHILD_CLEARTID    0x00200000  /* clear the TID in the child */                         |~ 清除子进程的TID                                      
#define CLONE_DETACHED      0x00400000  /* Unused, ignored */                                        |~                                       
#define CLONE_UNTRACED      0x00800000  /* set if the tracing process can't force CLONE_PTRACE on thi|~                                       
#define CLONE_CHILD_SETTID  0x01000000  /* set the TID in the child */                               |~ 设置子进程的TID                                     
/* 0x02000000 was previously the unused CLONE_STOPPED (Start in stopped state)                       |~                                       
 and is now available for re-use. */                                                               |~                                       
#define CLONE_NEWUTS        0x04000000  /* New utsname group? */                                     |~                                       
#define CLONE_NEWIPC        0x08000000  /* New ipcs */                                               |~                                       
#define CLONE_NEWUSER       0x10000000  /* New user namespace */                                     |~                                       
#define CLONE_NEWPID        0x20000000  /* New pid namespace */                                      |~                                       
#define CLONE_NEWNET        0x40000000  /* New network namespace */                                  |~                                       
#define CLONE_IO        0x80000000  /* Clone io context */  

二、内核线程 (kernel thread) --独立运行在内核空间的标准进程
1、内核线程与普通进程的区别：内核线程没有独立的地址空间(实际上指向地址空间的mm指针被设置为NULL)
							 它们只在内核空间运行，从来不切换到用户空间去。

2、内核线程只能由其他内核线程创建。kthread_create()-wake_up_process() //创建+运行
								   kthread_run() //创建并运行
	
3、内核线程一直运行直到调用do_exit()，或者内核的其他部分调用kthread_stop()。
	传递给kthread_stop的参数是kthread_create返回的task_struct结构地址。


3.5 进程终结
1、内核释放进程占有的资源，并通知其父进程。
<1>一般来说，进程的析构是自身引起的。它发生在进程调用exit()系统调用时。
	即可能是显示调用，也可能是隐式地从某个程序的主函数返回。(C语言编译器会在main函数返回点后面放置调用exit的代码)

<2>当进程接收到它既不能处理也不能忽略的信号或异常时，也可能被动地终结。

<3>不管进程如何终结，该任务大部分都依靠do_exit()完成。

	do_exit调用exit_notify()向父进程发送信号，给子进程重新找养父。养父为线程组(子进程所在的线程组)中的其他线程或者init进程。
	do_exit调用schedule()切换到新的进程。因为处于EXIT_ZOMBIE状态的进程不会再被调度，因此这是该进程执行的最后一段代码。
	do_exit永远不返回。
	
<4>do_exit()执行完毕之后。与进程相关的所有资源都被释放掉了(假设该进程是这些资源的唯一使用中)。
1)进程不可运行(实际上也没有地址空间让它运行)，并处于EXIT_ZOMBIE退出状态。
2)进程所占用的所有内存就是 内核栈、thread_info结构、task_struct结构
3)此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内存被释放，归还给系统使用。

一、删除进程描述符
1、wait()这一族函数都是通过唯一的系统调用wait4()来实现的。
	它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的PID。
	此外，调用该函数时提供的指针会包含子进程退出时的退出代码。

2、当最终需要释放进程描述符时，release_task()会被调用。

二、孤儿进程造成的进退维谷
1、如果父进程在子进程之前退出，必须有机制保证子进程能找到一个新的父亲。否则子进程就会在自身退出时永远处于僵死状态，白白消耗内存。
1)解决方法是 给子进程在当前线程组内找一个线程作为父亲。如果不行，就让init作为它们的父进程。
2)do_exit--exit_notify--forget_original_parenet--find_new_reaper 执行寻父过程。

2、遍历两个链表：子进程链表children
				 ptrace子进程链表ptraced
	给每个子进程设置新的父进程。
	
3、当一个进程被跟踪时，它的临时父亲设定为调试进程，此时，如果它的父进程退出了，系统会为它和它的所有兄弟重新找一个父进程。
	//对应ptrace子进程链表
	
4、init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。


第四章 进程调度
进程调度程序：确保进程有效工作的一个内核子系统。
			  在可运行态进程之间分配有限的处理器时间资源的内核子系统。
			  是像linux这样的多任务操作系统的基础。
			  
4.1 多任务
1、多任务操作系统就是能同时并发地交互执行多个进程的操作系统。
<1>无论是在单处理器或多处理器的机器上，多任务操作系统都能使多个进程处于堵塞或者睡眠状态。
	这些任务尽管位于内存，但并不处于可运行态。
	这些进程利用内核阻塞自己，直到某件事情发生。
	
<2>多任务系统可以分为
1)抢占式多任务
linux提供了抢占式多任务模式。由调度程序决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会。这种强制的挂起动作就叫抢占。
	
进程在被抢占之前能够运行的时间是预先设置好的，叫进程的时间片。也就是分配给每个可运行进程的处理器时间段。

2)非抢占式多任务
除非进程自己主动停止，否则它会一直执行。
进程主动挂起自己的操作称为让步。理想情况下，进程通常做出让步，以便让每个可运行进程享有足够的处理器时间。

该模式下，调度程序无法对每个进程该执行多长时间做出统一规定。

4.2 Linux的进程调度
完全公平调度算法 CFS

4.3 策略
策略决定了调度程序在何时让什么进程运行。调度器的策略往往决定了系统的整体印象，并且，还要负责优化使用处理器时间。

一、I/O消耗型和处理器消耗型的进程
1、I/O消耗型进程
<1>进程的大部分时间用来提交I/O请求或是等待I/O请求。
	这样的进程经常处于可运行状态，但通常都是运行短短一会。
	
2、处理器消耗型进程
<1>把大量时间耗费在执行代码上。除非抢占，否则通常他们都是一直不停地运行。

<2>从系统响应角度考虑，调度器不应该经常让它们运行。
	
3、调度策略需要在两个矛盾的目标间寻找平衡：进程响应迅速(响应时间短)和最大系统利用率(高吞吐量)。
Unix系统的调度程序更倾向于I/O消耗型程序，从而提供更好的程序响应速度。
Linux为了保证交互式应用和桌面系统的性能，所以对进程的响应做了优化(缩短响应时间)，更倾向于优先调度I/O消耗型进程。

二、进程优先级
1、调度算法中最基本的一类就是基于优先级的调度。
<1>这是一种根据进程的价值和其对处理器时间的需求来对进程分级的想法。
<2>通常做法是优先级高的进程先运行，低的后运行，相同优先级的进程按照轮转方式进行调度。
<3>在某些系统中，优先级高的进程使用的时间片也较长。
	调度程序总是选择时间片未用尽且优先级最高的进程运行。
	用户和系统都可以通过设置进程的优先级来影像系统的调度。
	
2、linux采用了两种不同的优先级范围。
<1>nice值，范围从-20到19，默认为0。越大的nice值意味着优先级更低。(nice值意味着对系统其他进程的“优待”。)
1)低nice值的进程可以获得更多的处理器时间。linux系统中nice值代表时间片的比例。

<2>实时优先级，其值是可配置的，默认情况下变化范围[0,99]。
1)与nice值相反，越大的实时优先级数值意味着进程优先级越高。
2)任何实时进程的优先级都高于普通的进程。也就是说实时优先级和nice优先级处于互不相交的两个范畴。

<3>ps -eo state,uid,pid,ppid,rtprio,time,comm.
查看系统中的进程列表，以及它们的实时优先级(位于RTPRIO列下)，如果对应显示-，说明它不是实时进程。

三、时间片
1、在其他系统中时间片有时也称为量子或处理器片。

2、时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。调度策略必须规定一个默认的时间片。
<1>任何长时间片都将导致系统交互表现欠佳。所以默认时间片很短，如10ms。
1)linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比例划分给了进程。
	这样，进程所获得的处理器时间其实是和系统负载密切相关的。

2)这个比例进一步还受到进程nice值的影响，nice值作为权重将调整进程所使用的处理器时间使用比。

<2>当一个进程进入可运行态，它就被允许投入允许。
1)在多数操作系统中，是否要将一个进程立刻投入运行(也就是抢占当前进程)，是完全由进程优先级和是否有时间片决定的。
2)而在linux系统中，使用新的CFS调度器，其抢占时机取决于新的可运行程序消耗了多少处理器使用比。
	如果消耗的使用比小于当前进程，则新进程立刻投入运行，抢占当前进程。否则，将推迟运行。
	
四、调度策略的活动
文件编辑器程序和视频编码程序的例子。

4.4 linux调度算法
一、调度器类 scheduler classes
1、linux调度器是以模块方式提供的，这样的目的是允许不同类型的进程可以有针对性地选择调度算法。这种模块化结构称为调度器类。
<1>它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。
1)每一个调度器都有一个优先级。基础的调度器代码会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行的那个程序。

<2>完全公平调度(CFS)是一个针对普通进程的调度类，在linux中称为SCHED_NORMAL

二、Unix系统中的进程调度
1、要将nice值映射到时间片，就必然需要将nice单位值对应到处理器的绝对时间。这样将导致进程切换无法最优化进行。

2、相对nice值。
<1>nice值通常都是用相对值。nice系统调用是在原值上增加或减少，而不是在绝对值上操作。
<2>	0 -- 100ms 
	1 --  95ms
   18 --  10ms
   19 --   5ms
也就是说，把进程的nice值减小1所带来的效果极大的取决于nice的初始值。

3、如果执行nice值到时间片的映射，我们需要能分配一个绝对时间片，而且这个绝对时间片必须能在内核测试范围内。
	在多数操作系统中，这就要求时间片必须是定时器节拍的整数倍。
	
4、分配绝对的时间片引发的固定的切换频率，给公平性造成了很大变数。

三、公平调度
1、CFS的出发点基于一个简单的理念：进程调度的效果应如同系统具备一个理想中的完美的多任务处理器。
<1>每个进程将获得1/n的处理器时间，n是指可运行的进程的数目。
<2>同时我们可以调度给它们无限小的时间周期，所以在任何可测量的周期内，我们给予n个进程中的每个进程同样多的运行时间。

2、上述理想模型并非现实，因为我们无法在一个处理器上真正同时运行多个进程。
而且，如果每个进程运行无限小的时间周期也不是高效的。因为调度时进程抢占会带来一定的代价。
将一个进程换出，另一个换入本身就有消耗，同时还会影响到缓冲的效率。

<1>CFS首先要确保系统性能不受损失。
1)CFS允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。
2)CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。
3)nice值在CFS中被作为进程获得的处理器运行比的权重。
	每个进程都按其权重在全部可运行进程中所占的比例的"时间片"来运行。
4)目标延迟：CFS为完美多任务中的无限小调度周期的近似值设立的一个目标。   //调度周期：所有任务调度一遍的时间
	越小的调度周期将带来越好的交互性，同时也更接近完美的多任务。
5)最小粒度：CFS引入的每个进程获得时间片的底线。默认情况下这个值是1ms。确保切换消耗被限制在一定范围内。

3、绝对的nice值不再影响调度决策，只有相对值才会影响处理器时间的分配比例。
	0   5    //nice值为5的进程的权重将是默认nice进程的1/3
   10  15    //nice值为15的进程的权重将是nice值为10的进程的1/3
   
   任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的。
   nice值对时间片的作用不再是算术加权，而是几何加权。
   任何nice值对应的绝对时间不再是一个绝对值，而是处理器的使用比。(这样可以在目标延迟内进行多个进程的切换)
	CFS称为公平调度器是因为它确保每个进程公平的处理器使用比。
	
4.5 Linux调度的实现  kernel/sched/fair.c

一、时间记账
<1>所有的调度器都必须对进程运行时间做记账。
<2>多数Unix系统，分配一个时间片给每一个进程。那么当每次系统时钟节拍发生时，时间片都会被减少一个节拍周期。
当一个进程的时间片被减少到0时，它就会被另一个时间片尚未减到0的可运行进程抢占。

1、调度器实体结构  //sched_entity结构体
<1>它作为一个名为se的成员变量，嵌入在进程描述符task_struct结构内。
<2>用于追踪进程运行时间记账。

2、虚拟实时
<1>结构体sched_entity中的vruntime变量存放进程的虚拟运行时间(花在运行上的时间和)，
	该运行时间的计算是经过了所有可运行进程总数的标准化(或者说被加权)的。
	
<2>单位为 ns，因此vruntime与定时器节拍不再相关。

<3>CFS使用vruntime变量来记录一个程序到底运行了多次时间以及它还应再运行多久。

<4>sched/fair.c文件中的update_curr()函数实现了该记账功能。
1)update_curr()是由系统定时器周期性调用的，无论进程处于可运行态，还是被阻塞处于不可运行态。
	根据这种方式，vruntime可以准确地测量给定进程的运行时间，而且可以知道谁应该是下一个运行的进程。

二、进程选择
<1>CFS试图利用一个简单的规则去均衡进程的虚拟运行时间：
	当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。

<2>CFS调度算法的核心：
	选择具有最小vruntime的任务。
	
<3>CFS使用红黑树来组织可运行进程队列，并且利用其迅速找到最小vruntime值的进程。 //CFS只是普通进程的调度类，可以预见每个调度类都对应一棵红黑树。

1、挑选下一个任务
<1>假设有一个红黑树(rbtree)存储了系统中所有可运行进程，其中节点的键值便是可运行进程的虚拟运行时间。
<2>CFS调度器选取待运行的下一个进程，是所有进程中vruntime最小的那一个，它对应的便是在树中最左侧的叶子结点。
<3>kernel/sched/fair.c	__pick_next_entity() 实现这一过程。
	但实际上该函数本身并不会遍历红黑树去找到最左叶子节点，因为该值已经缓存在rb_leftmost字段中。

2、向树中加入进程
<1>CFS将进程加入rbtree，以及缓存最左叶子节点，发生在进程变为可运行状态(被唤醒)或者通过fork()调用第一次创建进程时。
__enqueue_entity()函数实现。

3、从树中删除进程
删除动作发生在进程堵塞(变为不可运行态)或者终止时(结束运行)。
__dequeue_entity()函数实现。

三、调度器入口
1、调度进程的主要入口函数是schedule()。
<1>它是内核其他部分用于调度进程调度器的入口：选择哪个进程可以运行，何时将其投入运行。
<2>schedule()通常都需要和一个具体的调度类相关联。也就是说，它会找到一个最高优先级的调度类。
	该调度类需要有自己的可运行队列，然后找到下一个要运行的进程。
<3>schedule()会调用pick_next_task()，后者会以优先级为序，从高到低，依次检查每个调度类。
	并且从最高优先级的调度类中选择最高优先级的进程。
<4>pick_next_task()会调用pick_next_entity(),而后者会调用__pick_next_entity()。

四、睡眠和唤醒
1、休眠(被阻塞)的进程处于一个特殊的不可执行状态。进程休眠有多种原因，但肯定都是为了等待一些事件。
	内核的操作都是：进程把自己标记成休眠状态，从可执行红黑树中移除






















	
	
	
	
	
	
	
	
	
	












