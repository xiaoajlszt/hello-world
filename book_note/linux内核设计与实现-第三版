第一章 Linux内核简介
1.3 操作系统内核简介
<1>操作系统是指在整个系统中负责完成最 基本功能和系统管理 的那些部分。这些部分应包括内核、设备驱动程序、启动引导程序、
      命令行Shell或者其他种类的用户界面、基本文件管理工具和系统工具。

<2>系统这个词包含了操作系统和所有运行在其上的应用程序。
	  
<3>用户界面是操作系统的外在表象，内核才是操作系统的内在核心。系统其他部分必须依靠内核这部分软件提供的服务，
像管理硬件设备、分配系统资源等。内核有时候被称为管理者或操作系统核心。
	通常一个内核由负责响应中断的中断服务程序；负责管理多个进程从而分享处理器时间的调度程序；
	负责管理进程地址空间的内存管理程序；网络、进程间通信等系统服务程序共同组成。
	  
<4>内核独立于普通应用程序，它一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和受保护的内存空间，统称为内核空间。

<5>应用程序在用户空间执行，它们只能看到允许它们使用的部分系统资源，并且只使用某些特定的系统功能，不能直接访问硬件，
	  也不能访问内核划分给别人的内存范围，还有其他一些使用限制。
	  
<6>当内核运行时，系统以内核态进入内核空间执行；执行普通程序时，系统以用户态进入用户空间执行。

<7>应用程序-->系统调用接口-->内核子系统-->设备驱动程序-->硬件
						  -->设备驱动程序             -->硬件
1)在系统中运行的应用程序通过系统调用来与内核通信。应用程序通常调用库函数，再由库函数通过系统调用界面，让内核代其完成各种不同任务。
   
2)当一个应用程序执行一条系统调用，称为 内核正在代其执行。
	应用程序被称为通过系统调用在内核空间运行；内核被称为运行于进程上下文中。
    应用程序通过系统调用界面陷入内核，是应用程序完成其工作的基本行为方式。
	
<8>内核还负责管理系统的硬件设备   //中断机制
	当硬件设备想要和系统通信时，它首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。
	中断通常对应一个中断号，内核通过这个中断号查找相应的中断服务程序，并调用这个程序相应和处理中断。
	
<9>处理器在任何时间点上的活动必然为以下三者之一：
1)运行于用户空间，执行用户程序
2)运行于内核空间，处理进程上下文，代表某个特定的进程执行
3)运行于内核空间，处理中断上下文，与任何进程无关，处理某个特定的中断

//这些上下文代表着内核活动的范围。
当CPU空闲时，内核就运行一个空进程，处于进程上下文，但运行于内核空间。
	
1.4 Linux内核和传统Unix内核的比较
1、单内核与微内核设计之比较
<1>单内核
1)把内核从整体上作为一个独立的大过程来实现，同时也运行在一个单独的地址空间上。
这样的内核通常以单个静态二进制文件的形式存放于磁盘中，所有内核服务都在这样的一个大内核地址空间上运行。

2)简单、高性能，大多数Unix系统都设计为单模块。
	
<2>微内核
微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。
理想情况下，只有强烈请求特权服务的服务器才运行在特权模式下，其他服务器都运行在用户空间。不过，所有服务器都保持独立并运行在各自地址空间上。

1)不能像单模块那样直接调用函数，而是通过消息传递处理微内核通信，(IPC 进程间通信机制)
2)IPC机制开销大于函数调用;同时涉及内核空间和用户空间的上下文切换。
3)结果，所有实际基于微内核的系统都让大部分或全部服务器位于内核，这样虽可以直接调用函数、消除频繁切换上下文的弊端；
	但违反了微内核设计的初衷。
	
2、linux是一个单内核，也就是说，linux内核运行在单独的内核地址空间上。

3、Linux内核与传统Unix系统之间的差异：
<1>Linux支持动态加载/卸载内核模块。
<2>Linux支持对称多处理(SMP)机制。
<3>Linux内核可以抢占。
<4>Linux对线程支持的实现：内核并不区分线程和其他的一般进程。
<5>Linux提供具有设备类的面向对象的设备模型、热插拔时间。
<6>忽略了一些不好的Unix特性
<7>自由

1.5 Linux内核版本
<1>linux内核分为：稳定和处于开发中 两种。稳定内核具有工业级强度。
<2>linux通过一个简单的命名机制来区分稳定的和处于开发的内核。
2.6.26.1 //主版本号.副版本号.修订版本号.稳定版本号(可选)
1)从副版本号就可以反映出该内核是一个稳定版本还是一个处于开发中的版本：偶数表示稳定版本，奇数表示开发版本。
2)主版本号和副版本号 一起描述了 内核系列。2.6版内核系列

第二章 从内核出发
2.3 编译内核
一、配置内核
<1>make config  //字符界面下的命令行工具
该工具会逐一遍历所有配置项，要求用户选择yes、no或者module。
<2>make menuconfig //基于ncurse库编制的图形界面工具
<3>make gconfig  //基于gtk+的图形工具
<4>make defconfig //基于默认的配置为你的体系结构创建一个配置

执行上述任意一条命令后会生成.config文件保存配置项结果，可以直接修改它。

<5>修改配置文件后，或利用已有的配置文件配置新的代码树时，要验证和更新配置：
make oldconfig

<6>配置选项CONFIG_IKCONFIG_PROC把完整的压缩过的内核配置文件存放在/proc/config.gz下，这样编译一个新内核时就可以很方便地克隆当前的配置。
zcat /proc/config.gz > .config
make oldconfig

<7>一旦内核配置好了就可以编译它了：
make

二、减少编译的垃圾信息
make > .. /detritus

make > /dev/null

三、衍生多个编译作业
<1>make程序能把编译过程拆分成多个并行的作业。其中每个作业独立并发地运行，这有助于极大地加快多处理器系统上的编译过程。
<2>默认情况下，make只衍生一个作业，因为makefile常会出现不正确的依赖信息。多个作业可能互相踩踏，导致编译过程出错。
<3>make -jn //n为要衍生出的作业数目，通常每个处理器上一般衍生出一个或两个作业。
<4>利用distcc或者ccache工具，也可以动态地改善内核的编译时间。

四、完整性内核
<1>怎么安装内核和体系结构以及启动引导工具(boot loader)息息相关。按照启动引导工具的指导将内核镜像拷贝到合适的位置，并且按照启动要求安装。
<2>一定要保证随时有一个或两个可以启动的内核，防止新编译的内核出现问题。


2.4 内核开发的特点
<1>内核编程时既不能访问C库也不能访问标准C头文件
<2>内核编程时必须使用GNU C
<3>内核编程时缺乏像用户空间那样的内存保护机制
<4>内核编程时难以执行浮点运算
<5>内核给每个进程只有一个很小的定长堆栈
<6>由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发
<7>要考虑可移植性的重要性

一、无libc库抑或无标准头文件
<1>对于内核来说，完整的C库或者它的一个子集，都太大、太低效了。
<2>大部分常用的C库函数在内核中都已经得到实现。如linux/string.h

1、头文件

二、GNU C
1、内核并不完全符合ANSI C标准。事实上，内核开发者总是要用到gcc提供的许多语言的扩展部分。(gcc是多种GNU编译器的集合。)
2、内核开发者使用的C语言涵盖了ISO C99标准和GNU C扩展特性。推荐使用gcc 4.4或之后的版本。

3、GNU C与标准C的一些区别
<1>内联函数 inline
C99和GNU C均支持内联函数，可以消除函数调用和返回所带来的开销(寄存器存储和恢复)。
						  编译器会把调用函数的代码和函数本身放在一起优化，所以也有进一步优化代码的可能。
						  代价是代码会变长，占用更多的内存空间和指令缓存。
-内核开发者通常把对时间要求较高，且本身长度较短的函数定义成内联函数。   static inline
-内联函数必须在使用前就定义好，否则编译器就没法把这个函数展开。
-在内核中，为了类型安全和易读性，优先使用内联函数而不是复杂的宏。

<2>内联汇编
-gcc编译器支持在C函数中嵌入汇编指令。通常使用asm()指令嵌入汇编代码。
-linux内核混合使用了C语言和汇编语言。在偏近体系结构的底层或对执行时间要求严格的地方，一般使用汇编语言。内核其他大部分代码使用C语言编写。

<3>分支表明
对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。
内核把这条指令封装成了宏，如likely()和unlikely()。

三、没有内存保护机制
<1>如果一个用户程序试图进行一次非法的内存访问，内核就会发现这个错误，发送SIGSEGV信号，并结束整个进程。
	然而，如果室内和自己非法访问了内存，那后果就很难控制了。
<2>内核中的内存都不分页。也就是说，每用掉一个字节，物理内存就会减少一个字节。

四、不要轻易在内核中使用浮点数
<1>在用户空间的进程内进行浮点操作时，内核会完成从整数操作到浮点数操作的模式转换。因体系结构不同，内核会执行不同的操作。
<2>与用户空间进程不同，内核并不能完美地支持浮点操作，因为它本身不能陷入。

五、容积小而固定的栈
<1>用户空间的程序可以从栈上分配大量的空间来存放变量，甚至巨大的结构体或者是包含数以千计的数据项的数组。
	这是因为用户空间的栈本身就比较大，而且还能动态地增长。
<2>内核栈的准确大小随体系结构变化。内核栈的大小固定两页，也就是说，32位机的内核栈是8KB；64位机是16KB。
	每个处理机都有自己的栈。
	
六、同步和并发
内核很容易产生竞争条件，内核许多特性都要求能够并发地访问共享数据。

七、可移植性的重要性

第三章、进程管理
3.1 进程
<1>进程：进程就是处于执行期的程序。包括：可执行程序代码、打开的文件、挂起的信号、内核内部数据、处理器状态、内存地址空间、
		执行线程、数据段等。
<2>线程：执行线程简称线程，是在进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。
		 内核调度的对象是线程，而不是进程。
		 对linux而言，线程不过是一种特殊的进程。并不特别区分线程和进程。

<3>虚拟处理器：虽然实际上是多个进程共享一个处理器，但虚拟处理器让进程觉得自己在独享处理器。
<4>虚拟内存：让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。
注：同一个进程中  线程之间可以共享虚拟内存，但每个线程都拥有各自的虚拟处理器。

<5>程序本身并不是进程，进程是处于执行期的程序以及相关资源的总称。
	完全可能存在两个或多个不同的进程执行同一个程序，并且两个或两个以上的进程可以共享打开的文件、地址空间之类的资源。
	
<6>fork()系统调用通过复制一个现有进程来创建一个全新的进程。
1)调用fork的进程称为父进程，产生的进程称为子进程。
2)fork系统调用从内核返回两次：一次回到父进程，另一回到新产生的子进程。在返回点这个相同位置上，父进程恢复执行，子进程开始执行。
3)fork()实际上由clone()系统调用实现的。
4)创建新的进程都是为了立即执行新的、不同的程序，而接着调用exec()这组函数可以创建新的地址空间，并把新的程序载入其中。
5)程序通过exit()系统调用退出执行。该系统调用会终止进程并将其占用的资源释放。
	父进程可以通过wait4()系统调用查询子进程是否终结，这其实使得进程拥有等待特定进程执行完毕的能力。
	进程退出执行后被设置为僵死状态，直到它的父进程调用wait()或waitpid()为止。
	
<7>通常创建新的进程都是为了立即执行新的、不同的程序，而接着调用exec()这组函数就可以创建新的地址空间，并把新的程序载入其中。

<8>进程的另一个名字是任务(task)。linux内核通常把进程也叫作任务。这里通常指的是从内核观点所看到的进程。

3.2 进程描述符及任务结构
1、内核把进程列表存放在叫做任务队列(task list)的双向循环链表中。其中每一项都是task_struct类型，称为进程描述符(process descriptor)结构。
	该结构在<linux/sched.h>中，该描述符中包含了一个具体进程的所有信息。
	
一、分配进程描述符
1、linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色(cache coloring)的目的。//进程创建迅速。
<1>通过预先分配和重复使用task_struct，可以避免动态分配和释放所带来的资源消耗。
<2>由于用slab分配器动态生成task_struct，所以只需在栈底(对于向下增加的栈，向低地址增长，栈底为高地址)或
	栈顶(对于向上增加的栈，向高地址增长)创建一个新的结构thread_info。

	向上增长：向高地址增长；向下增长：向低地址增长  //http://blog.csdn.net/pfanaya/article/details/7043992

<3>每个任务的thread_info结构在它的内核栈的尾端部分(低地址部分)。thread_info中的task域中存放着指向该任务实际task_struct的指针。

二、进程描述符的存放
1、PID标识每一个进程，pid_t类型(实际上是int型)
<1>为了与老版本兼容，最大默认设置为32768(short int的最大值)。可以通过/proc/sys/kernel/pid_max来提高上限。
<2>PID保存在进程描述符中。

2、内核中，访问任务通常需要获得指向其task_struct的指针。
<1>current宏查找当前正在运行进程的进程描述符。


















	
	
	
	
	
	
	
	
	
	
	












