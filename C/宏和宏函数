http://m.blog.csdn.net/blog/bytxl/46007849
http://www.cnblogs.com/dong008259/archive/2011/12/27/2302625.html

1、要写好C语言，漂亮的宏定义是非常重要的。宏定义可以帮助我们防止出错，提高代码的可移植性和可读性等。
在软件开发过程中，经常有一些常用或者通用的功能或者代码段，这些功能既可以写成函数，也可以封装成为宏定义。
那么究竟是用函数好，还是宏定义好？这就要求我们对二者进行合理的取舍。
   
<1> 我们来看一个例子，比较两个数或者表达式大小，首先我们把它写成宏定义：
#define MAX(a, b) ( (a) > (b) (a) : (b) )
其次，把它用函数来实现：
int max(int a, int b)
{
    return (a > b a : b)
}

很显然，我们不会选择用函数来完成这个任务，原因有两个：
1)首先，函数调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆栈。
这种开销不仅会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都比函数更胜一筹；
2)其次，函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用，我们如果要比较两个浮点型的大小，就不得不再写一个专门针对浮点型的比较函数。
反之，上面的那个宏定义可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“>”操作符比较值大小的类型，也就是说，宏是与类型无关的。
3)和使用函数相比，使用宏的不利之处在于每次使用宏时，一份宏定义代码的拷贝都会插入到程序中。除非宏非常短，否则使用宏会大幅度增加程序的长度。

<2> 还有一些任务根本无法用函数实现，但是用宏定义却很好实现。比如参数类型没法作为参数传递给函数，但是可以把参数类型传递给带参的宏。
#define MALLOC(n, type) ((type *) malloc((n)* sizeof(type)))
利用这个宏，我们就可以为任何类型分配一段我们指定的空间大小，并返回指向这段空间的指针。

我们可以观察一下这个宏确切的工作过程：
int *ptr;
ptr = MALLOC(5, int);
将这宏展开以后的结果：
ptr = (int *)malloc((5) * sizeof(int));

2、下面总结和宏和函数的不同之处，以供大家写代码时使用，这段总结摘自《C和指针》一书。

     属性                     #define宏                                               函数
 
   代码长度             每次使用时，宏代码都被插入到程序中                 函数代码只出现于一个地方：每次使用这个函数时，
                     除了非常小的宏之外，程序的长度将大幅度增长                   都调用那个地方的同一份代码
 
   执行速度                     更快                                            存在函数调用、返回的额外开销

                      宏参数的求值是在所有周围表达式的上下文环境里，           函数参数只在函数调用时求值一次，
   操作符优先级       除非它们加上括号，否则邻近操作符的优先级可能              它的结果值传递给函数。
		      产生不可预料的结果                                       表达式的求值结果更容易预测。
 
    参数求值        参数用于宏定义时，每次都将重新求值，由于多次求值，         参数在函数调用前只求值一次，
	                 具有副作用的参数可能会产生不可预测的结果。           在函数中多次使用参数并不会导致多次求值过程，
									    参数的副作用并不会造成任何特殊问题。

    参数类型           宏与类型无关，只要参数的操作是合法的，                函数的参数是与类型有关系的，如果参数的类型不同，
	                    它可以用于任何参数类型。                        就需要使用不同的函数，即使它们执行的任务是相同的。
 
 
3、使用宏的注意点
<1>关于宏函数操作符优先级的说明：
#define MAX(a,b) ((a)>(b)?(a):(b))
若定义为#define MAX(a,b) (a>b?a:b)
k = MAX(a&0x0f,b&0x0f)
则宏展开就成了k = (i&0x0f>j&0x0f?i&0x0f:j&0x0f)，运算的优先级就错了&位与的优先级低于>。
因此一定要加上括号。
	
<2>消除多余的分号
1)通常情况下，为了使函数模样的宏在表面上看起来像一个通常的C语言调用一样，通常情况下我们在宏的后面加上一个分号。
比如下面的带参宏：MY_MACRO(x);

2)但是如果是下面的情况：
#define MY_MACRO(x) {	/* line 1 */	/* line 2 */	/* line 3 */ }

if(condition())
    MY_MACRO(a);
else
    {...}
这样会由于多出的那个分号产生编译错误。

3)为了避免这种情况出现同时保持MY_MACRO(x);这种写法:
建议把宏定义为这种形式： 
#define MY_MACRO(x) do {/* line 1 */	/* line 2 */	/* line 3 */ } while(0)
这样只要保证总是使用分号，就不会有任何问题。 

<3>Duplication of Side Effects
这里的Side Effect是指宏在展开的时候对其参数可能进行多次Evaluation（也就是取值），
如果这个宏参数是一个函数，那么就有可能被调用多次从而达到不一致的结果，甚至会发生更严重的错误。
1)eg:
#define min(X,Y) ((X) > (Y) ? (Y) : (X))
c = min(a,foo(b)); //不要传入具有副作用打参数如：foo(b)
这时foo()函数就被调用了两次。

2)为了解决这个潜在的问题，我们应当这样写min(X,Y)这个宏： 
#define min(X,Y) ({	typeof (X) x_ = (X);	typeof (Y) y_ = (Y);	(x_ < y_) ? x_ : y_; })
({...})的作用是将内部的几条语句中最后一条的值返回，它也允许在内部声明变量（因为它通过大括号组成了一个局部Scope）。 
typeof构造的主要应用是用在宏定义中。可以使用typeof关键字来引用宏参数的类型。

4、宏函数的示例
<1>define的单行定义
#define maxi(a,b) (a>;b?a:b)
<2>define的多行定义
define可以替代多行的代码，例如MFC中的宏定义（非常的经典，虽然让人看了恶心）
#define   MACRO(arg1,   arg2)   do   {   \
   \
stmt1;   \
stmt2;   \
   \
}   while(0)  
关键是要在每一个换行的时候加上一个 "\ "

<3>宏定义写出swap(x，y)交换函数
#define swap(x, y)\
x = x + y;\
y = x - y;\
x = x - y;

5、ANSI标准中五个预定义的宏名
__LINE__  代表该行代码的所在行号
__FILE__  代表源文件的文件名
__DATE__  宏指令含有形式为月/日/年的串，表示源文件被翻译到代码时的日期
__TIME__
__STDC__   

6、特殊符号的使用
http://blog.csdn.net/dotphoenix/article/details/4345174
<1>#的作用
在C语言的宏中，#的功能是将其后面的宏参数进行字符串化操作(Stringfication)，简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。
#define WARN_IF(EXP)    do{ if (EXP)    fprintf(stderr, "Warning: " #EXP "/n"); }  while(0)

WARN_IF (divider == 0)被替换为
do {
        if (divider == 0)
	fprintf(stderr, "Warning" "divider == 0" "/n");
} while(0);

<2>##的作用
##被称为连接符(concatenator)，用来将两个Token连接为一个Token。注意这里连接的对象是Token就行，而不一定是宏的变量。

1)比如要做一个菜单项命令名和函数指针组成的结构体的数组，并且希望在函数名和菜单项命令名之间有直观的、名字上的关系。那么下面的代码就非常实用：
struct command{
    char* name;
    void (*function) (void);
};
    
#define COMMAND(NAME) { NAME, NAME ## _command } //这里_command并不是宏的变量
	
//然后你就用一些预先定义好的命令来方便的初始化一个command结构的数组了：
struct command commands[] = {
    COMMAND(quit),
    COMMAND(help),
...
}
COMMAND宏在这里充当一个代码生成器的作用，这样可以在一定程度上减少代码密度，间接地也可以减少不留心所造成的错误。
 
2)我们还可以n个##符号连接n+1个Token。 
#define LINK_MULTIPLE(a,b,c,d) a##_##b##_##c##_##d
typedef struct _record_type LINK_MULTIPLE(name,company,position,salary);
//这里这个语句将展开为：typedef struct _record_type name_company_position_salary;
