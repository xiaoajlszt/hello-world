//深入理解计算机系统
1、C语言中数字数据类型的字节数
	C声明			32位机器		64位机器
	char			1				1
	short int		2				2
	int				4				4				
	long int		4				8
	long long int	8				8
	char *			4				8
	float			4				4
	double			8				8

//因此如果要表示整型8个字节范围，建议使用long long int。

<1> C库中的文件<limits.h>中定义了一组常量，用于限定编译器运行的这台机器的不同整型数据类型的取值范围。
比如，其中定义了常量INT_MAX、INT_MIN、UINT_MAX等。

<2>确定大小的整数类型
对于某些程序来说，用某个确定大小的表示来编码数据类型非常重要。
ISO C99标准在文件<stdint.h>中引入了另一类整数类型：它们的声明如intN_t和uintN_t，指定N位有符号和无符号整数。(N可以是8,16,32,64)。
因此，可以通过uint16_t无歧义地声明一个16位无符号变量。
 34 #ifndef __int8_t_defined
 35 # define __int8_t_defined
 36 typedef signed char     int8_t;
 37 typedef short int       int16_t;
 38 typedef int         int32_t;
 39 # if __WORDSIZE == 64
 40 typedef long int        int64_t;
 41 # else
 42 __extension__
 43 typedef long long int       int64_t;
 44 # endif
 45 #endif
 
 47 /* Unsigned.  */
 48 typedef unsigned char       uint8_t;
 49 typedef unsigned short int  uint16_t;
 50 #ifndef __uint32_t_defined
 51 typedef unsigned int        uint32_t;
 52 # define __uint32_t_defined
 53 #endif
 54 #if __WORDSIZE == 64
 55 typedef unsigned long int   uint64_t;
 56 #else
 57 __extension__
 58 typedef unsigned long long int  uint64_t;
 59 #endif

<3>C语言标识并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。
程序员如果希望代码具有最大可移植性，那么除了C语言的整型数据类型的保证取值范围(即取每种类型在16、32、64位机器上的最小取值范围)之外，
不应该假设任何可表示的数值范围，也不应该假设有符号数会使用何种特殊的表示方式。

<4>关于整数数据类型的取值范围和表示，Java标准是非常明确的。
它要求采用补码表示，且取值范围与64位的情况一致。
在Java中单字节数据类型称为byte，且没有long long类型。
这些非常具体的要求都是为了保证无论在什么机器上，java程序运行的表现都能完全一样。


2、凡是带word的都是正数：
WORD 2字节正整数
DWORD 4字节正整数
QWORD 8字节正整数


3、printf 
x/X		unsigned int	输出无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x)
p 		void *			输出16进制形式的指针
d 		int				输出有符号十进制整数
h 		short int
l 		long int	 	与d搭配：%ld=long int   %lld=long long int

64位linux机器中做以下测试：
<1>输出整数
printf("%u\n", 0xffffffffffffffff);
printf("%lu\n",0xffffffffffffffff);
printf("%llu\n",0xffffffffffffffff);
得到结果：
4294967295		//截断
18446744073709551615
18446744073709551615

可见若要输出long，必须要在u\d前面加l。

<2>输出地址
char a[10] = "12345";
printf("%x\n",a);
printf("%p\n",a);
得到结果：
629622c0		//截断
0x7ffc629622c0

可见64位机器中若要得到地址，必须使用p。这里输出的是一个48位的地址。？？？

4、不同的编译器
<1>VS2008等编译器，如果选择Win32编译平台，即使所在机器是64位的，编译出来的程序仍然是32位的。
char a[10] = "12334";
printf("%x\n",a);
printf("%p\n",a);
printf("%u\n", 0xffffffffffffffff);
printf("%lu\n",0xffffffffffffffff);
printf("%llu\n",0xffffffffffffffff);
得到结果：
45f724
0045F724	//输出地址为4个字节，可见仍是32位程序
4294967295
4294967295	//输出long为4个字节，可见仍是32位程序
18446744073709551615

5、为什么64位linux下输出的地址是48位的？
http://bbs.chinaunix.net/thread-4064247-1-1.html
<1>cat /proc/cpuinfo
可以看到：
address sizes   : 40 bits physical, 48 bits virtual			//40位物理地址，48位虚拟地址

64位处理器是指其数据总线位宽是64位，数据总线跟地址总线是不同概念。



















