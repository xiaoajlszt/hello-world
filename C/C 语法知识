1、for循环
<1> for循环有三个表达式:
    第一个表达式进行测试，只在循环开始时执行一次；
    第二个表达式是判断条件，每次执行循环之前进行求值，如果为假则循环结束；
    第三个表达式在每次循环结束时进行计算；

<2> 有时候我们希望for循环判断两个条件来结束循环(表达式2)，有时候希望每次循环结束后改变两个变量的值(表达式3)，可以采用逗号运算符；
    在C语言中，多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别计算，但整个表达式的值是最后一个表达式的值。
    因此for循环的第二个表达式条件判断时应该使用 && 和 || 等关系运算符，而第三个表达式可以使用逗号运算法。
    例：for (i=0,j=0; (i<10)&&(j<5); i+=2,j+=1) //该for语句的作用是，每次循环开始前判断i<10和j<5是否同时成立，循环结束后修改i和j的值。

2、::是C++里的“作用域运算符”
<1>类A中声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成void A::f()，表示这个f()函数是类A的成员函数。
<2>还有一种用法，就是直接用在全局函数前，表示是全局函数。当类的成员函数跟类外的一个全局函数同名时，在类内定义时，打此函数名默认调用的是本身的成员函数；如果要调用同名的全局函数时，就必须打上::以示区别。
比如在VC里，你可以在调用API函数时，在API函数名前加::。

#include "iostream"
using namespace std;

int a = 10;
int main()
{
	int a = 20;
	cout << a << ::a;

	return 0;
}

输出结果： 2010
	
3、cout输出数组名/指针时，字符串数组char []/指针char *：输出整个字符串，其他类型数组/指针：输出首地址。
原因：1、cout对const char*重载了运算符<<，输出字符数组时，就把字符数组转换成char*，将数组\0前的内容全部输出；（等同于输出char *字符串）
      2、其他非字符数组输出数组首地址。
	  如：char a[] = "hello";
          char *p = a;
          cout << "p = " << p << endl                   hello
               << "p = " << (void *) p << endl          0x0032FB2C
               << "*p = " << *p << endl;                h
			   
4、结构体对齐
（一）http://blog.csdn.net/zhongkeli/article/details/7002371
<1>对齐规则：一般来说，结构体的对齐规则是先按数据类型自身进行对齐，然后再按整个结构体进行对齐，对齐值必须是2的幂，比如1，2， 4， 8， 16。
             如果一个类型按n字节对齐，那么该类型的变量起始地址必须是n的倍数。比如int按四字节对齐，那么int类型的变量起始地址一定是4的倍数，比如0x0012ff60，0x0012ff48等。
<2>数据自身对齐：通常是数据类型所占的空间大小，比如int类型占四个字节，那么它的对齐值就是4。
<3>结构体的对齐：整个结构体的对齐值一般是结构体中最大数据类型所占的空间。
eg:struct Test1
  {
      int i ;
      double d ;
      char c ;
  };
  i是int类型，按4字节对齐;d是double类型，按8字节对齐，所以i和d之间空了4字节;c是char类型，按1字节对齐。
  所以整个结构体是 4(i) + 4（补齐）+ 8(d) + 1(c) =  17字节，注意！整个结构体还没有对齐，因为结构体中空间最大的类型是double，
  所以整个结构体按8字节对齐，那么最终结果就是17 + 7（补齐） = 24字节。

（二）http://blog.csdn.net/mcu_hong/article/details/8702912
eg: 1字节对齐后，该结构总长为13字节；去掉对齐后，总长为16字节。
   #pragma pack(push) //保存对齐状态------------
   #pragma pack(1)   // 1 bytes对齐-------------等价于 #pragma pack(push,1)

   typedef struct 
   {
       double dValue1;
       char   u8Value2;
       int    u32Value3;
   } ASampleStructor;
   
   #pragma pack(pop)//恢复对齐状态
   
（三）在ARM平台的编译器中，没有提供象“#pragma pack”这么丰富的带参数对齐指令，只有一个关键字“__packed”。
      __packed 限定符将所有有效类型的对齐边界设置为 1，如果一个结构没有这个限定符，默认向表数能力最强的那个数据类型对齐。
	  
5、C和C++中的sizeof('A')
<1>C语言:
	char a = 'a';
	sizeof(char) = 1
	sizeof(a) = 1
	sizeof('a') = 4
<2>C++语言:
	char a = 'a';
	sizeof(char) = 1
	sizeof(a) = 1
	sizeof('a') = 1
  存在问题：字符型变量是1字节这个没错，奇怪就奇怪在C语言认为'a'是4字节，而C++语言认为'a'是1字节？？？？
  原因如下:
  <1>C99标准的规定，'a'叫做整型字符常量(integer character constant)，被看成是int型，所以在32位机器上占4字节。
  <2>ISO C++标准规定，'a'叫做字符字面量(character literal)，被看成是char型，所以占1字节。

6、printf输出：
   d / i       int         接受整数值并将它表示为有符号的十进制整数，i是老式写法 
     u     unsigned int    无符号10进制整数 
   x / X   unsigned int    无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x) 
     c         char        字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 

7、函数原型的使用
   函数原型：int max(int,int);或int max(int a,int b);
   函数声明：int max();
<1>使用函数原型，是为了在编译器编译第一个调用该函数的语句之前，告知编译器该函数的使用方法。
<2>函数声明形式是不够准确的，只声明了函数返回值类型，没有声明其参数。当调用函数时，参数类型或参数个数错误，编译器并不能发现这种错误。
<3>无参数的函数原型void print_name();最好写成void print_name(void); 否则编译器会认为没有函数原型，编译器不会进行参数检查；
<4>若不使用函数原型，也可以通过在首次调用某函数之前对该函数进行定义，这样函数的定义部分就和函数原型有着相同的作用（适用于小函数）。
  
8、变量申明必须用extern，否则视为定义

9、字符串常量是有地址的，其他常量没有地址
    const常量本质并不是常量，只是表示只读，因此有地址

10、volatile关键字  http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html
<1>volatile关键字是一种类型修饰符，它声明的类型变量表示可以被某些编译器未知的因素更改，如：操作系统、硬件、其他线程等。。
<2>遇到volatile声明的变量，编译器对访问改变了的代码不再进行优化，从而可以提供对特殊地址的稳定访问。
系统总是重新从它所在的内存读取数据，即使之前的指令刚刚从该处读取过数据。

11、static
http://www.cnblogs.com/stoneJin/archive/2011/09/21/2183313.html

12、switch中的打印：
int main()
{
	int a = 100;

	switch(a)
	{
		printf("enter switch!");
		
	    case 100:
			printf("a=100!");
			break;
		default:
			printf("default!");
			break;
	}
	
	return 0;
}

switch直接跳到case分支，该段代码中的 printf("enter switch!"); 是不会打印出来的！！！

13、restrict关键字  http://blog.csdn.net/llf021421/article/details/8092602
<1>restrict是c99标准引入的，它只可以用于限定和约束指针，并表明该指针是访问一个数据对象的唯一且初始的方式。
即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改，而不能通过其它途径(其它变量或指针)来修改；
这样做能帮助编译器进行更好的优化代码，生成更有效率的汇编代码。
<2>关键字restrict有两个读者。一个是编译器，它告诉编译器可以自由地做一些有关优化的假定。
另一个读者是用户，它告诉用户仅使用满足restrict要求的参数。
一般，编译器无法检查您是否遵循了这一限制，如果您蔑视它也就是在让自己冒险。





