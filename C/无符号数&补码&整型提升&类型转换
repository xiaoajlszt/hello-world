1、有符号数和无符号数
<1>大多数数字都默认是有符号的，如:声明如12345或0x1A2B常量时，这个值被认为是有符号的。要声明无符号常量必须加上后缀u\U,如：12345u；
<2>原码、反码、补码都是针对有符号数的；无符号数采用向量编码。(详见深入理解计算机系统)
    注：计算机有符号数基本使用补码方式表示，如：计算器中输入-80，转换为16进制数0xFFFFFFB0，即用补码表示。
<3>同时包含有符号和无符号数表达式的处理：
    执行运算时，如果一个运算数是有符号的，另一个运算数是无符号的，那么C语言会隐式地将有符号参数强制转换为无符号数，并假设这两个数都是非负数，来执行这个运算。
	
2、http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html  原码 反码 补码 （针对有符号数）
eg: -80在计算器中16/2进制显示为0xffffffffffffffb0，其实显示的就是其补码形式。
<1>正数的反码是其本身;负数的反码是在其原码的基础上, 符号位不变，其余各各位取反.
<2>正数的补码就是其本身;负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)(实际是加了-1)
<3>补码表示：将字的最高位表示为负权（负的2的位数-1次方），value = -符号位*（2的位数-1次方）+ 低位的值
   反码表示：将字的最高位表示为负权（负的（2的位数-1次方 - 1）），value = -符号位*（2的位数-1次方 - 1）+ 低位的值
   原码表示：最高位是符号位，不参与计算，只用于确定其他位取负权还是正权

3、数字有符号&无符号之间的转换
                       原码1--补码--原码2
对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但位模式保持不变。
<1>有符号数转无符号数：
   short v = -12345;
   unsigned short uv = (unsigned short)v;
   printf("v=%d,uv=%u\n",v,uv);//输出：v=-12345,uv=53191
   原因：-12345补码cfc7，uv也为cfc7，即为53191
        <1>-12345的16位补码表示与53191的16位无符号表示是完全一样的。
		<2>强制类型转换保持位值不变，只是改变了解释这些位的方式。将short强制转换为unsigned short改变数值，但不改变位表示。
<2>无符号数转有符号数：
   unsigned u = 4294967295u;//0xffffffff
   int     tu = (int)u;
   printf("u=%u,tu=%d",u,tu);//输出:u=4294967295,tu=-1
   原因：<1>对于32位字长来说，无符号形式的4294967295和补码形式的-1的位模式是完全一样的。
         <2>将unsigned转换为int，底层位表示保持不变。

4、扩展一个数字的位（保持数值不变，内存中扩充补码表示）
<1>将一个无符号数转换为一个更大的数据类型，只需在表示的开头添加0，这种运算称为0扩展；
<2>将一个补码数字转换为一个更大的数据类型，可以采用符号扩展，在表示中添加最高有效位的副本。(添加符号位)

5、数字截断
eg: int x = 53191;
    short sx = (short)x;//-12345
	int y = (int)sx;//-12345
	
6、整数运算
<1>无符号数加法：（10进制数相加结果转换为2进制或直接2进制数相加）丢弃溢出位；
<2>补码加法：补码相加（10进制数相加结果转换为2进制或直接2进制数相加），丢弃溢出位（可能是符号位,如5+5=01010->1010=-6），得到结果的补码。（以4位补码加法为例，可能情况：不变，+16，-16）
<3>无符号数的乘法：（10进制数相乘结果转换为2进制）丢弃溢出位
<4>补码的乘法：（10进制数相乘结果转换为2进制）丢弃溢出位

7、移位运算
<1>左移（<<）:算术左移和逻辑左移保持一致，都是在末尾增加0；
<2>右移（>>）:逻辑右移就是不考虑符号位,右移一位,左边补零即可.
              算术右移需要考虑符号位,右移一位,若符号位为1,就在左边补1;否则,就补0.
			  一般说来无符号数采用逻辑右移；带符号数采用算术右移.
              所以算术右移也可以进行有符号位的除法,右移n位就等于除2的n次方.
              例如,8位二进制数11001101分别右移一位.逻辑右移就是[0]1100110,算术右移就是[1]1100110 

8、整型提升
<1>定义：K＆R C中关于整型提升(integral promotion)的定义为："A character, a short integer, or an integer bit-field, all either signed or not, 
                                                            or an object of enumeration type, may be used in an expression wherever an integer maybe used. 
															If an int can represent all the values of the original type, then the value is converted to int; 
															otherwise the value is converted to unsigned int. This process is called integral promotion."
         在一个表达式中，凡是可以使用整型的地方都可以使用带符号或无符号的字符、短整型、整型位字段、枚举类型对象。如果原始类型的所有值可以用int类型表示，那么原始类型的
		 值将被转化为int；否则的话，其值将被转换为unsigned int。这一过程就称为整型提升。	 
<2>eg:  char c1 = 4;
		char c2 = 5;
		sizeof(c1+c2); 的结果为4，发生整型提升
		sizeof('A');   的结果为4，但不是整型提升（C与C++的区别所在，C 语法知识笔记）
		sizeof(c1);    的结果为1，未发生整型提升(注：ANSI C规定，编译器如果能保证保证运算结果一致，也可以省略类型提升的操作――这通常出现在表达式中存在常量操作数的时候)
		//注：sizeof是操作符(运算符)
   eg： unsigned char a, b;  
		a = 0x0f;  
		b = (~a) >> 4;  
		printf("0x%x", b);  //输出：0xff  (%x:无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x))
		原因： (~a) 被提升为 int 型的取反运算。对于 MinGW gcc，int 型是 32 位，因此 (~a) = 0xff ff ff f0，所以 b = 0xff。
		
9、类型转换
<1>当出现在表达式里，有符号和无符号的char和short类型都将自动转换为int，在需要的情况下，将自动转换为unsigned；（转换成较大的类型）
 eg:char c1,c2;
    c1=c1+c2;//在运算时，c1和c2都先被提升为int类型进行运算，运算结果再裁减为char类型。
<2>在包含两种数据类型的任何运算中，两个值都被转换成两种类型中较大的类型；
<3>在赋值语句中，计算的最终结果被转换成将要被赋予值的那个变量的类型；（可能出现扩展也可能出现截断）
<4>当作为函数参数被传递时，char和short会被转换为int，float会被转换为double，可以通过函数原型（声明参数个数以及参数类型（详见C primer plus 222页））来阻止自动提升的发生。
    http://blog.csdn.net/yuan1125/article/details/6412951   （函数原型的重要性）
<5>用作条件表达式被转换为bool类型。如：int a; if(a)/while(a);a被转换为bool型

10、<1> 8进制以0开头，如 0173 01777等;16进制以0x开头
    <2> 十进制整数字面值可能是int、long、unsigned long类型，缺省情况下，它是最短类型但能完整容纳这个值
	<3> 字符常量类型总是int，不能添加unsigned或long后缀
	
11、整型提升，算术转换 例子 （http://blog.csdn.net/cherish_2012/article/details/21243047）
    <1> unsigned a = 0; int b = -1; a = b;//结果 a = 4294967295
	<2> int a = -1; unsigned b = 255; unsigned c = a - b;//结果c=0xFFFFFF00;(4294967040)
	                                  int c = a - b;//结果为c=0xFFFFFF00;(-256)
	<3> int a = -1; unsigned b = 255; unsigned c = a + b;//结果c=254;(因为-1转换为无符号之后为全F，相加之后会溢出，结果为254)(给人感觉是255-1，其实不是)