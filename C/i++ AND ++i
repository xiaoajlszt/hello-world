网上看到的结果 		执行效率从高到底依次是：++i -> i++ -> i += 1 -> i = i + 1	
	i=i+1的实现：	读取右i的地址; i+1; 读取右i的地址; 将右值传给左边的i(编译器并不认为左右i的地址相同);
	i+=1的实现：	读取i的地址; i+1; 将得到的值传给i;
	i++的实现：		读取i的地址; i自增1;
	
	i++的实现是：	int temp；temp = i; i = i+1; return temp;  
	++i的实现是：	i = i+1；return i; 
	
	i+=1 比 i++ 多了一次赋值; i++ 比 ++i 多了一次复制。

目前的编译器上		若i是内置的数值类型，完全一样; 若i是一些自定义的类，如iterator, ++i的效率 >= i++的效率.

-----------------------------------------------------------------------------------------------------------------

1、a++和++a可不可以作为左值
<1> 首先说左值和右值的定义： 
    变量和文字常量都有存储区，并且有相关的类型。区别在于变量是可寻址的（addressable）对于每一个变量都有两个值与其相联：
  1)它的数据值，即存储在某个内存地址中。有时这个值也被称为对象的右值（rvalue,读做are-value），也可认为右值的意思是被读取的值（read value）。文字常量和变量都可被用作右值。
  2)它的地址值，即存储数据值的那块内存的地址。它有时被称为变量的左值（lvalue，读作ell-value），也可认为左值的意思是位置值。文字常量不能被用作左值。

<2> a++和++a在做左值的时候有不同，那么左值它首先必须是有特定地址的才能作为左值，否则赋值就没有具体对象。
    a++的意思是先复制一份临时数据出来参与周边环境的运算，再自加变量a，可见a++用来参与运算的是一份复制出来的临时数据，这个数据是临时存在而没有固定地址的，不是一个真正的变量。
	++a的意思是先自加变量a，再将变量放到周边环境参与运算，那么++a用来参与运算的是有具体地址的变量，所以++a是可以作为左值使用的。
    具体一点可以理解为：a++返回一个临时变量，++a返回变量的引用。
          i++的实现是：int temp；temp = i; i = i+1; return temp;  
		  ++i的实现是：i = i+1；return i;              
    i++=5;是错误的是因为i++返回的是编译器自动分配的临时变量temp，而这个temp并不是程序中定义的可寻址变量的引用，也就是说你不能通过地址对temp进行操作，不能作为左值。
    ++i=5;是正确的就是因为其返回值就是i;

2、函数参数压栈顺序 - 从右往左
解释一：因为C++支持可变长函数参数。正是这个原因使得Ｃ语言函数参数入栈顺序为从右至左。
具体原因为：C方式参数入栈顺序（从右至左）的好处就是可以动态变化参数个数。
Ｃ程序栈底为高地址，栈顶为低地址。函数最左边确定的参数在栈上的位置必须是确定的，否则意味着已经确定的参数是不能定位和找到的，这样是无法保证函数正确执行的。
衡量参数在栈上的位置，就是离开确切的函数调用点（call f）有多远。已经确定的参数，它在栈上的位置，不应该依赖参数的具体数量，因为参数的数量是未知的！
所以只有确定的参数最后入栈才能保证它在栈中的位置是确定的。

私人看来, 左边的参数总是最重要, 并且最频繁使用的参数, 所以最后压栈, 读取更快。

解释二：
http://blog.csdn.net/FreeApe/article/details/48999063
这只是cdecl 调用约定 而已，也可以不这么传参，pascal调用约定从左到右传参，win64 ABI的调用约定左面4个参数优先使用寄存器传递，也不是从右开始的。

3、一些例子
http://blog.csdn.net/FreeApe/article/details/48999063
"x++，是将计算结果存放到栈空间，最后是要出栈的；"
"++x和x是将计算结果直接存放到某个寄存器变量中（是同一个），所以计算完最后输出时，++x和x的结果总是相同的。"
这两句话是以上博文中的解释，但是本人更认可1<2>中的解释：
x++返回结果在临时变量中，因此x值变化x++不会变化；
++x与x返回结果仍为x，因此x值变化++x也会变化。

eg 1：
int x=5;   printf("%d %d\n",x,x++);  
int y=5;   printf("%d %d\n",y++,y);  
int z=5;   printf("%d %d %d\n",z,z++,z);  
int w=5;   printf("%d %d %d %d\n",w,++w,w++,w); 

/*输出结果*/
6 5       
5 6
6 5 6
7 7 5 7 

解释：
从右至左计算，对于x，x++为5，压入栈中，再是x,为6，放寄存器中，然后输出，则输出6 5；
从右至左计算，对于y,先是计算y,这时值是5，放入寄存器中，然后计算y++，结果还是5，压入栈中，但是寄存器中值变了，为6，最后开始输出。输出的话，是压入栈（y++）中的就输出对应的值，不是压入栈(y)的就都是寄存器中的值。
从右至左计算，对于z，z为5，放寄存器中，z++，还为5，压入栈中，z则为6了，寄存器值改变为6，然后输出，则输出为6 5 6；
同理可得其他的计算结果。	
	
eg 2：
int a = 1; 
printf("%d %d %d %d %d %d\n",a++, ++a, a++, ++a, a++, ++a );

结果：6  7  4  7  2  7

eg 3：
void f(int a,int b,int c)
{
	printf("%d\n",a);   //7
	printf("%d\n",b);   //8
	printf("%d\n",c);   //5
}

int main()
{
	int i = 5;
	f(i++,++i,i++);
	
	return 0;
}

解释：从右至左，i++压入栈中5，之后i变为6；++i先加，i变为7，放入某个寄存器中；i++压入栈中7，之后i变为8，寄存器中的i也变为8。
因此输出为 7  8  5


注意：这些结果都是发生在进入函数内部实现之前，因此与C语言的按值传递原则并不矛盾！！！！
