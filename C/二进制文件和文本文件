一、传输模式：(ASCII模式 和 Binary模式)
1、只有文本文件(例如html文件)可以使用ASCII传输模式，其他文件通通使用Binary传输模式(图像、压缩、可执行文件等)。
<1>文本文件也称为ASCII文件，其文件内容遵循ASCII的定义，其主要特征是文件内容由若干行组成，
可以使用操作系统的显示、编辑命令来显示和编辑ASCII文件的内容，它使用的传输模式是asc；

<2>二进制文件是指除ASCII文件以外的所有文件格式，它使用的传输模式是bin；

<3>需要注意的是，可以将ASCII文件按二进制模式传输，但决不能将二进制文件按ASCII模式传输，
否则二进制文件的内容会遭到破坏而无法使用。

2、ASCII传输方式：假定用户正在拷贝的文件包含的简单ASCII码文本，如果在远程机器上运行的不是UNIX，
当文件传输时ftp通常会自动地调整文件的内容以便于把文件解释成另外那台计算机存储文本文件的格式。 

但是常常有这样的情况，用户正在传输的文件包含的不是文本文件，它们可能是程序，数据库，字处理文件或者压缩文件
（尽管字处理文件包含的大部分是文本，其中也包含有指示页尺寸，字库等信息的非打印字符）。
在拷贝任何非文本文件之前，用binary命令告诉ftp逐字拷贝，不要对这些文件进行处理。
 
3、二进制传输模式：在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。即使目的地机器上包含位序列的文件是没意义的。
例如，macintosh以二进制方式传送可执行文件到Windows系统，在对方系统上，此文件不能执行。 
　　
如果你ASCII方式下传输二进制文件，即使不需要也仍会转译。这会使传输稍微变慢，也会损坏数据，使文件变得不能使用。
（在大多数计算机上，ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。如果你传输二进制文件，所有的位都是重要的。）

4、如果两台机器是同样的，则二进制方式对文本文件和数据文件都是有效的。

二、文本文件 和 二进制文件
1、解释一：
两者并无本质的区别，或者可以说，文本文件是某种特殊的二进制文件。
<1>如果某个文件的内容是3C 68 74 6D 6C 3E 0D 0A，用记事本打开显示的就是<html>。

<2>如果一个文件的内容是42 4D C6 9E 04 00 00 00  00 00 36 00 00 00 28 00，用画图软件打开时，
因为他的前两个字符是BM，会被解释为一个位图文件，从而按照位图文件的读取规则来读取其中的内容，显示的就是一张图片。
而如果用记事本打开，会将其中的内容按照文本内容来读取，看到的就是BM ...

<3>文本文件和二进制文件并无本质的差别，他们的区别在于打开这个文件的程序在对其内容的解释上，
我们可以把一个典型的所谓二进制文件(bmp)当作文本文件来打开，是同样可以的，只是得到的内容就是一些乱七八糟的符号了。反过来，也是同样成立。

2、解释二：
要弄明白二者的区别，需要知道文件的读写过程。
<1>以读文件为例，实际上是 磁盘 -> 文件缓冲区 -> 应用程序内存空间 这两个转化过程。
"文本文件和二进制文件没有区别"的说法，实际上针对的是第一个过程；
既然没有区别，那么打开方式不同，为何显示内容就不同呢？这个区别实际上是第二个过程造成的。

<2>文件实际上包括两部分，控制信息和内容信息。纯文本文件仅仅是没有控制格式信息罢了；实际上也是一种特殊的二进制文件。
所以，我们很难区分二者的不同，因为他们的概念上不是完全互斥的。
我们说文本文件是特殊的二进制文件，是因为文本文件实际上的解释格式已经确定了：ASCII或者unicode编码。

<3>文本文件的一个缺点是，它的熵往往较低，也就是说，其实本可以用更小的存储空间记录这些信息。
比如，文本文件中的一个数字65536，需要用5个字节来存储；但是用二进制格式，采用int存储，仅仅需要2个字节。
而二进制文件elf和bmp等，都往往有一个head，告诉你文件信息和解释方式。

3、解释三：
广义上的二进制文件包括文本文件，这里讨论的是狭义上的二进制文件与文本文件的比较：
<1>能存储的数据类型不同     
文本文件只能存储char型字符变量。     
二进制文件可以存储char/int/short/long/float/……各种变量值。

<2>每条数据的长度     
文本文件每条数据通常是固定长度的。以ASCII为例，每条数据(每个字符)都是1个字节。     
二进制文件每条数据不固定。如short占两个字节，int占四个字节，float占8个字节……

<3>读取的软件不同     
文本文件编辑器就可以读写。比如记事本、NotePad++、Vim等。     
二进制文件需要特别的解码器。比如bmp文件需要图像查看器，rmvb需要播放器……

<4>操作系统对换行符('\n')的处理不同（不重要）     
文本文件，操作系统会对'\n'进行一些隐式变换，因此文本文件直接跨平台使用会出问题。
在Windows下，写入'\n'时，操作系统会隐式的将'\n'转换为"\r\n"，再写入到文件中；读的时候，会把“\r\n”隐式转化为'\n'，再读到变量中。
在Linux下，写入'\n'时，操作系统不做隐式变换。

二进制文件，操作系统不会对'\n'进行隐式变换，很多二进制文件（如电影、图片等）可以跨平台使用。

4、存储方式
二进制文件和文本文件在磁盘中都是按照01的方式存储的。

三、不同语言中的使用
1、Python中的不同操作方式
<1>StringIO内存中操作字符串
<2>BytesIO内存中操作二进制数据
<3>f = open('/Users/michael/test.txt', 'r')  读文本文件
<4>f = open('/Users/michael/test.txt', 'rb') 读二进制文件

2、Linux不区分文本文件和二进制文件
<1>linux fopen等分析
http://blog.csdn.net/pingnanlee/article/details/9671365
w、r等形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合。加入b字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。
不过在POSIX系统，包含Linux都会忽略该字符。

四、相关函数的使用
1、EOF判断文件结尾
http://blog.csdn.net/bingqing07/article/details/5785080/

stdio.h中  #define  EOF  (-1)		//32位机器中即为0xffffffff

<1>EOF是不可输出字符，因此不能在屏幕上显示。由于字符的ASCII码不可能出现-1，因此EOF定义为-1是合适的。
当读入的字符值等于EOF时，表示读入的已不是正常的字符而是文件结束符，但这适用对文本文件的读写。

<2>在二进制文件中，信息都是以数值方式存在的。EOF的值可能就是所要处理的二进制文件中的信息。这就出现了需要读入有用数据却被处理为"文件结束"的情况。

<3>为了解决这个问题，C提供了一个feof()函数，可以用它来判断文件是否结束。
feof（fp）用于测试fp所指向的文件的当前状态是否为“文件结束”。如果是函数则返回1；否则返回0。

<4>但是说EOF只能用于文本文件，其实不然，这点不是特别的准确，还要看定义的变量的类型。

下面这段程序对文本文件和二进制文件都可以：
int c;
while((c=fgetc(fp)) != EOF)
{
	printf("%X/n", c); 
}
如果读到了FF，由于c定义为int型，所以实际上c=0x000000FF，不等于EOF(-1=0xFFFFFFFF)，因此不会误判为文件结尾。

但是如果把c定义为char类型，就有可能产生混淆了。
char c;
while((c=fgetc(fp)) != EOF)
{
	printf("%X/n", c); 
}
因为文本文件中存储的是ASCII码，而ASCII码中FF代表空值(blank)，一般不使用，所以如果读文件返回了FF，说明已经到了文本文件的结尾。
但是如果是二进制文件，其中可能会包含FF，因此不能把读到EOF作为文件结束的条件。

2、feof()
#define  _IOEOF  0x0010 
#define  feof(_stream)  ((_stream)->_flag & _IOEOF)

在VC里，只有当文件位置指针(fp->_ptr)到了文件末尾，然后再发生读/写操作时，标志位(fp->_flag)才会被置为含有_IOEOF。然后再调用feof()，才会得到文件结束的信息。

因此，如果运行如下程序：
char c;
while(!feof(fp))
{
	c = fgetc(fp);
	printf("%X/n", c); 
}
会发现多输出了一个FF，原因就是在读完最后一个字符后，fp->flag仍然没有被置为_IOEOF，因而feof()仍然没有探测到文件结尾。
直到再次调用fgetc()执行读操作，feof()才能探测到文件结尾。这样就多输出了一个-1(即FF)。

正确的写法应该是：
char c;
c = fgetc(fp);
while(!feof(fp))
{
	printf("%X/n", c); 
	c = fgetc(fp);
} 

3、fgets和feof配合使用
<1>fgets 是读取文件中的一行，当读文件过程中发生错误或者读到文件尾时，返回NULL。
所以不能使用fgets==NULL来判断是否到了文件尾，需要结合feof(NULL) 才能确定是否到了文件尾。

<2>
while(!feof(fp))
{
	fgets(temp,100,fp);
	Operation(temp);
}

这种判断是否到了文件尾的方式在存在错误的，因为fgets函数是遇到回车\r符返回的。
所以在读到最后一行时，它的文件指针并没有指向文件尾，而是指向\r处，feof依然返回0(文件还没结束)，所以这时operations还是会执行。

<3>应该修改为这种形式
while(1)
{
	fgets(temp,100,fp);
    if(feof(fp)) 
	{
		break;
	}
	operation(temp);
}

注：
<1>vim/cat 查看配置文件global_conf.ini内容时，末尾是没有空行的；nodepad++ 查看配置文件global_conf.ini内容时，末尾是有空行的。
因此只需要使用nodepad++打开配置文件，并删除最后一个空行，这样<2>中就不会出现多读的现象。

<2>也可以通过增加0 != ferror(file_stream)的判断，这样虽然多读了，但可以避免文件末尾报错的情况。
void ls_load_global_config(void)
{   
    FILE * file_stream = NULL;
    char line_buf[512];

    if(NULL == (file_stream = fopen("global_conf.ini", "r")))
    {
        printf("fopen config file fail!\n");
        return ;
    }

    while(!feof(file_stream))
    {
        if(NULL == fgets(line_buf, 512, file_stream) && 0 != ferror(file_stream))
        {
            printf("fgets config file return NULL! ferror:%d.", ferror(file_stream));
            fclose(file_stream);
            return ;
        }
        
        if('/' == line_buf[0] || ' ' == line_buf[0] || '\r' == line_buf[0] || '\n' == line_buf[0])
        {
            continue;
        }
    }

    fclose(file_stream);
} 