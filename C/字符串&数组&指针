字符串/数组小节：
1、数组名是一个地址常量，不能执行自增运算；指针是变量，可以执行自增运算。（数组中的元素是变量，但数组名是常量！！！）
   
   根本原因是表达式中的数组除作为sizeof和&的操作数外，会隐式转换为右值指针类型？？？，不能作为赋值运算符的左操作数。

2、例如：char *p1 = "i love u"; char p2[] = "i hate u";
   p1 = p2;(正确)
   p2 = p1;(错误)
   原因：常量可以赋值给变量；变量不可赋值给常量。
   
3、例如：char *p1 = "i love u"; char p2[] = "i love u";
   p1[1] = 'a';(错误)
   *(p2+1) = 'a';(正确)
   原因：字符串数组中只是字符串常量的拷贝，可以改变值；而指向字符串的指针指针指向内存中的字符串常量，不能改变。
   初始化一个指向字符串文字(常量)的指针时建议使用const修饰符：const char *p1 = "i love u";

4、例如：char *p1 = "i love u";字符串指针p1表示字符串"i love u "的地址，该字符串存储在存放常量的那部分内存中。（整个引号中的内容作为指向该字符串存储位置的指针）
   通常不能使用关系运算符＝＝/!=来比较两个字符串，只能用strcmp() 函数来处理，因为字符串实质是地址，通常两者不会相等的（除了字符串文字）。(见C Primer Plus 300页上方)
 例 char str1[] = "abc";
	char str2[] = "abc";
	const char str3[] = "abc";
	const char str4[] = "abc";
	const char *str5 = "abc";
	const char *str6 = "abc";
	char *str7 = "abc";
	char *str8 = "abc";
	cout << ( str1 == str2 ) << endl;
	cout << ( str3 == str4 ) << endl;
	cout << ( str5 == str6 ) << endl;
	cout << ( str7 == str8 ) << endl;
	结果是：0 0 1 1
	str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。

5、为数组赋值:
 例 int a[4] = {5,4,3,2};int b[4];
    b = a;//错误!
	b[4] = a[4];//错误！
    b[4] = {5,4,3,2};//错误！
	原因：C不支持把数组作为一个整体来进行赋值，也不支持用花括号括起来的列表进行赋值（初始化时除外）。声明完数组后，只能借助索引（下标）对数组成员进行赋值！(或借助strcpy等函数)
 例 char a[20];char *b = "i love u";
    a = "i love u";//错误！数组名是常量，不能被赋值。
	b = "abc";//正确！
	b = a;//正确！ 
	strcpy(a,"Hi!");//正确！

6、注意点
<1>使用数组时不能越界，编译器不会检查是否越界，因此会造成不可估量的错误。
<2>声明一个数组会为数据分配存储空间；而声明一个指针只为一个地址分配存储空间！（不管有没有初始化）
<3>我们在删除一个指针之后（free/delete），编译器只会释放该指针所指向的内存空间，而不会删除这个指针本身。
   该指针会变成野指针！！指向一个已删除的对象或未申请访问受限内存区域的指针。
   因此，在删除一个指针之后，一定将该指针设置成空指针（即在delete *p之后一定要加上： p=NULL）

7、经典问题：
 <1>#include<stdio.h>
    char *returnStr()
	{
		char *p="hello world!";
		return p;
	}
	int main()
	{
		char *str=NULL;
	    str=returnStr();
		printf("%s\n", str);
		return 0;
	}
 <2>#include<stdio.h>
	char *returnStr()
	{
		char p[]="hello world!";
		return p;
	}
	int main()
	{
		char *str=NULL;
		str=returnStr();
		printf("%s\n", str);
		return 0;
	}
    现象：<1>正常输出字符串，正确；<2>输出乱码，错误。
	原因分析：代码<1>没有任何问题，因为"hello world!"是一个字符串常量，存放在静态数据区，把该字符串常量存放的静态数据区的首地址赋值给了指针，
	          所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。
			  代码<2>"hello world!"是一个字符串常量，存放在静态数据区，没错，但是把一个字符串常量赋值给了一个局部变量(char []型数组)，该局部变量存放在栈中，
			  这样就有两块内容一样的内存，也就是说“char p[]="hello world!";”这条语句让“hello world!”这个字符串在内存中有两份拷贝，一份在动态分配的栈中，
			  另一份在静态存储区,这是与前者最本质的区别。当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，所以这时的函数返回的是一个已被释放的内存地址，
			  所以打印出来的是乱码。
    特殊说明：只有返回指针或者引用才会出现以上情况，若返回数值内容本身，虽然函数结束，局部变量被回收，但也能正常显示输出。

8、strlen与sizeof
 例：char ss[100]=”0123456789”;
     Sizeof(ss)结果为100，ss表示在内存中预分配的大小，100*1；
     Strlen(ss)结果为10，它的内部实现是用一个循环计算字符串的长度，直到”\0”为止。
	 
     int ss[100]=”0123456789”;
     Sizeof(ss)结果为400，ss表示在内存中的大小，100*4；
     Strlen(ss)错误，strlen的参数只能是char*，且必须是以”\0”结尾的。
	 
	 char* ss = "0123456789"; 
     sizeof(ss) 结果 4 ＝＝＝》ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是4 
     sizeof(*ss) 结果 1 ＝＝＝》*ss是第一个字符 其实就是获得了字符串的第一位'0' 所占的内存空间，是char类 型的，占了 1 位 
     strlen(ss)= 10 >>>> 如果要获得这个字符串的长度，则一定要使用 strlen
	 
	 char * parr = new char[10];
     int len_one = strlen(parr);
     int len_two = sizeof(parr);
	 int len_three = sizeof(*parr);
     cout << len_one << " and " << len_two << " and " << len_three << endl;
    输出结果：23 and 4 and 1
    点评：第一个输出结果23实际上每次运行可能不一样，这取决于parr里面存了什么（从parr[0]开始直到遇到第一个NULL结束）；
	第二个结果实际上本意是想计算parr所指向的动态内存空间的大小，但是事与愿违，sizeof认为parr是个字符指针，因此返回的是该指针所占的空间（指针的存储用的是长整型，所以为4）;
	第三个结果，由于*parr所代表的是parr所指的地址空间存放的字符，所以长度为1。

 <1>sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。
    它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
    由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。
    具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：
    数组――编译时分配的数组空间大小；
    指针――存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
    类型――该类型所占的空间大小；
    对象――对象的实际占用空间大小；
    函数――函数的返回类型所占的空间大小。函数的返回类型不能是void。
 <2>strlen是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。返回字符串的长度,返回的长度大小不包括NULL。
 <3>sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以”\0”结尾的。sizeof还可以用函数做参数，
    比如：short f();printf(“%d\n”,sizeof(f()));输出的结果是sizeof(short)，即2。
 <4>数组做sizeof的参数不退化，传递给strlen就退化为指针。
 <5>sizeof后如果是类型必须加括号，如果是变量名可以不加括号。这是因为sizeof是个操作符而不是函数。
 
9、指针类型不能随意强制转化：
如：
word a = 1，将&a作为入参传入函数时（函数参数类型为dword *）
那么 word * 转dword * ，这样解析的时候按dword解析4个字节，多出来的两个字节里的数据不可知，（dword *）&a指向的值就不一定是1了。

10、int *p = 0;(ok,表示p指向0x00000000)
   int *p = (int *)1;(ok,表示p指向0x00000001，这里是将1强制转换为int *)
   
   char *p = "123";(ok,创建指针，同时创建了一个字符串常量,且常量的值不能修改)(只有字符串常量可以这么写，int/double等不可以)
   int *p = 1;(error,p表示一个地址，1表示一个值)
   int *p = &1;(error，字面量，不能用&取地址)
   
   *p = 1;(ok，p指向的值为1，但前提是要对p初始化！！！)
   
   double *m = (double *)3.15;(error,无法从double强制转换为double *)
   double *p = (double *)(int)1.11;(ok，表示p指向0x00000001，强制类型转换)

   &运算符只能作用于变量，不能作用于字面量。字面量是直接量，数字的话就是 1 2 3 等等，字符串就是 abc def 等等
   常量是存在内存里面的，而内存是分好多段的，常量所存储的空间是不允许我们操作的，为了是保护内存，所以这个取地址是没有意义的，当然也不允许操作  
   
11、数组名是不可修改的左值，不能对其赋值，详见C专家编程
	编译器为每个对象分配一个地址（左值），编译时可知；存储在变量中的值（右值），运行时可知。
   
12、指针常量和常量指针
    <1>常量指针:
	常量是形容词，指针是名词，以指针为中心的一个偏正结构短语。这样看，常量指针本质是指针，常量修饰它，表示这个指针乃是一个指向常量的指针。
	指针指向的对象是常量，那么这个对象不能被更改。

	<2>指针常量：
	指针是形容词，常量是名词。这回是以常量为中心的一个偏正结构短语。那么，指针常量的本质是一个常量，而用指针修饰它，那么说明这个常量的值应该是一个指针。
	指针常量的值是指针，这个值因为是常量，所以不能被赋值。

13、CCK&R C 与 ANSI C的区别 
<1> C语言由Dennis M. Ritchie在1973年设计和实现。从那以后使用者逐渐增加。到1978年Ritchie和Bell实验室的另一位程序专家Kernighan合写了著名的《The C Programming Language》，
    将C语言推向全世界，许多国家都出了译本，国内有一些C语言书就是这本书的翻译或者编译。由这本书定义的C语言后来被人们称作 K&R C。 
<2> 随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。这个标准化的工作在美国国家标准局（ANSI）的框架中进行（1983-1988），
    最终结果是1988年10月颁布的ANSI标准X3.159-1989，也就是后来人们所说的ANSI C标准。由这个标准定义的C语言被称作ANSI C。 
    ANSI C标准很快被采纳为国际标准和各国的标准。国际标准为ISO/IEC 9899-1990，中国国家标准GB/T 15272-94是国际ISO标准的中文翻译。 
    ANSI C标准化工作的一个主要目标是清除原来C语言中的不安全、不合理、不精确、不完善的东西。由此也产生了ANSI C与K&R C之间的差异。
	从总体上看，这些差异反应的是C语言走向完善、走向成熟。 

14、字符串常量出现在表达式中时，表达式所使用的值就是这些字符所存储的地址，而不是这些字符本身。

15、数组声明和定义
http://www.cnblogs.com/yyx001000000001010101100101/p/5184523.html

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

数组和指针的异同：
1、相同
<1>所有作为函数参数的数组名总是可以通过编译器转换为指针；（函数参数声明）
<2>在语句或者表达式中使用数组时，数组总是可以写成指针的形式，两者可以互换；
2、相异
<1>extern声明,如extern char a[]，不能写成指针形式；
<2>定义，如char a[10]，不能写成指针形式；
3、<1>规则一：表达式中的数组名（与声明不同）被编译器当作一个指向该数组第一个元素的指针；
      注：也有极个别例外，就是把数组作为一个整体来考虑。在下列情况中，对数组的引用不能用指向该数组第一个元素的指针来代替：
	        <1>数组作为sizeof()操作数 <2>使用&操作符取数组地址 <3>数组是一个字符串常量初始值（指针此时不能修改所指向的值，数组值可以修改）
   <2>规则二：下标总是与指针的偏移量相同；
   <3>规则三：在函数参数声明中，数组名被编译器当作指向该数组第一个元素的指针；
      注：这种情况下，编译器只向函数传递数组的地址，而不是整个数组的拷贝（出于效率考虑）
	      所有的数组在作为参数传递时都转换为指向该数组起始地址的指针，而其他参数均采用传值调用
		  类似，函数的返回值绝对不能是一个函数数组，而只能是指向数组或函数的指针

指针的类型限制：
<1>每个指针只能指向一种类型的原因在于：编译器需要知道对指针进行解引用操作时应该取几个字节，以及每个下标的步长应取几个字节；

字符串操作一些总结：
1、gxMakePRAElementList中，直接将TAI\RAI等值存入字符串中的某个字符，这样是可以的：
    如：char a[6] = "12345";内存中存放的是每个字符对应的数值：31 32 33 34 35
	    a[0] = 0xfa;内存中对应的数值即为：fa 32 33 34 35 (只不过fa对应的字符显示出来是乱码)
	
	字符串，从内存低字节到高字节，依次存储31 32 33 34 35
	int/short等一般采用小端法，内存低字节存低位，如int a = 0x1234  从内存低字节到高字节，依次存储34 12
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1、指针数组：int* p[10]
   数组指针：int (*p)[10]

2、函数指针：即为指向函数的指针：
/*函数指针*//*函数指针数组*/
#include "string"
const int FUN_MAX = 2;
typedef void (*CmpStr)(const char *,const char *);

void printf1(const char *str1,const char *str2)
{
	printf("%s",str1);
	return;
}

void printf2(const char *str1,const char *str2)
{
	printf("%s",str2);
	return;
}

void main()
{
	CmpStr cmpstr[FUN_MAX] = {printf1,printf2};
	cmpstr[0]("123","345");
	(************cmpstr[1])("123","345");
	return;
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

一些思考和总结：
1、char*与其他指针的区别
2、数组地址&a\指向数组首元素的地址(a\&a[0])：两者值相同，但类型不同。a+1 加一个数组元素大小、&a+1 加整个数组大小
   函数名func和&func的地址相同。函数名和数组名一样都是地址常量。

3、变量名存储在哪：（内存中不会存储变量名称）


----------------------------------------------------------------------------------------------------------------------
string(字符串)与octect string(字节串)： (octet，一种计算机语言，意思是因特网标准使用八位组。)
1、unsigned char *a = “12301233”； //string中间是不会有0值的
2、unsigned char code_stream_req[] = {0x01,0x00,0x01,0xd0,0xc0,0x00,0x01,0x10,0x01,0x00,0x00,0x16,0x45,0x0a,0xa0,0x49}；
octect string里面就会有0值，即0x00。
sizeof(code_stream_req)结果为16
strlen(code_stream_req)结果为1

BYTE与CHAR
BYTE是字节串，1就是1,2就是2。

CHAR是字符串，‘1’是49。

-----------------------------------------------------------------------------------------------------------------------
char与unsigned char:
<1>unsigned char通常被定义为BYTE。

<2>eg
include <string.h>
int main()
{
	char a[] = "中文";
	unsigned char b[] = "中文";

	printf("a=%s\tb=%s\n",a,b);
	printf("len a=%d\t len b=%d\n", strlen(a), strlen((char *)b));
	printf("a[0]=%d	a[1]=%d a[2]=%d a[3]=%d\n", a[0],a[1],a[2],a[3]);
	printf("b[0]=%d	b[1]=%d b[2]=%d b[3]=%d\n", b[0],b[1],b[2],b[3]);

	return 0;
}

a=中文  b=中文
len a=4  len b=4
a[0]=-42 a[1]=-48 a[2]=-50 a[3]=-60
b[0]=214 b[1]=208 b[2]=206 b[3]=196

可见，每个字节实际值是一样的，只不过char中认为首位为符号位，出现负数的情况。