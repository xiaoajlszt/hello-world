0、资料
https://github.com/jobbole/awesome-python-cn  //中文
https://github.com/vinta/awesome-python       //英文

----------------------------------------------------------------
python3.6 编译安装 https://my.oschina.net/tasker/blog/831092
<1>下载  https://www.python.org/downloads/release/python-360/
<2>cd /usr/local/src
(wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz)
1)tar -zxvf /usr/local/src/Python-3.6.0.tgz && cd Python-3.6.0

2)mkdir /usr/local/python3
./configure --prefix=/usr/local/python3 --with-thread
make && make altinstall  
//这里使用make altinstall安装在/usr/local/python3/bin目录下，如果使用make install，将会安装在/usr/bin/目录中。

3)# 关键一步，建立链接 
ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3          # 可直接使用 "python3"
ln -s /usr/local/python3/bin/pip3.6  /usr/bin/pip3               # 可直接使用 "pip3"

4)# 最后测试下 
python3
pip3

注：
1、Python Shell 中敲击方向键显示「^[[C^[[D]
安装yum -y install readline-devel，然后再重新编译安装python。
----------------------------------------------------------------
1、#!/usr/bin/Python 与 #!/usr/bin/env python
脚本语言的第一行，目的就是指出，文件中的代码用什么可执行程序去执行。

<1>#!/usr/bin/Python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器；
<2>#!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。
当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。
<3>#!/usr/bin/python相当于写死了python路径;#!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法。

2、random模块
<1>randrange() //返回指定递增基数集合中的一个随机数，基数缺省值为1
random.randrange ([start,] stop [,step])
参数
start -- 指定范围内的开始值，包含在范围内。
stop -- 指定范围内的结束值，不包含在范围内。
step -- 指定递增基数。
返回值
从给定的范围返回随机项。

<2>randint()  //Return random integer in range [a, b], including both end points
def randint(self, a, b):
	return self.randrange(a, b+1)

random.randint(12, 20) #生成的随机数n: 12 <= n <= 20 
random.randint(20, 20) #结果永远是20 
random.randint(20, 10) #该语句是错误的

3、print '',这里的逗号，可以让后面要输出的内容不换行。会用空格隔开。
print 'Refilling candy...',
try:
	candytray.release()
except ValueError:
	print 'full, skipping'
else:
	print 'OK'
	
4、内置函数help()的使用
查看python所有的modules：help("modules")
单看python所有的modules中包含指定字符串的modules： help("modules yourstr")
查看python中常见的topics： help("topics")
查看python标准库中的module：import os.path + help("os.path")
查看python内置的类型：help("list")
查看python类型的成员方法：help("str.find") 
查看python内置函数：help("open")

5、print('\t', end='')  //表示输出一个制表符后不换行。

7、signal模块
https://www.cnblogs.com/madsnotes/articles/5688681.html
signal模块有各种信号名的宏定义，与Linux保持一致。

<1>signal包的核心是使用 signal.signal()函数来预设(register)信号处理函数:
signal.signal(signalnum, handler)		//signalnum为某个信号，handler为该信号的处理函数
当handler为signal.SIG_IGN时，信号被无视(ignore)。
当handler为singal.SIG_DFL，进程采取默认操作(default)。
当handler为一个函数名时，进程采取函数中定义的操作。

信号处理函数的两个参数:一个用来识别信号(signum)，另一个用来获得信号发生时，进程栈的状况(stack frame)。
这两个参数都是由signal.singnal()函数来传递的。

8、subprocess模块
subprocess的目的是启动一个新的进程并且与之通信。
<1>call
<2>check_all
<3>check_output
父进程等待子进程执行命令，返回子进程向标准输出发送输出运行结果，检查退出信息。
如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。

<4>如果在执行相关命令时，可将命令和所带的参数一起放在一个列表中传递给相关方法，例如：
>>> import subprocess
>>> retcode = subprocess.call(["ls", "-l"])
>>> print retcode
0

9、from A import B as C  \  import A as B
给B库一个C的别称

10、xml.etree.ElementTree解析XML
from xml.etree import ElementTree as ET
<1>tree = ET.parse('xmlfilepath')

11、ConfigParser模块
读写配置文件
http://blog.csdn.net/gexiaobaohelloworld/article/details/7976944

12、psycopg2模块	//操作PostgreSQL

13、locals()和globals()	//(locals 是只读的，globals 不是)
http://blog.csdn.net/scelong/article/details/6977867

Python的两个内置函数，基于字典的访问局部和全局变量的方式。

<1>首先需要理解python中的名字空间概念。
Python使用叫做名字空间的东西来记录变量的轨迹。
名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变量的值。实际上，名字空间可以象Python的字典一样进行访问。
1)每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数和局部定义的变量。
2)每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
3)还有就是内置名字空间，任何模块均可访问它，它存放着内置的函数和异常。

<2>当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1)局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用这个变量，然后停止搜索。
2)全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python将使用这个变量然后停止搜索。
3)内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

14、glob
glob模块是最简单的模块之一，内容非常少。用它可以查找符合特定规则的文件路径名。跟使用windows下的文件搜索差不多。
查找文件只用到三个匹配符：”*”, “?”, “[]”。
”*”匹配0个或多个字符；
”?”匹配单个字符；
”[]”匹配指定范围内的字符，如：[0-9]匹配数字。

<1>glob.glob
返回所有匹配的文件路径列表。它只有一个参数pathname，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。

<2>glob.iglob
获取一个可编历对象，使用它可以逐个获取匹配的文件路径名。
与glob.glob()的区别是：glob.glob同时获取所有的匹配路径，而glob.iglob一次只获取一个匹配路径。

15. DT模块 DT.datatime


15、内置函数filter()
filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。

<1>例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：
def is_odd(x):
    return x % 2 == 1

然后，利用filter()过滤掉偶数：

>>>filter(is_odd, [1, 4, 6, 7, 9, 12, 17])
结果：

[1, 7, 9, 17]

<2> help()
Return those items of sequence for which function(item) is true.  
If function is None, return the items that are true.  
If sequence is a tuple or string, return the same type, else return a list.


16、注意点
<1> += 和 =不同
list1 = [1,2,3]
list2 = [1,2,3]

def change_list1(l):
	l += [4]
	
def change_list2(l):
	l = l + [4]

change_list1(list1)
//[1,2,3,4]

change_list2(list1)
//[1,2,3]


17. reload(sys)后设置编码
http://blog.csdn.net/daydayup_gzm/article/details/72654188

<1>python在安装时，默认的编码是ascii，当程序中出现非ascii编码时，python的处理常常会报：
UnicodeDecodeError: 'ascii' codec can't decode byte 0x?? in position 1: ordinal not in range(128)
python没办法处理非ascii编码的，此时需要自己设置python的默认编码，一般设置为utf8的编码格式。

<2>查询系统默认编码可以在解释器中输入以下命令：
sys.getdefaultencoding()

<2>设置默认编码时使用： 
sys.setdefaultencoding('utf8')
//可能会报AttributeError: 'module' object has no attribute 'setdefaultencoding'的错误，需要执行reload(sys)，再执行以上命令就可以顺利通过。再执行sys.getdefaultencoding()就会发现编码已经被设置为utf8的了。
//如果需要在运行时（就是整个解释器启动完之后）进行setdefaultencoding，就只能重新加载sys这个模块。

<3>eg:
import sys  
reload(sys)  
sys.setdefaultencoding('utf8')











