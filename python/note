0、资料
https://github.com/jobbole/awesome-python-cn  //中文
https://github.com/vinta/awesome-python       //英文

----------------------------------------------------------------
python3.6 编译安装 https://my.oschina.net/tasker/blog/831092
<1>下载  https://www.python.org/downloads/release/python-360/
<2>cd /usr/local/src
(wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz)
1)tar -zxvf /usr/local/src/Python-3.6.0.tgz && cd Python-3.6.0

2)mkdir /usr/local/python3
./configure --prefix=/usr/local/python3 --with-thread
make && make altinstall  
//这里使用make altinstall安装在/usr/local/python3/bin目录下，如果使用make install，将会安装在/usr/bin/目录中。

3)# 关键一步，建立链接 
ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3          # 可直接使用 "python3"
ln -s /usr/local/python3/bin/pip3.6  /usr/bin/pip3               # 可直接使用 "pip3"

4)# 最后测试下 
python3
pip3

注：
1、Python Shell 中敲击方向键显示「^[[C^[[D]
安装yum -y install readline-devel，然后再重新编译安装python。
----------------------------------------------------------------
1、#!/usr/bin/Python 与 #!/usr/bin/env python
脚本语言的第一行，目的就是指出，文件中的代码用什么可执行程序去执行。

<1>#!/usr/bin/Python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器；
<2>#!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。
当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。
<3>#!/usr/bin/python相当于写死了python路径;#!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法。

2、random模块
<1>randrange() //返回指定递增基数集合中的一个随机数，基数缺省值为1
random.randrange ([start,] stop [,step])
参数
start -- 指定范围内的开始值，包含在范围内。
stop -- 指定范围内的结束值，不包含在范围内。
step -- 指定递增基数。
返回值
从给定的范围返回随机项。

<2>randint()  //Return random integer in range [a, b], including both end points
def randint(self, a, b):
	return self.randrange(a, b+1)

random.randint(12, 20) #生成的随机数n: 12 <= n <= 20 
random.randint(20, 20) #结果永远是20 
random.randint(20, 10) #该语句是错误的

3、print '',这里的逗号，可以让后面要输出的内容不换行。会用空格隔开。
print 'Refilling candy...',
try:
	candytray.release()
except ValueError:
	print 'full, skipping'
else:
	print 'OK'
	
4、内置函数help()的使用
查看python所有的modules：help("modules")
单看python所有的modules中包含指定字符串的modules： help("modules yourstr")
查看python中常见的topics： help("topics")
查看python标准库中的module：import os.path + help("os.path")
查看python内置的类型：help("list")
查看python类型的成员方法：help("str.find") 
查看python内置函数：help("open")

5、print('\t', end='')  //表示输出一个制表符后不换行。

6、getopt模块
getopt模块用于抽出命令行选项和参数，也就是sys.argv。命令行选项使得程序的参数更加灵活，支持短选项模式和长选项模式。
<1>说明
getopt函数的格式是getopt.getopt([命令行参数列表], "短选项", [长选项列表])
短选项名后的冒号(:)表示该选项必须有附加的参数。
长选项名后的等号(=)表示该选项必须有附加的参数。
返回opts和args。

opts是一个参数选项及其value的元组( ( '-f', 'hello'), ( '-t', '' ), ( '--format', '' ), ( '--directory-prefix', '/home' ) )
args是一个除去有用参数外其他的命令行输入 ( 'a', 'b' )

<2>eg:	python scriptname.py -f 'hello' --directory-prefix=/home -t --format 'a' 'b'
 
import getopt
shortargs = 'f:t'
longargs = ['directory-prefix=', 'format', '--f_long=']

opts, args = getopt.getopt( sys.argv[1:], shortargs, longargs )
 
然后遍历opts便可以获取所有的命令行选项及其对应参数了。

for opt, val in opts:
	if opt in ( '-f', '--f_long' ):
		pass
	if ....
使用字典接受命令行的输入，然后再传送字典，可以使得命令行参数的接口更加健壮。


7、signal模块
https://www.cnblogs.com/madsnotes/articles/5688681.html
signal模块有各种信号名的宏定义，与Linux保持一致。

<1>signal包的核心是使用 signal.signal()函数来预设(register)信号处理函数:
signal.signal(signalnum, handler)		//signalnum为某个信号，handler为该信号的处理函数
当handler为signal.SIG_IGN时，信号被无视(ignore)。
当handler为singal.SIG_DFL，进程采取默认操作(default)。
当handler为一个函数名时，进程采取函数中定义的操作。

信号处理函数的两个参数:一个用来识别信号(signum)，另一个用来获得信号发生时，进程栈的状况(stack frame)。
这两个参数都是由signal.singnal()函数来传递的。

8、subprocess模块
subprocess的目的是启动一个新的进程并且与之通信。
<1>call
<2>check_all
<3>check_output
父进程等待子进程执行命令，返回子进程向标准输出发送输出运行结果，检查退出信息。
如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。

<4>如果在执行相关命令时，可将命令和所带的参数一起放在一个列表中传递给相关方法，例如：
>>> import subprocess
>>> retcode = subprocess.call(["ls", "-l"])
>>> print retcode
0

9、from A import B as C  \  import A as B
给B库一个C的别称

10、xml.etree.ElementTree解析XML
from xml.etree import ElementTree as ET
<1>tree = ET.parse('xmlfilepath')

11、ConfigParser模块
读写配置文件
http://blog.csdn.net/gexiaobaohelloworld/article/details/7976944

12、psycopg2模块	//操作PostgreSQL

13、locals()和globals()	//Python的两个内置函数，基于字典的访问局部和全局变量的方式。(locals 是只读的，globals 不是)
http://blog.csdn.net/scelong/article/details/6977867

<1>当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1)局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用这个变量，然后停止搜索。
2)全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python将使用这个变量然后停止搜索。
3)内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

14、glob
glob模块是最简单的模块之一，内容非常少。用它可以查找符合特定规则的文件路径名。跟使用windows下的文件搜索差不多。
查找文件只用到三个匹配符：”*”, “?”, “[]”。
”*”匹配0个或多个字符；
”?”匹配单个字符；
”[]”匹配指定范围内的字符，如：[0-9]匹配数字。

<1>glob.glob
返回所有匹配的文件路径列表。它只有一个参数pathname，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。

<2>glob.iglob
获取一个可编历对象，使用它可以逐个获取匹配的文件路径名。
与glob.glob()的区别是：glob.glob同时获取所有的匹配路径，而glob.iglob一次只获取一个匹配路径。

15. DT模块 DT.datatime


15、内置函数filter()
filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。

<1>例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：
def is_odd(x):
    return x % 2 == 1

然后，利用filter()过滤掉偶数：

>>>filter(is_odd, [1, 4, 6, 7, 9, 12, 17])
结果：

[1, 7, 9, 17]

<2> help()
Return those items of sequence for which function(item) is true.  
If function is None, return the items that are true.  
If sequence is a tuple or string, return the same type, else return a list.


16、注意点
<1> += 和 =不同
list1 = [1,2,3]
list2 = [1,2,3]

def change_list1(l):
	l += [4]
	
def change_list2(l):
	l = l + [4]

change_list1(list1)
//[1,2,3,4]

change_list2(list1)
//[1,2,3]














