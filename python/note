0、资料
https://github.com/jobbole/awesome-python-cn  //中文
https://github.com/vinta/awesome-python       //英文

1、#!/usr/bin/Python 与 #!/usr/bin/env python
脚本语言的第一行，目的就是指出，文件中的代码用什么可执行程序去执行。

<1>#!/usr/bin/Python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器；
<2>#!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。
当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。
<3>#!/usr/bin/python相当于写死了python路径;#!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法。

2、if __name__ == '__main__'的作用
“Make a script both importable and executable”
意思就是说让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。

举例：
#module.py
def main():
  print "we are in %s"%__name__
  
if __name__ == '__main__':
  main()
这个函数定义了一个main函数，我们执行一下该py文件发现结果是打印出”we are in __main__“,
说明我们的if语句中的内容被执行了，调用了main()。

#anothermodle.py
from module import main
main()

其执行的结果是：we are in module
说明模块__name__ = '__main__' 下面的函数没有执行。
这样既可以让“模块”文件运行，也可以被其他模块引入，而且不会执行函数2次。这才是关键。

总结一下：
如果我们是直接执行某个.py文件的时候，该文件中那么”__name__ == '__main__'“是True,但是我们如果从另外一个.py文件通过import导入该文件的时候，这时__name__的值就是我们这个py文件的名字而不是__main__。
这个功能还有一个用处：调试代码的时候，在”if __name__ == '__main__'“中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！

3、pass语句在函数中的作用
<1>当编写一个程序时，执行语句部分思路还没有完成，这时可以用pass语句来占位，也可以当做是一个标记，是要过后来完成的代码。比如下面这样：
>>>def iplaypython():
>>>       pass

<2>pass语句在循环中的作用
pass也常用于为复合语句编写一个空的主体，比如说想一个while语句的无限循环，每次迭代时不需要任何操作，你可以这样写：
>>>while True:
>>>    pass

<3>pass语句用法总结:
空语句，什么也不做
在特别的时候用来保证格式或是语义的完整性


