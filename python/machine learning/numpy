一. 常用函数
1. np.concatenate((a1,a2,...),axis=0,out=None)
通过一个存在的axis连接一系列的arrays。返回连接后的array。

2. np.empty(shape,dtype=float,order='C')
shape: int or tuple
dtype:
order:
返回一个指定shape和type的array。(不对值进行初始化)

3. 增加维度np.newaxis
eg: 
X = np.random.randint(1,8,size=(2,3,4))
Y = X[:,np.newaxis,:,:]

结果：Y.shape (2,1,3,4)

4. np.mgrid()


二. np.random
1. np.random.seed(0) # set a seed so that the results are consistent
seed( ) 用于指定随机数生成时所用算法开始的整数值。 
- 如果使用相同的seed值，则每次生成的随即数都相同； 
- 如果不设置这个值，则系统根据时间来自己选择这个值，此时每次生成的随机数因时间差异而不同；
- 设置的seed()值仅一次有效。

2. 随机打乱数组元素的顺序。(如果X是多维的，只对第一个维度作随机。)
<1>np.random.permutation(X)
<2>np.random.shuffle(X)

函数shuffle与permutation都是对原来的数组进行重新洗牌:
shuffle直接在原来的数组上进行操作，改变原来数组的顺序，无返回值。
permutation不直接在原来的数组上进行操作，而是返回一个新的打乱顺序的数组，并不改变原来的数组。

2. np.linalg.norm(x, ord=None, axis=None, keepdims=False)
参数：
	x: 	矩阵或向量
	ord:范数类型
	axis:
		= 1表示按行向量处理，求多个行向量的范数
		= 0表示按列向量处理，求多个列向量的范数
		= None表示矩阵范数。
	keepding: 是否保持矩阵的二维特性。True表示保持矩阵的二维特性。

返回值：x的范数




-----------------------------------------------------------------------------------------
https://www.jianshu.com/p/047d8c1c7e14

1. NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：
- NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。
	比起Python的内置序列，NumPy数组使用的内存更少。
- NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。

4.1 NumPy的ndarray:一种多维数组对象
1. N维数组对象ndarray，该对象是一个快速而灵活的大数据集容器，其语法跟标量元素之间的运算一样。
<1> 其中的所有元素必须是相同类型的。
<2> 每个数组都有一个shape(表示各维度大小的元组)和一个dtype(说明数组数据类型的对象)。
<3> 数组、NumPy数组、ndarry，都是指ndarry对象。

2. 创建ndarry
<1> np.array()	//接受一切序列型的对象，产生一个新的含有传入数据的NumPy数组。
除非特殊说明，np.array()会尝试为新建的数组推断出一个较为合适的类型。类型保存在dtype中。

<2> np.zeros()	//创建指定长度的全0数组
eg: np.zeros(10)
	np.zeros((3,6))

<3> np.ones()	//创建指定长度的全1数组

<4> np.empty()	//创建一个没有任何具体值的数组(未初始化的任意值)
eg: np.empty((2,3,2))
array([[[6.90805897e-310, 6.90806863e-310],
        [6.90805953e-310, 6.90805911e-310],
        [6.90805897e-310, 6.90805898e-310]],
       [[6.90805897e-310, 6.90805953e-310],
        [6.90805908e-310, 6.90805908e-310],
        [6.90805909e-310, 6.90805908e-310]]])

<5> arange是python内置range的数组版：
In [7]: np.arange(10)
Out[7]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

<6> 总结：由于NumPy关注的是数组计算，因此，如果没有特别指定，数据类型基本都是float64。
array()
asarry()
arange()
ones()/ones_like()
zeros()/zeros_like()
empty()/empty_like()
full()/full_like()
eye()/identity()	//创建N*N单位矩阵(对角线为1，其余为0)

2. ndarry的数据类型
<1> dtype是一个特殊的对象，它含有ndarry将一块内存解释为特定数据类型所需的信息。
In [10]: np.array([1,2,3], dtype = np.int32)
Out[10]: array([1, 2, 3], dtype=int32)

<2> NumPy的数据类型
int8	uint8
int16	uint16
int32	uint32
int64	uint64
float16						半精度浮点数
float32						单精度浮点数
float64						双精度浮点数
float128					扩展精度浮点数
complex64	complex128		复数
complex256					复数
bool	

object						python对象类型
string_						固定长度的字符串类型(每个字符1字节)
unicode_					固定长度的unicode类型(字节数由平台决定)

<3> 通过ndarry的astype方法明确地将一个数组从一个dtype转换成另一个dtype。
In [11]: arr1=np.array([1,2,3,4,5])
In [12]: arr1.dtype
Out[12]: dtype('int64')
In [14]: arr1.astype(np.float64).dtype
Out[14]: dtype('float64')

//调用astype总会创建一个新的数组(一个数据的备份)，即使新的dtype与旧的dtype相同。

3. NumPy数组的运算
数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化。大小相等的数组之间的任何算术运算都会将运算应用到元素级。

<1> 数组与标量的算术运算会将标量值传播到各个元素。

<2> 大小相同的数组之间的比较会生成布尔值数组。

<3> 不同大小的数组之间的运算叫做广播(broadcasting)。

4. 索引
<1> 基础
In [15]: arr = np.arange(10)

In [16]: arr
Out[16]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [17]: arr[1]
Out[17]: 1

In [18]: arr[2:5]
Out[18]: array([2, 3, 4])

In [19]: arr[2:5] = 10	# 将一个标量赋值给一个切片时，该值会自动传播(广播)到整个选区。

In [20]: arr
Out[20]: array([ 0,  1, 10, 10, 10,  5,  6,  7,  8,  9])

<2> 跟list的区别在于，数组切片是原始数组的视图。视图上任何修改都会直接反映到源数组。
In [15]: arr = np.arange(10)

In [30]: slice1 = arr[5:7]

In [31]: slice1[1] = 11

In [33]: arr
Out[33]: array([ 0,  1,  2,  3,  4,  5, 11,  7,  8,  9])

//切片[:]会给数组中的所有值赋值。
//由于NumPy的设计目的是处理大数据，所以你可以想象一下，假如NumPy坚持要将数据复制来复制去的话会产生何等的性能和内存问题。

<3> 如果想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如arr[5:8].copy()。

<4> 各索引位置上的元素不再是标量而是一维数组。
In [35]: arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])

In [36]: arr2d[0][2]
Out[36]: 3

In [37]: arr2d[0,2]	# 传入一个以逗号隔开的索引列表来选取单个元素。
Out[37]: 3

<5> 多维数组中，如果省略了后面的索引，则返回对象会是一个维度降低一点的ndarry。
2 * 2 * 3 数组：
In [46]: arr3d = np.array([[[1,2,3],[4,5,6]], [[7,8,9],[10,11,12]]])

In [47]: arr3d
Out[47]:
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [48]: arr3d[0]	# 2 * 3的数组
Out[48]:
array([[1, 2, 3],
       [4, 5, 6]])

In [49]: arr3d[0] = 10	# 标量赋值

In [50]: arr3d
Out[50]:
array([[[10, 10, 10],
        [10, 10, 10]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
		
In [51]: arr3d[1,0]
Out[51]: array([7, 8, 9])

5. 切片
<1> 可以一次传入多个切片
In [38]: arr2d
Out[38]:
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

In [40]: arr2d[:2,1:]	# 像这样进行切片时，只能得到相同维数的数组视图
Out[40]:
array([[2, 3],
       [5, 6]])

<2> 索引和切片混合		# 通过将整数索引和切片混合，可以得到低维度的切片。(索引是降维的，切片维度不变)
In [46]: arr3d = np.array([[[1,2,3],[4,5,6]], [[7,8,9],[10,11,12]]])
In [59]: arr3d.shape
Out[59]: (2, 2, 3)

In [57]: arr3d[:1].shape	# 维度不变
Out[57]: (1, 2, 3)

In [58]: arr3d[1].shape		# 降维
Out[58]: (2, 3)

In [41]: arr2d[1,:2]	# 第二行的前两列
Out[41]: array([4, 5])

In [42]: arr2d[:2,2]	# 第三列的前两行
Out[42]: array([3, 6])

In [44]: arr2d[:,1]
Out[44]: array([2, 5, 8])

In [45]: arr2d[:,:1]	# :表示选取整个轴
Out[45]:
array([[1],
       [4],
       [7]])

//索引/切片始终是0、1、2...的顺序。

<3> 对切片/索引表达式的赋值操作会被扩散到整个选区。

6. 布尔型索引
<1>
In [80]: names = np.array(['A', 'B', 'C', 'A', 'C', 'B', 'B'])
In [75]: names
Out[75]: array(['A', 'B', 'C', 'A', 'C', 'B', 'B'], dtype='<U1')

In [74]: data = np.random.randn(7, 4)
In [77]: data
Out[77]:
array([[-0.66750988,  0.10661126, -0.38997121, -0.31655207],
       [ 1.42548493,  0.91294081, -0.55147635, -0.03016264],
       [-2.89855062,  1.77880962,  0.59966733,  0.750277  ],
       [ 0.7910015 , -1.30523579, -1.76134655,  0.56069919],
       [-0.37766197,  1.16498764, -0.23765988, -1.04956079],
       [ 0.32410393,  0.93473914, -0.06204678, -1.80867043],
       [-1.13802734,  0.06322953, -0.84597177,  1.25903867]])

In [81]: names == 'A'	# 选出'A'对应的所有行。数组的比较运算将产生一个布尔型数组。
Out[81]: array([ True, False, False,  True, False, False, False])

In [83]: data[names == 'A']		# 布尔型数组可用于数组索引
Out[83]:						# 布尔型数组的长度必须跟被索引的轴长度一致
array([[-0.66750988,  0.10661126, -0.38997121, -0.31655207],
       [ 0.7910015 , -1.30523579, -1.76134655,  0.56069919]])

<2> 布尔型数组跟切片、整数(或整数序列)混合使用
In [85]: data[names == 'A', 2:]
Out[85]:
array([[-0.38997121, -0.31655207],
       [-1.76134655,  0.56069919]])

In [86]: data[names == 'A', 3]
Out[86]: array([-0.31655207,  0.56069919])

<3> != 
	~		# 对条件进行否定
	&		# 和
	|		# 或

<4> eg
In [91]: data[data < 0] = 0		# 将data这种的所有负值都设为0
In [92]: data
Out[92]:
array([[0.        , 0.10661126, 0.        , 0.        ],
       [1.42548493, 0.91294081, 0.        , 0.        ],
       [0.        , 1.77880962, 0.59966733, 0.750277  ],
       [0.7910015 , 0.        , 0.        , 0.56069919],
       [0.        , 1.16498764, 0.        , 0.        ],
       [0.32410393, 0.93473914, 0.        , 0.        ],
       [0.        , 0.06322953, 0.        , 1.25903867]])
	   
	   
In [94]: data[names != 'A'] = 7	# 通过一维布尔数组设置整行或列的值
In [95]: data
Out[95]:
array([[0.        , 0.10661126, 0.        , 0.        ],
       [7.        , 7.        , 7.        , 7.        ],
       [7.        , 7.        , 7.        , 7.        ],
       [0.7910015 , 0.        , 0.        , 0.56069919],
       [7.        , 7.        , 7.        , 7.        ],
       [7.        , 7.        , 7.        , 7.        ],
       [7.        , 7.        , 7.        , 7.        ]])

<5> 通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使是返回一模一样的数组。

7. 花式索引	#利用整数数组进行索引
In [102]: arr = np.arange(32).reshape((8,4))

In [103]: arr
Out[103]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])

In [104]: arr[[1,5,7,2],[0,3,1,2]]
Out[104]: array([ 4, 23, 29, 10])

最终选出的元素(1,0),(5,3),(7,1),(2,2)。无论数组是多少维的，花式索引总是一维的。

<1> 花式索引跟切片不一样，它总是将数据复制到新数组中。
In [105]: arr[[1,5,7,2]][:,[0,3,1,2]]	# 0,3,1,2 是指选取第0,3,1,2列
Out[105]:
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])

8. 数组转置和轴对换
<1> 数组不仅有transpose方法，还有一个特殊的T属性。返回的是源数据的视图(不会进行任何复制操作)。
In [111]: arr = np.arange(15).reshape((3,5))

In [112]: arr
Out[112]:
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

In [113]: arr.T
Out[113]:
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])

<2> np.dot()	# 计算矩阵内积
In [114]: arr = np.random.randn(6,3)

In [115]: arr
Out[115]:
array([[-0.73287892, -0.68494557,  0.1474168 ],
       [ 0.05446299,  0.81619198, -1.20525919],
       [-0.70650199,  0.29845597,  1.96793706],
       [-3.73590234, -0.34647623, -2.5911906 ],
       [ 0.8066249 ,  0.4330313 , -0.60166593],
       [-0.60543694,  0.99742242,  1.03746054]])

In [116]: np.dot(arr.T, arr)
Out[116]:
array([[16.01338667,  1.37539349,  7.00296723],
       [ 1.37539349,  2.52680912,  1.17467935],
       [ 7.00296723,  1.17467935, 13.49975268]])

<3> 对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置。
In [125]: arr
Out[125]:
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [126]: arr.transpose((1,0,2))	# 第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。
Out[126]:							# 等价于arr.swapaxes(0,1)
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])


<4> swapaxes	# 接受一对轴编号
In [122]: arr
Out[122]:
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [123]: arr.swapaxes(1,2)
Out[123]:
array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])

4.2 通用函数：快速的元素级数组函数
通用函数(即ufunc)是一种对ndarray中的数据执行元素级运算的函数。

<1> 一元 	//入参是一个数组
np.sqrt()
np.exp()

<2> 二元	//入参是两个数组
np.add()
np.maximum()//取较大的元素

<3> 返回多个数组
np.modf()	//分别返回浮点数组的小数和整数部分

<4> Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：

4.3 利用数组进行数据处理
1. np.meshgrid(ndarry,ndarry) # 生成网格型数据，接受两个一维数组，生成两个二维数组(对应一维数组中所有的x,y对)。

2. 将条件逻辑表述为数组运算
np.where(cron, xarr, yarr)	# cron - 布尔型数组；当cron中值为True时，选取xarr的值，否则从yarr中选取。
//第二个参数和第三个参数不必是数组，也可以是标量。

3. 数学和统计方法













































