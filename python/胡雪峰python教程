第一章 基础

一、输入与输出
1、print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：
>>> print('The quick brown fox', 'jumps over', 'the lazy dog')
T
The quick brown fox jumps over the lazy dog
print()会依次打印每个字符串，遇到逗号“,”会输出一个空格。

2、input()可以让用户输入字符串，并存放到一个变量里

3、python大小写敏感

二、数据类型和变量
1、布尔值：and、or、not
>>> True and False
False
>>> True or False
True
>>> not True
False
>>>

2、空值(None)
None不能理解为0，因为0是有意义的，而None是一个特殊的值。

3、变量
<1>变量名必须是大小写英文、数字和_的组合，且不能以数字开头。
<2>a = 'ABC'
-在内存中创建了一个‘ABC’的字符串；
-在内存中创建了一个名为a的变量，并把它指向‘ABC’
b = a
-把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据

4、常量
常量就是不能改变的量。通常用全部大写的变量名表示常量。
PI = 3.14159 //用全部大写的变量名表示常量知识一个习惯，PI仍是可以改变的

5、除法
<1> / 结果是浮点数，即使两个整数恰好整除，结果也是浮点数。 9 / 3 = 3.0
<2> // 整除 10 // 3 = 3
<3> % 取余数 10 % 3 = 1

三、字符串和编码
1、编码: ASCII - Unicode - UTF-8
内存中统一使用的是Unicode编码，当需要保存到硬盘或者需要传输的时候就转换为UTF-8编码。
ASCII单个字节；
Unicode2个字节；
UTF-8是可变长编码，把一个Unicode字符根据不同的数据大小编码成1-6个字节，英文(1个字节)、汉字(通常3个字节)、很生僻的字符(4-6个字节)。 UTF-8可以节约空间，同时ASCII编码实际上是UTF-8的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。
2、对于单个字符的编码：
ord()函数获取字符的整数表示   >>> ord('a')   97
chr()函数把编码转换为对应的字符   >>> chr(97)  'a'

四、条件判断
python缩进规则，如果if语句是true，就执行if后所有缩进的行。

五、循环
1、for...in循环 //把每个元素带入变量x，然后执行缩进的语句
>>> names = ['123','456','789']
>>> for name in names:
	print(name)

	
123
456
789
2、range() 生成一个整数序列，再通过list()转换成list。
range(5)：生成的序列0,1,2,3,4
range(101):0-100
3、while循环

五、dict(字典)和set
set和dict类似，也是一组key的集合，但不存储value。key不能重复，set中没有重复的key。
要创建一个set需要提供一个list作为输入集合。
set是无序和无重复的集合：
<1>set是无序的，重复的元素会自动过滤
<2>add(key)可以添加元素到set中
<3>remove(key)删除元素
<4>set和dict一样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部不会有重复元素。

六、函数
1、调用函数
<1>数据类型转换
int()、float()、str()、bool()
<2>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋值给一个变量：
>>> a = str
>>> a(123)
'123'
>>> 
3、定义函数
<1>定义函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号，
然后在缩进块中编写函数体，函数的返回值用return语句返回。
如果没有return语句，函数执行完毕返回None。return None简写为return
>>> def my_abs(x):
	if x >= 0:
		return x
	else:
		return -x

	
>>> my_abs(-1)
1
>>> 

<2>空函数 
pass语句什么都不做，可以用作占位符，让代码先运行起来。

<3>参数检查
调用函数时，如果参数个数不对，python解释器会自动检测出来，并抛出TypeError
类型检查使用内置函数isinstance()实现

<4>返回多个值
其实返回的是一个tuple (151.96152422706632,70.0)
>>> import math
>>> def  move(x,y,step,angle=0):
	nx = x + step * math.cos(angle)
	ny = y - step * math.sin(angle)
	return nx,ny

>>> x,y = move(100,100,60,math.pi/6)
>>> print(x,y)
151.96152422706632 70.0
>>> 

3、函数的参数
默认参数、可变参数、关键字参数
<1>位置参数--一般的参数
<2>默认参数
def power(x,n=2):   //power(2)相当于调用power(2,2)
--必选参数在前，默认参数在后，否则python解释器会报错
--如何设置默认参数：当函数有多个参数时，把变化大的参数放在前面，变化小的参数放在后面，变化小的参数就作为默认参数。
def enroll(name, gender, age=6, city='Beijing'):
当有多个默认参数时：既可以按顺序提供默认参数，比如调用enroll('Bob','M',7)//city参数仍使用默认值
                    也可以不按顺序提供部分默认参数，但需要注明参数名，如enroll('Bob','M',city='TianJin')
<3>默认参数特殊情况
>>> def add_end(L=[]):
	L.append('END')
	return L

>>> add_end()
['END']
>>> add_end()
['END', 'END']
>>> add_end()
['END', 'END', 'END']
>>> 

原因：函数在定义时，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是定义时的[]了。
因此必须牢记：默认参数必须指向不变的对象！数字、字符串、元组、None
>>> def add_end(L=None):
	if L is None:
		L = []
	L.append('END')
	return L

>>> add_end()
['END']
>>> add_end()
['END']
>>> add_end()
['END']
>>> 
使用None这个不变对象来实现上面的例子。
为什么要设计str、None这样的不变对象呢？因为对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。
此外由于对象不可变，多任务环境下同时读取对象不需要加锁。编程时，如果可以设计一个不变对象，就尽量设计成不变对象！！

<4>可变参数 *
仅需在参数前面加一个*号，在函数内部接收到的是一个tuple。
>>> def cacl(*num):
	sum = 0
	for n in num:
		sum = sum + n*n
	return sum

>>> cacl()
0
>>> cacl(1)
1
>>> cacl(1,2,3,4,5)
55
>>> 

>>> nums = [1, 2, 3]

>>> calc(*nums)

14

*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。

<5>关键字参数 **
def person(name, age, **kw):
可变参数允许传入0个或任意个参数，这些可变参数在函数调用时，自动组装为一个tuple。而关键字参数允许传入0个或人一个含参数名的参数，这些参数在函数内部自动组装为一个dict。

<6>命名关键字参数 def person(name, age, *, city, job):
对于关键字参数，调用者可以传入任何不受限制的关键字参数；命名关键字参数可以限制关键字的名字。
*后面的参数被视为命名关键字参数。
--如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：
--命名关键字参数必须传入参数名
--命名关键字参数可以有缺省值
--使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数

<7>参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

4、递归函数
如果一个函数内部调用自身，这个函数就是递归函数。
<1>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
<2>尾递归化：解决递归调用栈溢出的方法是通过尾递归化
尾递归化是指，在函数返回的时候，调用自身。并且return语句不能包含表达式。这样编译器或解释器就可以把尾递归做优化，使得递归本身无论调用多少次，都只占用一个帧，不会出现栈溢出的情况。
遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。


第二章 高级特性

1、切片

2、迭代
如果给定一个list或tuple，可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代(iteration)
<1>python迭代通过for...in完成的，而很多语言通过下标完成。python的for循环抽象程度要高于java的for循环，
因为python的for循环不仅可以用在list或tulip上，还可以用在其他迭代对象上。
list虽然有下标，但还有很多其他数据类型没有下标，但只要是可迭代对象，无论有无下标，都可以迭代，比如dict。
>>> d = {'a':1,'b':2,'c':3}
>>> for key in d:
	s = '%s\t%d' %(key,d[key])
	print(s)

	
b	2
c	3
a	1
<2>字符串也是可迭代对象，因此，也可以作用于for循环：
>>> for s in "ABC":
	print(s)

	
A
B
C
<3>如何判断一个对象是可迭代对象：
通过collections模块的Iterable类型判断
>>> from collections import Iterable
>>> isinstance('abc',Iterable)
True
>>> isinstance([1,2,3],Iterable)
True
>>> isinstance(123,Iterable)
False
<4>下标循环
内置的enumerate()函数将list变为索引-元素对
>>> for i,value in enumerate(['a','b','c']):
	print(i,value)

	
0 a
1 b
2 c

3、列表生成式  List Comprehensions
python内置非常强大的创建list的生成式。
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
<1>[0*0,1*1,2*2,3*3....]
>>> [x * x for x in range(11)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
<2>
>>> [x*x for x in range(1,11) if x %2 == 0]
[4, 16, 36, 64, 100]
<3>两层
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
<5>列出当前目录下所有文件
>>> import os
>>> [d for d in os.listdir('.')]
['data.txt', 'DLLs', 'Doc', 'include', 'Lib', 'libs', 'LICENSE.txt', 'NEWS.txt', 'python.exe', 'python3.dll', 'python35.dll', 'pythonw.exe', 'README.txt', 'Scripts', 'tcl', 'Tools', 'vcruntime140.dll']
<6>for循环可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value
>>> for k,v in d.items():
	print(k,'=',v)

	
y = B
z = C
x = A

4、生成器(generator)
一边循环一边计算的机制，称为生成器。只要将列表生成式的[]改为()就创建了一个生成器。
>>> g = (x*x for x in range(10))
>>> g
<generator object <genexpr> at 0x0000000003C83990>
>>> next(g)
0
>>> next(g)
1
通过next()函数获得generator的下一个返回值。
<1>generator保存的是算法，每次调用next()就计算下一个元素的值，直到最后一个元素。最终抛出StopIteration的错误。
>>> for x in g:
	print(x)

	
4
9
16
25
36
49
64
81
<2>使用yield关键字定义generator
def fib(max):
    n,a,b = 0,0,1
    while n < max:
        yield b
        a,b = b,a+b
        n  = n+1
    return 'done'
如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。
generator函数与普通函数执行流程不一样，普通函数是顺序执行的，遇到return语句或者最后一行语句就返回，
而generator函数在每次调用next()时执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

>>> reload(fib_text)
<module 'fib_text' from 'E:\\python_test\\fib_text.py'>
>>> 
>>> 
>>> fib_text.fib(10)
<generator object fib at 0x0000000003C83938>

>>> for n in fib_text.fib(10):
	print(n)
同样的把函数变为generator后，我们直接使用for循环来迭代，不需要使用next()

<3>如果想要取到返回值，就必须捕获StopIteration错误，返回值包含在StopIteration的value中。
>>> g = fib_text.fib(6)
>>> while True:
	try:
		x = next(g)
		print('g:',x)
	except StopIteration as e:
		print("Generator return value:",e.value)
		break;

	
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done

5、迭代器
可以直接作用于for循环的数据类型有：
集合类型：list、tuple、dict、set、str等
generator：生成器、带yield的generator function
这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。可以用isinstance()判断一个对象是否是Iterable。
可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

<1>生成器都是迭代器，但list、dict、str只是可迭代对象，却不是迭代器，可以使用iter()函数变为Iterator。
python的Iterator对象表示的是一个数据流，可以把这个数据流看做一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时才计算。

<2>for循环本质上就是通过不断调用next函数实现的


第三章 函数式编程

函数式编程 Functional Programming
函数是面向过程的程序设计的基本单元。

1、高阶函数(Higher-order function)
<1>函数本身可以赋值给变量，即变量可以指向函数。//f = abs
<2>函数名也是变量，函数名是指向函数的变量。//abs = -1
<3> 一个函数可以接收另一个函数作为参数，这种函数就称为高阶函数。
def add(x,y,f):
return f(x)+f(y)

1.1 map/reduce
<1>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
>>> def f(x):
	return x*x

>>> r = map(f,[1,2,3,4,5,6,7,8,9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> 

<1>reduce()
reduce把结果继续和序列下一个元素做累积计算。
reduce(f,[x1,x2,x3,x4]) = f(f(f(x1,x2),x3),x4)

1.2 filter() 过滤序列
filter()也是接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。

1.3 sorted()排序算法
sorted()函数也是一个高阶函数，它可以接收一个key函数来实现自定义的排序。

2、返回函数
2.1 函数作为返回值
高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
>>> def lazy_sum(*args):
	def sum():
		ax = 0
		for n in args:
			ax = ax + n
		return ax
	return sum

>>> 
>>> f = lazy_sum(1,2,3,4)
>>> f()
10
>>> f
<function lazy_sum.<locals>.sum at 0x0000000002A4C048>
>>> 
函数lazy_sum中定义了函数sum，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包(Closure)”的程序结构。
当我们调用lazy_sum函数时，每次调用都会返回一个新的函数，即使传入的参数相同：
>>> g = lazy_sum(1,2,3,4)
>>> f = lazy_sum(1,2,3,4)
>>> g == f
False
>>> g()==f()
True
>>> 

2.2 闭包
>>> def count():
	fs = []
	for i in range(1,4):
		def f():
			return i * i
		fs.append(f)
	return fs

>>> list(count())
[<function count.<locals>.f at 0x00000000039D6730>, <function count.<locals>.f at 0x00000000039D67B8>, <function count.<locals>.f at 0x00000000039D6840>]
>>> f1,f2,f3 = count()
>>> f1
<function count.<locals>.f at 0x00000000039D68C8>
>>> f2
<function count.<locals>.f at 0x00000000039D6950>
>>> f1()
9
>>> f2()
9
>>> f3()
9
>>> 
这个例子中每次循环都创建了一个新的函数，然后把三个函数都返回了。三个函数的执行结果都是9
原因在于返回函数引用了变量i，但它并非立刻执行，等到3个函数都返回时，它们所引用的变量i已经变成3了。
牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
<1>如果必须引用循环变量，就需要再创建一个函数
>>> def count():
	def f(j):
		def g():
			return j * j
		return g
	fs = []
	for i in range(1,4):
		fs.append(f(i))
	return fs

>>> f1,f2,f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9

<2>小结
一个函数可以返回一个计算结构，也可以返回一个函数。
返回一个函数时，牢记函数并未执行。

3、匿名函数
传入函数时，有时候不需要显示的定义函数，直接传入匿名函数更方便。
<1>关键字lambda表示匿名函数，冒号前面的x表示函数参数
lambda x: x * x 即为
def f(x):
    return x*x
<2>限制
匿名函数只能有一个表达式，不用return，返回值就是该表达式的结果。

匿名函数同样可以作为返回值，同样可以赋值给一个变量。

4、装饰器
在代码运行期间动态增加功能的方式被称为“装饰器”（Decorator）,本质上decorator就是一个返回函数的高阶函数。
<1>__name__属性
>>> f = lambda x : x * x
>>> f.__name__
'<lambda>'
>>> f = count
>>> f.__name__
'count'
>>> 

5、偏函数(partial function)
functools.partial的作用是把一个函数的某些参数给固定住(设为默认值)，返回一个新的函数，调用新函数更简单。

第四章 模块

<1>在python中，一个.py文件就称为一个模块(Module)。使用模块最大的好处是大大提高了代码的<1>可维护性。<2>可复用性。<3>避免函数名、变量名冲突。
<2>为了避免模块名冲突，python引入了按目录来组织模块的方法，称为包(Package)。只要顶层包名不冲突，那么所有的模块就不会冲突。
   每个包目录下都必须存在一个__init__.py文件，否则，python会把这个目录当成普通目录，而不是一个包。
   __init__.py文件可以为空，也可以有python代码，其本身就是一个模块，模块名为mycompany。

1、使用模块
1.1 作用域    前缀_
<1>正常的函数和变量名是公开的(public)，可以被直接引用；abc、x123、PI等
<2>类似__xxx__的特殊变量，可以被直接引用，但有特殊用途，如__author__,__name__
<3>类似_xxx和__xxx这样的函数或者变量就是非公开的(private),不应该被直接引用，如_abc,__abc等

模块将内部逻辑用private函数隐藏起来，这样调用公共函数就不用关心内部private函数的细节。这是一种非常有用的代码封装和抽象的方法。
外部不需要引用的函数全部定义为private，只有外部需要引用的函数才定义为public。

2、安装第三方模块 pip工具
<1>一般来说第三方库都会在python官方的pypi.python.org网站注册。可以官网或者pypi上搜索第三方库。
pip install Pillow  //图形库
mysql-connector-python //mysql驱动库
numpy //科学计算的库
Jinja2 //生成文本的模板工具

2.1 模块搜索路径
当我们试图加载一个模块时，python会在指定的路径下搜索对应的.py文件。
默认情况下，python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径为sys模块的path变量中：
>>> import sys
>>> sys.path
['', 'C:\\Program Files\\Python35\\Lib\\idlelib', 'C:\\Program Files\\Python35\\python35.zip', 'C:\\Program Files\\Python35\\DLLs', 'C:\\Program Files\\Python35\\lib', 'C:\\Program Files\\Python35', 'C:\\Program Files\\Python35\\lib\\site-packages']
<1>添加自己的搜索目录：
直接修改sys.path,这是在运行时修改，运行结束后失效；
或者设置环境变量PYTHONPATH


第五章 面向对象
面向对象编程--Object Oriented Programming(OOP)
1、类class和实例instance
class Student(object):
pass
<1>类的定义
class后面紧接着类名，类名通常是大写字母开头，紧接着是(object),表示该类从哪个类继承下来的。如果没有合适的继承类，就使用object类。它是所有的类的父类。
<2>创建实例
bart = Student()
类名+()

class Student(object):
    pass
此时却可以：
>>> bart = class_student.Student()
>>> bart.name = 'xiao'
>>> bart.name
'xiao'

<3>由于类可以起到模板的作用，因此可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。
通过定义一个特殊的__init__方法。注意到，__init__方法的第一个参数永远都是self，表示创建实例的本身。
与普通函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且调用时，不用传递该参数。
class Student(object):

    def __init__(self,name,score):
        self.name = name
        self.score = score

此时可以：
>>> from imp import reload
>>> reload(class_student)
>>> bart = class_student.Student('xiao',99)
>>> bart.name
'xiao'
>>> bart.score
99

1.1 数据封装
类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响。
和静态语言不同，python允许对实例变量绑定到任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但可以拥有不同的变量名称：
>>> xiao = class_student.Student('xiao',99)
>>> wang = class_student.Student('wang',97)
>>> 
>>> wang.age = 8
>>> 
>>> xiao.age
Traceback (most recent call last):
  File "<pyshell#14>", line 1, in <module>
    xiao.age
AttributeError: 'Student' object has no attribute 'age'
>>> wang.age
8
>>> 

2、访问限制
class内部有属性和方法。外部代码可以通过直接调用实例变量的方法来操作数据，这样就隐藏了内部的复杂逻辑。
<1>要让内部属性不被外部访问，可以把属性的名称前面加上__，以__开头表示是私有变量。只有内部可以访问，外部不能访问。
>>> bart.__name
Traceback (most recent call last):
  File "<pyshell#11>", line 1, in <module>
    bart.__name
AttributeError: 'Student' object has no attribute '__name'
<2>外部获取属性：给Student类增加get_name和get_score等方法
<3>外部修改属性：给Student类增加set_name和set_score等方法
这样做的目的，是可以在set方法中进行安全性检测，避免传入无效参数。
    def set_score(self,score):
        if 0 <= score <= 100:
            self.__score = score
        elif:
            raise ValueError('bad score!')

<4>_name 这样的变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”
<5>双下划线开头的实例变量是不是一定不能从外部访问呢？其实不是
不能直接访问__name只是因为解释器对外把__name变成了_Student__name，可以通过_Student__name来访问__name变量
>>> xiao._Student__name = 'New name'
>>> xiao.get_name()
'New name'
>>> 
但强烈不建议这么做，因为不同版本的python解释器会将__name改成不同的变量名。
<6>错误写法：
>>> xiao.__name = '123'、
>>> xiao.__name
'123'
表面上看，外部代码成功设置了__name变量，实际上，这个__name变量和class内部的__name变量不是一个变量。
内部的__name变量已经被解释器自动改成了_Student__name，而外部代码给xiao新增了一个__name变量。
>>> xiao.get_name()
'New name'

3、继承和多态
定义一个class时，可以从现有的class继承，新的class称为子类(subclass),被继承的class称为基类、父类、超类。
<1>子类通过继承可以获得子类的全部功能。
class Animal(object):
    def run(self):
        print('Animal is running...')

class Dog(Animal):
    pass

class Cat(Animal):
    pass

Cat和Dog继承了run方法：
>>> dog = animal.Dog()
>>> dog.run()
Animal is running...
>>> cat = animal.Cat()
>>> cat.run()
Animal is running...
>>> 
<2>子类可以对基类的方法进行改写
class Dog(Animal):

    def run(self):
        print('Dog is running...')

    def eat(self):
        print('Dog is eating...')

>>> dog = animal.Dog()
>>> dog.run()
Dog is running...
当子类和父类都存在相同的run()方法时，子类的run()覆盖了父类的run()。
代码运行时，总是会调用子类的run(),这就是继承的另一个好处：多态。
<3>什么是多态：
>>> b = animal.Dog()
>>> isinstance(b,animal.Animal)
True
>>> isinstance(b,animal.Dog)
True
变量b既是Animal类型又是Dog类型，所以，在继承关系中，如果一个实例的数据类型是某个子类，那么它的数据类型也可以被看做是父类。反之则不成立。
多态的好处在于：当我们需要传入Dog、Cat...时，我们只需要接收Animal类型就可以了，因为Dog、Cat...都是Animal类型。
“开闭”原则：对扩展开发，允许新增Animal子类；对修改封闭，不需要修改依赖Animal类型的方法。

<4>静态语言 VS 动态语言
对于静态语言，如果需要出传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。
对于动态语言，则不一定需要传入Animal类型，我们只需要保证传入的对象有一个run()方法即可。
>>> class Timer(object):
	def run(self):
		print('start...')

>>> def animal_run(animal):
	animal.run()

>>> animal_run(Dog())
Dog is running...
>>> animal_run(Timer())
start...

这可能是因为python不注重类型，函数animal_run()并没有限制入参的类型。

4、获取对象信息
<1>type() 用于判断对象类型
>>> type(123)
<class 'int'>
>>> type('123')
<class 'str'>
>>> dog = Dog()
>>> type(dog)
<class 'animal.Dog'>
>>> type(abs)
<class 'builtin_function_or_method'>
>>> 
>>> Dog == type(dog)
True
>>> str == type('123')
True
>>> int == type(123)
True
>>> 
<2>isinstance() 与type()类似，在处理class继承关系时更好用
<3>dir()  获得一个对象的所有属性和方法，返回一个包含字符串的list。

5、实例属性和类属性
<1>实例属性：给实例绑定属性，通过实例变量或者self
class Student(object):
    def __init__(self, name):
        self.name = name
 //self


s = Student('Bob')
s
s.score = 90  //实例变量
<2>类属性：归某个类所有的属性，直接在class中定义属性。
class Student(object):
    name = 'Student' //类属性

<3>类属性虽然归类所有，但类的所有实例都可以访问到。

>>> class Student(object):
...     name = 'Student'
.
...

>>> s = Student() # 创建实例s
>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
S
Student

>>> print(Student.name) # 打印类的name属性
S
Student

>>> s.name = 'Michael' # 给实例绑定name属性
>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
M
Michael

>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
S
Student

>>> del s.name # 如果删除实例的name属性
>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
S
Student

<4>可以看出编写程序时，不要将实例属性和类属性使用相同的名字，否则实例属性会屏蔽掉类属性。
但将实例属性删除后，再使用相同的名称，访问到的将是类属性。


第六章 面向对象高级编程
class Student(object):
    pass

>>> def set_score(self,score):
	self.score = score

>>> student.Student.set_socre = set_score
通常情况下，类的方法直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。

一、使用__slots__
定义特殊变量__slots__来限制实例的属性。
class Student(object):
    __slots__ = ('name','age')

>>> s=student.Student()
>>> s.name ="xiao"
>>> s.age=28
>>> s.score = 100
Traceback (most recent call last):
  File "<pyshell#225>", line 1, in <module>
    s.score = 100
AttributeError: 'Student' object has no attribute 'score'
1、使用__slots__的注意点
__slots__定义的属性仅对当前类实例起作用，对继承的子类不起作用。
除非在子类中也定义__slots__,这样子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。

二、使用@property
绑定属性时，如果直接把类的属性暴露出去，虽然写起来简单，但是，没有参数检查，导致成绩可以随意改；
通过增加set_score()方法来设置成绩，再通过get_score()来获取成绩，这样的调用方法又略显复杂，没有直接操作属性简单。
python内置@property装饰器就是负责将一个方法变成属性调用的：

三、多重继承
通过多重继承，一个子类就可以同时获取多个父类的所有功能。
1、MixIn
MixIn的目的就是给一个类增加多个功能。在设计类时，我们优先考虑通过多重继承来组合多个MixIn功能，而不是设计多层次的复杂的继承关系。

四、定制类
<1>__slots__
<2>__len__		len()
<3>__str__		str()		__repr__
<4>__iter__

五、枚举类  Enum
为枚举类型定义一个class类型，每个常量都是class的唯一实例。


第七章I/O编程

<1>I/O：输入输出
Stream(流)：可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。 Input/Output Stream 
<2>CPU和内存的速度远远高于外设(如：磁盘)的速度，存在速度严重不匹配的问题。
--同步IO：CPU等着，程序暂停执行后续的代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；
--异步IO：CPU不等待，立即执行后续代码。回调(服务员跑过来找你)/轮询(服务员发短信通知，你就得不停地检查手机)
<3>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的c接口封装起来方便使用。
python内置的读写函数，用法和C是兼容的。

一、文件读写
在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，读写文件就是请求操作系统打开一个文件对象(文件描述符)，然后，通过操作系统提供的接口从这个对象中读写数据。
1、读文件  
<1>f = open():传入文件名和标识符，如果文件不存在，返回一个IOError错误；
<2>f.read():读取文件的全部内容，读到内存中，用一个str对象表示；
<3>f.close():关闭文件，释放资源。
2、调用read()会一次性读取文件的全部内容；    //文件较小时使用
   如果文件太大，可以反复调用read(size);     //不能确定文件大小时使用
   调用readline()可以每次读取一行内容；
   调用readlines()一次读取所有内容并按行返回list。//读取配置文件时使用

3、file-like object
像open()函数返回的这种有个read()方法的对象，称为file-like object。除了file外，还可以是内存字节流，网络流，自定义流等。
file-like object不要求从特定类继承，只要写一个read()方法即可。
StringIO就是在内存中创建的file-like object，常用作临时缓冲。

4、二进制文件
读取二进制文件需要用'rb'模式打开。

5、字符编码
<1>要读取非UTF-8编码的文本文件，需要给open()插入encoding参数，例如，读取GBK编码文件：
>>> f = open('E:\\python_test\\12.txt','r',encoding='gbk')
>>> f.read()
'笑笑'
<2>遇到有编码不规范的文件，可能会遇到UnicodeDecodeError，这是因为在文本文件中夹杂了一些非法编码的字符。可以在open()中增加一个errors参数：
errors=‘ignore’

6、写文件
‘w’：文本文件 
'wb'：二进制文件
可以反复调用write()来写入文件，但务必要调用f.close()来关闭文件。
写文件时，操作系统往往不会立即把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，系统才保证把没有写入的数据全部写入磁盘。

7、with...as...语句
with open('','') as f:
f.write('')/print(f.read())
这样可以不调用close()函数。
在python中，使用with语句操作文件IO是个好习惯。

二、StringIO和BytesIO
1、StringIO
很多时候，数据读写不一定是文件，也可以是在内存中读写。StringIO实在内存中读写str。
>>> from io import StringIO
>>> f = StringIO()
>>> 
>>> f.write('Hello')
5
>>> f.write(' ')
1
>>> f.write('world!')
6
>>> print(f.getvalue())
Hello world!
要把str写入StringIO，我们需要先创建一个StringIO，getvalue()用于获得写入后的str。

2、BytesIO
StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。同样需要先创建一个BytesIO。
>>> from io import BytesIO
>>> f = BytesIO()
>>> f.write('中文'.encode('utf_8'))
6
>>> print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'
注意：写入的是经过UTF_8编码的bytes，不是str。

三、操作文件和目录
内置的os模块可以直接调用操作系统提供的接口函数，操作文件、目录。
import os
os.name
如果是posix，说明系统是Linux、Unix、Mac，如果是nt，则是windows系统。
os.uname() //更详细的信息
1、环境变量
os.environ
os.environ.get('PATH')
2、操作文件和目录
<1>os.path.abspath('.') 查看当前目录的绝对路径
<2>os.path.join('','')  在某个目录下创建一个新目录，并列出新目录完整路径
   os.mkdir('')         创建一个目录
<3>os.rmdir('')	      删除一个目录
>>> os.path.abspath('.')
'E:\\python_test'
>>> os.path.join('E:\\python_test','123')
'E:\\python_test\\123'
>>> os.mkdir('E:\\python_test\\123')
>>> os.rmdir('E:\\python_test\\123')
<4>两个路径合并为一个时，不要直接拼字符串，而是通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。
unix下：part-1/part-2
windows下：part-1\part-2
<5>同样拆分路径时，也不要直接拆分字符串，而是通过os.path.split()函数。后一部分总是最后级别的目录或文件名。
<6>os.path.splitext() 可以直接得到文件的扩展名
注意：os.path.join()、os.path.split()、os.path.splitext()不需要目录和文件真实存在，它们只对字符串进行操作。
<7>对文件操作：
os.rename('','') 对文件重命名
os.remove('')    删除文件
<8>shutil模块提供了copyfile()函数用于复制文件
   shutli是对os模块的补充。
<9>os.listdir('.')//列出所有文件和目录
   os.path.isdir()

四、序列化
在程序运行过程中所有变量都在内存中，修改变量后，一旦程序结束，变量所占的内存就被系统全部回收。如果没有把修改后的变量的值存储到磁盘中，下次重新运行程序，变量又被初始化为原先的值。
<1>把变量从内存中变成可存储或传输的过程称之为序列化。python中称为pickling。python提供pickle模块来实现序列化。
序列化后，就可以把序列化的内容写入磁盘，或者通过网络传输到别的机器上。
-pickle.dumps()方法把任意对象序列化成一个bytes，然后就可以把这个bytes写入文件。
>>>import pickle
>>> d = dict(name='bob',age=20,score=99)
>>> d
{'name': 'bob', 'age': 20, 'score': 99}
>>> pickle.dumps(d)
b'\x80\x03}q\x00(X\x04\x00\x00\x00nameq\x01X\x03\x00\x00\x00bobq\x02X\x03\x00\x00\x00ageq\x03K\x14X\x05\x00\x00\x00scoreq\x04Kcu.'
-pickle.dump()方法直接把对象序列化写入一个file-like Object。
>>> f = open('dump.txt','wb')
>>> pickle.dump(d,f)
>>> f.close()
<2>把变量的内容从序列化的对象重新读到内存里称之为反序列化，unpickling。
- pickle.loads():把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用loads()方法反序列化对象。
- pickle.load():也可以直接使用load()方法从一个file-like object中直接反序列化出对象。
>>> f=open('dump.txt','rb')
>>> d = pickle.load(f)
>>> f.close()
>>> d
{'name': 'bob', 'age': 20, 'score': 99}
1、JSON
需要在不同编程语言之间传递对象时，就必须把对象序列化为标准格式，XML、JSON。JSON的编码是UTF_8
import json
json.dumps/dump
json.loads/load

2、JSON进阶


第八章 异步I/O

1、要解决的问题：CPU高速执行能力和IO设备的龟速严重不匹配
   解决方法：<1>多线程、多进程
             <2>异步IO
2、异步IO
当代码需要执行一个耗时IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。
一段时间后，当IO返回结果时，再通知CPU进行处理。
<1>按普通顺序写出的代码实际上是无法完成异步IO的：

<2>异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复"读取消息-处理消息"

一、协程(coroutine)
协程又叫微线程、纤程。
协程看上去是子程序，但在执行过程中，在子程序内部可以中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。(不是函数调用，而是类似CPU的中断)


def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)

[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK

整个流程无锁，由一个线程执行，produce和consumer协作完成任务，而非线程的抢占式多任务。

二、asyncio //python 3.4引入的标准库，直接内置了对异步IO的支持
asyncio的编程模型就是一个消息循环，从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。


第九章 进程和线程

一、多进程
Unix操作系统提供了fork()系统调用，fork()调用一次返回两次，将当前进程(父进程)复制一份(子进程)，然后分别在父进程和子进程内返回。
子进程永远返回0，父进程返回子进程的ID。一个父进程可以fork出很多子进程，所以父进程要记录下子进程的ID，而子进程只需要调用getppid()就可以得到父进程的ID。
os模块分装了常见的系统调用，包括fork()。注：由于windows没有fork调用，因此windows下python不能使用fork()。
1、mutiprocessing
mutiprocessing模块提供了process类来代表一个进程对象。
创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start


第十章 其他

一、os
1、IDLE中切换路径
import os
os.getcwd()  //获取当前路径
os.chdir("") //跳转到目标路径下

2、os.system()
python中可以方便地使用os模块运行其他脚本或程序，这样就可以在python脚本中直接使用其他脚本，或者其他程序提供的功能。
os.system(command)  //cmd为要执行的命令。如果要向脚本传递参数，可以用空格分隔。
eg:
>>> import os
# 使用os.system()函数打开记事本程序
>>> os.system('notepad')
0 # 关闭记事本后的返回值
# 向记事本传递参数，打开python.txt文件
>>> os.system('notepad python.txt')

<1>其中/表示转义符，但在指明路径时，要使用/本身，需要：
1)需要先用转义符转义，就像这样 \\
2)还有一种方法,就是字符串之前加上一个字母r，表示该字符串是原始字符串，此时的转义符就无效了。os.system(r'字符串')

3、os.listdir(dir) //列出目录下的文件和文件夹

4、os.remove(file) //删除指定路径的文件

二、sys
1、import sys
<1> sys.argv 脚本参数。 
没有sys.argc，可以通过len(sys.argv)获取参数个数；
<2> sys.argv[0]?脚本名
<3> sys.argv[1:] 所有参数

三、re   import re
1、re.split()

2、re.search()

3、re.compile()

四、字符串、文件操作
1、文件操作
http://blog.csdn.net/wirelessqa/article/details/7974531

shutil.rmtree(dir) //删除文件夹及该文件夹下的所有文件
os.remove("file") //删除文件
os.rmdir("dir") //只能删除空目录

---------------------------------------------------------------------------------------------------------------
DOS下的一些命令

1、subst
eg： E盘下有个目录叫 test，可以将其映射为一个虚拟盘Z。  subst  z:   e:\tsest

2、rd/s/q 文件夹   //强制删除文件夹
   del    文件     //强制删除文件
   
3、rem [comment]//指定要作为注释的任何字符串

4、wine 程序.exe 参数  //启动某个程序执行某个命令
eg wine cmd.exe < /home/version/gerrit/rcp/tools/PCLint/bat/${module}.bat
----------------------------------------------------------------------------------------------------------------
python 2.7 与 3.5

1、2.7 格式 os.system('**.sh')
   3.5 格式 os.system('sh **.sh') \  os.system('**.sh') 都支持




















