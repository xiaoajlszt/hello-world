第二章 python如何运行程序
1、python解释器：
python既是一门编程语言，又是一个名为解释器的软件包。解释器是一种让其他程序运行起来的程序。
当编写了一段python程序，python解释器将读取程序，并按照其中的命令执行，输出结果。
实际上，解释器是代码与计算机硬件之间的软件逻辑层。python代码必须在解释器中运行。

2、python的视角
当python运行脚本时，在代码开始进行处理之前，python还会执行一些步骤。
第一步是编译成所谓的“字节码”，之后将其转发到所谓的“虚拟机”中。
<1>字节码编译
python内部会先将源代码编译成所谓的字节码的形式。字节码可以提高执行速度。
如果python进程在机器上具有写入权限，那么它将把程序的字节码保存为一个以.pyc为扩展名的文件。
当python需要重新编译时，它会自动检查源文件和字节码文件的时间戳：若果你又保存了源代码，下次程序运行时，字节码将自动重新创建。
<2>python虚拟机（PVM）
一旦程序编译成字节码，字节码会发送到python虚拟机上来执行。
PVM不是一个独立的程序，不需要安装。PVM就是迭代运行字节码指令的一个大循环。
PVM时python的运行引擎，它时常表现为python系统的一部分，并且它是实际运行脚本的组件。

<3>性能
python代码无法运行得像c/c++代码一样快的原因：
--python工作是没有make的步骤，代码在写好之后立即运行。程序开始执行之前不需要预编译和连接。
--python字节码不是机器的二进制代码，而是特定于python的一种表现形式。
PVM循环仍需要解释字节码，并且字节码指令与CPU指令相比需要更多工作。

<4>开发的含义
程序开始执行之前不需要预编译和连接，这同样使python具有更多动态语言特性。python代码可以动态的修改。
牢记python中真正拥有的只有运行时:完全不需要初始化的编译阶段，所有事情都是在程序运行时发生的。

3、python实现的替代者
python语言有三种主要实现方式：CPython(标准实现)、Jython(java)、IronPython(.NET)。所有这些都是用来实现python语言，只是通过不同的形式执行程序而已。
CPython、CPython、IronPython都是通过同样的方式实现python语言的，即通过把源代码编译为字节码，然后在适合的虚拟机上执行这些代码。

4、执行优化工具
<1>Psyco实时编译器：Psyco系统并不是python的另一种实现方式，而是一个扩展字节码执行模块的组件，可以让程序运行的更快。
   Psyco是一个PVM增强工具，可以将部分程序的字节码转换成底层真正的二进制机器码，从而实现更快的执行速度。
<2>Shedskin C++转换器

5、冻结二进制文件
冻结二进制文件能够将程序的字节码、PVM以及任何需要的python支持文件捆绑在一起形成一个单独的文件包。结果将会是一个单独的可执行的二进制程序，这个程序可以很容易地向客户分发。这好像将字节码和PVM混合在一起形成一个独立的组件--冻结二进制文件。
py2exe(windows)\pyinstall(linux、unix)
冻结二进制文件中嵌入了python，因此接收端不需要安装python来运行它。

第三章 如何运行程序
1、交互提示模式：
<1>退出交互对话：UNIX下ctrl-d；windows下ctrl-z
<2>当在>>>提示符下输入一条语句时，输出立即显示出来。没有必要像c/c++运行代码前要先通过编译器和连接器；
   可以在交互提示符中运行多行语句（复合语句），当输入所有语句行且两次按下Enter键添加一个空行之后，会立即执行这条语句。
<3>当你对一段代码运行有任何疑问时，打开交互命令行并实验代码。

2、交互式地导入模块文件eg ：import os

3、系统命令行和文件
<1>模块是一个包含了python语句的简单文本文件。每当运行模块文件时，python都会从头到尾执行模块文件中的每一条代码。
   可以直接运行的模块文件往往也称为脚本。
<2>注意点：
--注意windows上的默认扩展名（隐藏）
--在系统提示模式下需要文件扩展名.py，在导入时不需要文件扩展名.py
--在文件中要使用print语句，交互式命令行中可以不需要。

4、UNIX可执行脚本(#!)
UNIX风格的可执行脚本包含了python语句的一般文本文件，但是有两个特殊属性
<1>它们第一行是特定的，以字符#!开始，后面紧跟机器python解释器的路径。
#!/uer/local/bin/python (直接列出python安装路径)
#!/usr/bin/env python   (UNIX env查找，不需要列出python安装路径，更具有移植性)
<2>它们往往都拥有可执行的权限。

5、模块导入和重载
导入同时也是一种启动程序的方法。每一个以扩展名py结尾的python源代码文件都是一个模块，其他的文件可以通过导入一个模块读取这个模块的内容。导入从本质上来讲就是载入另一个文件，并能够读取那个文件的内容。
基于模块的方式使模块成为了python程序架构的一个核心概念。更大的程序往往以多个模块文件的形式出现。其中一个模块文件设计成主文件，或叫做顶层文件。
from imp import reload
--import是一个语句，reload是一个被调用的函数，因此reload参数需要加括号。reload(script1)   import script1
--reload是不可传递的，重载一个模块的话只会重载该模块，而不能够重载该模块所导入的任何模块，因此有时候必须reload多个文件。

6、模块的显要特性：属性
模块往往就是变量名的封装，被认为是命名空间。在一个包中的变量名就是所谓的属性：也就是说，属性是绑定在特定的对象上的变量名（就像一个模块）。
一个模块文件的变量名可以通过两个python语句读取：import和from，以及reload调用。
--from和import很相似，只不过增加了对载入组件的变量名的额外赋值。from复制了模块的属性，以便属性能够成为接收者的直接变量。
--内置dir函数可以用来获取模块内部的可用的变量名列表。dir(myfile)

7、模块和命名空间
每个模块文件时一个独立完备的变量包，即一个命名空间。一个模块文件不能看到其他文件定义的变量名，除非它显示地导入了那个文件。
所以模块文件在代码中起到了最小化命名冲突的作用。

8、使用exec运行模块文件
--从交互提示模式启动文件而不必导入以及随后的重载，每次exec都运行文件的版本。
--exec调用有着类似import的效果，它从技术上不会导入模块，默认情况下，每次以这种方式调用exec时，它都重新运行文件。
--缺点是，exec工作机制就像是在调用它的地方粘贴代码一样，对当前使用的变量有潜在默认覆盖的可能。
  而import会把文件生成到一个单独的模块命名空间中，不会改变作用域里的变量（from可能会影响），但要付出修改后需要重载的代价。

9、嵌入式调用（python程序被嵌入在其他程序中运行）
C语言编写的程序通过连接python解释器的库嵌入python解释器，并传递给解释器一行python语句去运行。

10、pdb


第4章 介绍python对象类型
1、内置类型
<1>python程序中处理的每样东西都是一种对象，它们有各自的行为。函数、模块和类这样的编程单元在python中也是对象。
<2>python中没有类型声明（python是动态类型的，它自动跟踪类型而不是要求声明代码），运行的表达式的语法决定了创建和使用的对象的类型。一旦创建了一个对象，它就和操作集合绑定了。它是强类型语言，只能对一个对象进行适合该类型的有效操作。

2、数字
<1>整数、浮点数以及更少见的类型（复数等）
<2>+ * **乘方
<3>数学模块：math--数学工具
		 random--随机数生成器、随机选择器

3、字符串
是python中作为序列的第一个例子。字符串是单个字符的字符串序列。其他类型的序列还包括列表和元组。
<1>python允许字符串包括在单引号或双引号中，它们代表着相同的东西。
<2>python允许在三个引号（单/双）中包含多行字符串常量，此时，所有的行都合并在一起，并在每一行的末尾增加换行符。
>>> msg = '''aaaaaaaaaaaaaaa
bbbbbbbbbbbbbbb
ccccccccccccccc'''
>>> msg
'aaaaaaaaaaaaaaa\nbbbbbbbbbbbbbbb\nccccccccccccccc'
>>> print(msg)
aaaaaaaaaaaaaaa
bbbbbbbbbbbbbbb
ccccccccccccccc
>>> 

3.1 序列操作
len()　　
<1>序列：一个包含其他对象的有序集合。序列中的元素包含了一个从左到右的顺序，序列中的元素根据它们的相对位置进行存储和读取。
<2>索引和反向索引：索引类似与C中的数组下标，从最左边的偏移量进行编码，0,1,2...
                   反向索引从最右边开始计算-1,-2
			 s = 'spam'  s[-1] == s[len(s)-1]
<3>分片(slice):从字符串中一步就提取出一部分的方法。X[I:J]。s = 'spam'   s[1:3] = 'pa'
X[I:J] 取出在X中从偏移量为I，直到但不包含偏移量J的内容。在一个分片中，左边界默认为0，右边界默认为分片序列的长度。

负偏移量如何用作分片的边界：s[:-1] = 'spa'
作为一个序列，字符串也支持使用加号进行合并(将两个字符串合并成一个新的字符串)，或者重复(通过再重复一次创建一个新的字符串)

3.2 不可变性
<1>字符串在python中具有不可变性--创建之后不能就地改变。例如，不能通过对其某一位置进行赋值而改变字符串。
>>> s[0] = '1'
Traceback (most recent call last):
  File "<pyshell#69>", line 1, in <module>
    s[0] = '1'
TypeError: 'str' object does not support item assignment
<2>但可以通过建立一个新的字符串，并以同一个变量名对其进行赋值。python在运行过程中会清理旧的对象。
>>> s = "xapm"
>>> s
'xapm'
>>> s = 'z' + s[1:]
>>> s
'zapm'

3.3 类型特定的方法 //不改变原始的字符串，创建一个新的字符串作为结果
<1>find():一个基本的字符串查找的操作，返回一个传入子字符串的偏移量，或者在没有找到的情况下返回-1。
<2>replace():对全局进行搜索和替换。
<3>split():通过分隔符将字符拆分为子字符串
<4>upper():大写
<5>格式化：

3.4 帮助
<1>dir():将返回一个列表，包括对象的所有属性。dir(s)    //方法是函数属性
<2>help():查询方法是做什么的。help(s.replace)

3.5 编写字符串的其他方法
<1>反斜杠转义序列表示特殊的字符    注意：python中'\0'不会结束一个字符串，与C/C++不同
<2>raw字符串常量:即去掉反斜杠转义机制（这样的字符串常量是以字母r开头的）。

3.6 模式匹配
导入re模块
>>> import re
>>> match = re.match('/(.*)/(.*)/(.*)','/1/2/3')
>>> match.groups()
('1', '2', '3')

4、列表：
python的列表对象是这个语言提供的最通用的序列。列表是一个任意类型的对象的位置相关的有序集合，它没有固定的大小。
列表大小是可变的，通过对偏移量进行赋值以及其他各种列表的方法进行调用，确实能够修改列表的大小。
4.1 序列操作
<1>len()
<2>索引
<3>切片

4.2 类型特定的操作
python列表比其他语言的数组强大得多，列表没有固定类型的约束（L = [1,'spam',1.23]），可以包含不同类型的对象。
列表没有固定大小，可以按照需要增加或减小列表大小。
<1>append():在列表末尾添加一个对象
<2>pop()/del():移除给定偏移量的一项
<3>insert()：在任何位置插入元素
<4>remove():按值移除元素
<5>reserve():元素倒序
<6>sort():升序排序
因为列表是可变的，大多数列表的方法都会就地改变列表对象，而不是创建一个新的列表。

4.3 边界检测
尽管列表没有固定的大小，python仍不允许引用不存在的元素。

4.4 嵌套
python核心数据类型的一个优秀特性就是它们支持任意的嵌套。多层嵌套，例如能让一个列表包含一个字典，并在这个字典中包含另一个列表等。（多维数组）
>>> M = [[1,2,3],[4,5,6],[7,8,9]]
>>> M
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> M[1][1]
5

4.5 列表解析
列表解析创建了一个新的列表作为结果，但是能够在任何可迭代的对象上进行迭代。
<1>通过列表解析获得列：
>>> col2 = [row[1] for row in M]
>>> col2
[2, 5, 8]
<2>

5、字典
<1>字典不是序列，而是一种映射(mapping)，映射是一个其他对象的集合，但是它们是通过键而不是相对位置来存储的。
<2>字典与列表一样具有可变性--可以就地改变，并可以随需求增大或减小。
注：字典不包含任何可靠的从左至右的顺序，这意味着建立一个字典，并将它打印出来，它的键也许以与我们输入时不同的顺序出现。

5.1 映射操作
作为常量编写时，字典编写在大括号内，并包含一系列的“键：值”对。当需要将健与一系列值相关联时，字典是很有用的。
<1>可以通过键对字典进行索引来读取或改变键所关联的值，方括号里面的元素是键，而不是相对位置。
<2>字典的创建
通过键索引一个字典往往是python中编写搜索的最快方法。

5.2 重访嵌套
python具有垃圾收集的特性，在程序运行时可以清理不再使用的内存。一旦一个对象的最后一次引用被移除，空间将会立即收回。
不需要为创建和清理对象空间而的担心。

5.3 键的排序
使用sort方法进行排序，然后使用for循环逐个进行显示结果。
{'c': 3, 'b': 2, 'a': 1}
<1>
>>> Ks = list(D.keys())
>>> Ks
['c', 'b', 'a']
>>> Ks.sort()
>>> Ks
['a', 'b', 'c']
>>> for key in Ks:
	print(key,'=>',D[key])

	
a => 1
b => 2
c => 3
<2>
>>> for key in sorted(D):
	print(key, '=>', D[key])

	
a => 1
b => 2
c => 3

5.4 迭代和优化 
从左到右扫描一个对象的每个python工具都使用迭代协议。字典是可迭代对象，可以用一个next返回后续的键。
>>> squares = [x ** 2 for x in [1,2,3,4]]
>>> squares
[1, 4, 9, 16]
<1>列表解析和相关的函数编程工具，如map和filter，通常运行得比for循环快。

5.5 不存在的键：if测试
<1>通过给新的键赋值来扩展字典：
>>> D['e'] = 4
>>> D
{'c': 3, 'e': 4, 'b': 2, 'a': 1}
<2>获取一个不存在的键是错误的：
>>> D['f']
Traceback (most recent call last):
  File "<pyshell#64>", line 1, in <module>
    D['f']
KeyError: 'f'
<3>当不知道存在什么键时，先进行测试
>>> 'f' in D
False
<4>get方法：带有一个默认值的条件索引
   hash_key
   try语句 
   if/else

6、元组(tuple)
元组对象基本上就像一个不可变列表。元组是序列，但它具有不可变性，和字符串类似。
元组编写在圆括号中，支持任意类型、任意嵌套以及常见的序列操作。
>>> T = (1,2,3,4)
>>> T
(1, 2, 3, 4)
>>> len(T)
4
>>> T + (5,6)
(1, 2, 3, 4, 5, 6)
>>> T
(1, 2, 3, 4)
>>> T.index(4) //4出现的偏移位置
3
>>> T.count(4) //4出现几次
1
<1>元组一旦创建之后就不能改变，也就是说，元组是不可变的序列。
>>> T[0] = 1
Traceback (most recent call last):
  File "<pyshell#83>", line 1, in <module>
    T[0] = 1
TypeError: 'tuple' object does not support item assignment
<2>与列表和字典一样，元组支持混合的类型和嵌套，但不能增长或缩短。
6.1 为什么要用元组

7、文件
调用内置的open函数以字符串的形式传递给它一个外部的文件名以及一个处理模式的字符串。
>>> f = open('data.txt','w')
>>> f.write('hello\n')
<1>文本文件和二进制文件
7.1 其他文件类型工具
管道、先进先出队列(FIFO)、套接字、通过键访问文件、对象持久、基于描述符的文件、关系数据库和面向对象的数据库接口

8、其他核心类型
集合、固定精度浮点数、分数、布尔值、占位符对象(None)

9、如何破换代码的灵活性
内置函数type()返回对象的类型
在代码中检验了特定的类型，实际上破换了它的灵活性，即限制了它只能使用一种类型工作。

10、用户定义的类
隐含的self对象是我们把这叫做面向对象模型的原因，即一个类中的函数总有一个隐含的对象。
