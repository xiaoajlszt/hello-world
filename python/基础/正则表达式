1、基础
<1>匹配法则
\d 		匹配一个数字
\w 		匹配一个字母或数字
\s		匹配一个空格字符(与[\n\t\r\v\f]相同)
.  		匹配任意字符
*  		匹配任意个字符(包括0个)
+  		表示至少1个字符
？ 		表示0个或1个字符
{n}		表示n个字符
{n,m}	表示n到m个字符

<2>示例
eg： \d{3}\s+\d{3,8}
\d{3} 	匹配3个数字
\s+	  	匹配至少一个空格字符
\d{3,8}	匹配3-8个数字

eg：要匹配'010-12345'这样的号码
由于'-'是特殊字符，在正则表达式中要用'\'转义。
\d{3}\-\d{3,8}

2、进阶
要做到精确匹配，可以使用[]表示范围。

<1>匹配法则
[0-9a-zA-Z\_]   匹配一个数字、字母或者下划线
[0-9a-zA-Z\_]+	匹配至少由一个数字、字母或者下划线组成的字符串
[a-zA-Z\_][0-9a-zA-Z\_]*  匹配由字母或下划线开头，后接任意个由数字、字母或者下划线组成的字符串
[a-zA-Z\_][0-9a-zA-Z\_]{0,19} 	更精确地限制了变量的长度1-20个字符。

A|B  匹配A或B  	//(p|P)ython  可以匹配'python'或'Python'
^	 表示行的开头
^\d	 表示必须以数字开头
$	 表示行的结尾
\d$	 表示必须以数字结束

3、re模块
<1>要注意Python字符串本身也用'\'转义

几组对比：
1)
>>> m = r'abc\\-001' //这里的'\\'实际中也是'\\'，因此长度为9
>>> m
'abc\\\\-001'		 //显示
>>> print(m)
abc\\-001			 //实际
>>> print(len(m))
9


>>> n = 'abc\\-001'  //这里的'\\'实际只是一个字符'\'，因此长度为8
>>> n
'abc\\-001'			
>>> print(n)
abc\-001
>>> print(len(n))
8


2)
>>> x = r'abc\123'
>>> x
'abc\\123'
>>> print(x)
abc\123
>>> print(len(x))
7


>>> y = 'abc\123'
>>> y
'abcS'
>>> print(y)
abcS
>>> print(len(y))
4

因此强力建议使用r前缀，r''表示引号内部的字符串不转义。

<2>match()方法
re模块的match方法判断是否匹配，如果匹配返回一个match对象，否则返回None。
>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
>>>

<3>切分字符串
>>> 'a b  c d ef'.split(' ') 			//固定字符切分(无法识别连续的空格)
['a', 'b', '', 'c', 'd', 'ef']

>>> re.split(r'\s+','a b  c d ef')		//空格切分
['a', 'b', 'c', 'd', 'ef']

>>> re.split('[\s\,]+','a,b  c,d ef') 	//空格或逗号切分
['a', 'b', 'c', 'd', 'ef']

<4>分组
正则表达式具有提取子串的功能，用()表示的就是要提取的分组。

eg：提取电话号码
>>> m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'

注意到group(0)永远是原始字符串，group(1)、group(2)...表示第1、2、...个子串。

<5>贪婪匹配
正则匹配默认是贪婪匹配，即匹配尽可能多的字符。

>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')

\d+采用贪婪匹配，因此0*只能匹配空字符串。


>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')

\d+? 采用非贪婪匹配(尽可能少匹配)

<6>编译
1)当我们在Python中使用正则表达式时，re模块内部会干两件事情：
- 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
- 用编译后的正则表达式去匹配字符串。

2)因此如果一个正则表达式需要重复使用很多次，出于效率考虑，我们可以对它进行预编译。
接下来重复使用时就不需要进行编译了。

# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')

编译后生成re对象，由于该对象包含了正则表达式，因此调用对应的方法时不需要再给出正则表达式。



















