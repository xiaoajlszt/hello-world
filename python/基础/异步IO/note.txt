1. CPU的速度远远快于磁盘、网络等IO。
在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。
这种情况称为同步IO。

为了解决线程阻塞的问题:
<1>可以使用多线程或者多进程来并发执行代码，为多个用户服务。
每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。

多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程，因为系统切换线程的开销也很大。

<2>另一种解决IO问题的方法是异步IO。
当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。
一段时间后，当IO返回结果时，再通知CPU进行处理。

2. 普通顺序写出的代码实际上是没法完成异步IO的
异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复"读取消息-处理消息"这一过程：
loop = get_event_loop()
while True:
    event = loop.get_event()
    process_event(event)
	
<1>消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。
所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。

由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。
某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。
这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。

<2>消息模型是如何解决同步IO必须等待IO操作这一问题的呢？
当遇到IO操作时，代码只负责发出"IO请求"，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。
当IO操作完成后，将收到一条"IO完成"的消息，处理该消息时就可以直接获取IO操作结果。

在"发出IO请求"到收到"IO完成"的这段时间里，同步IO模型下，主线程只能挂起;
但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。
这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。
对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。