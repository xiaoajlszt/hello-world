一、调用函数
1、Python内置了很多有用的函数
<1>help()
查看python所有的modules：help("modules")
单看python所有的modules中包含指定字符串的modules： help("modules yourstr")
查看python中常见的topics： help("topics")
查看python标准库中的module：import os.path + help("os.path")
查看python内置的类型：help("list")
查看python类型的成员方法：help("str.find") 
查看python内置函数：help("open")

<2>abs() 取绝对值

<3>max() 取最大值

<4>数据类型转换
1)int('123') //123
  int(12.34) //12
2)float('12.34')  //12.34
3)str(1.23)	 //'1.23'
4)bool('')	 //False
  bool(1)	 //True
  
2、函数名其实就是指向一个函数对象的引用。
完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：
>>> a = abs # 变量a指向abs函数
>>> a(-1)   # 所以也可以通过a调用abs函数
1


二、定义函数
1、空函数
如果想定义一个什么事也不做的空函数，可以使用pass语句：
def nop():
    pass
<1>pass语句什么都不做，那有什么用？
实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。

<2>pass还可以用在其他语句里，比如：
if age >= 18:
    pass
缺少了pass，代码运行就会有语法错误。

2、参数检查
<1>参数个数检查，Python解释器会抛出TypeError
<2>参数类型检查，可用内置函数isinstance()
eg	isinstance(x, (int, float))

3、返回多个值
import math
def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
	
解释：Python函数起始返回的是一个tuple。在语法上tuple可以省略括号，按位置赋给对应的值。

4、函数执行完毕也没有return语句时，自动return None

三、函数的参数
Python函数定义非常灵活，除了必选参数(位置参数)外，还可以使用默认参数、可变参数和关键字参数。

1、默认参数
def power(x,n=2):
	s=1
	while n>0:
		n=n-1
		s=s*x
	return s
	
//n即为默认参数，默认为2

<1>必选参数在前，默认参数在后；否则Python解释器报错。
<2>当有多个参数时，将变化大的参数放在前面，变化小的参数放在后面。变化小的参数可以作为默认参数。

def enroll(name, gender, age=6, city='Beijing')
<3>默认参数可以降低函数调用的难度。只有与默认参数不符时，才需要提供额外的信息。
<4>有多个默认参数时，默认按顺序提供默认参数，如调用enroll('Bob', 'M', 7)，
意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。
<5>有多个默认参数时，也可以指定参数，比如调用enroll('Adam', 'M', city='Tianjin')，
意思是，city参数用传进去的值，其他默认参数继续使用默认值。

<6>默认参数必须指向不变对象。
因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。
此外，由于对象不变，多任务环境下同时读取对象不需要加锁。

2、可变参数
定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了*。
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
函数内部接收到的是一个tuple，因此代码完全不变。调用该函数时，可以传入任意个数参数。




四、递归函数
如果一个函数在内部调用自身本身，这个函数就是递归函数。
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
	
1、使用递归函数需要注意防止栈溢出。
在计算机中，函数调用是通过栈（stack）这种数据结构实现的，
每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：

2、解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，
所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，
不会出现栈溢出的情况。
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
	
注：
尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。
所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。




















